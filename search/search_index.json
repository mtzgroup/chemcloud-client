{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"chemcloud","text":""},{"location":"#chemcloud-a-python-client-for-chemcloud","title":"chemcloud - A Python Client for ChemCloud","text":"<p><code>chemcloud</code> is a python client for the ChemCloud Server. The client provides a simple yet powerful interface to perform computational chemistry calculations using nothing but modern Python and an internet connection.</p> <p>Documentation: https://mtzgroup.github.io/chemcloud-client</p> <p><code>chemcloud</code> works in harmony with a suite of other quantum chemistry tools for fast, structured, and interoperable quantum chemistry.</p>"},{"location":"#the-qc-suite-of-programs","title":"The QC Suite of Programs","text":"<ul> <li>qcio - Beautiful and user friendly data structures for quantum chemistry.</li> <li>qcparse - A library for efficient parsing of quantum chemistry data into structured <code>qcio</code> objects.</li> <li>qcop - A package for operating quantum chemistry programs using <code>qcio</code> standardized data structures. Compatible with <code>TeraChem</code>, <code>psi4</code>, <code>QChem</code>, <code>NWChem</code>, <code>ORCA</code>, <code>Molpro</code>, <code>geomeTRIC</code> and many more.</li> <li>BigChem - A distributed application for running quantum chemistry calculations at scale across clusters of computers or the cloud. Bring multi-node scaling to your favorite quantum chemistry program.</li> <li><code>ChemCloud</code> - A web application and associated Python client for exposing a BigChem cluster securely over the internet.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install chemcloud\n</code></pre>"},{"location":"#quickstart","title":"Quickstart","text":"<ul> <li>Create a ChemCloud account at https://chemcloud.mtzlab.com/signup (or the address of the ChemCloud Server you want to communicate with).</li> <li>Instantiate a client</li> <li>Configure client (only required the very first time you use <code>CCClient</code>)</li> </ul> <pre><code>from chemcloud import CCClient\n\nclient = CCClient()\nclient.configure() # only run this the very first time you use CCClient\n# See supported compute engines on the ChemCloud Server\nclient.supported_engines\n['psi4', 'terachem', ...]\n# Test connection to ChemCloud\nclient.hello_world(\"Colton\")\n'Welcome to ChemCloud, Colton'\n</code></pre> <ul> <li>Run calculations just like you would with <code>qcop</code> except calling <code>client.compute</code> instead of <code>qcop.compute</code>. Rather than getting back an <code>Output</code> object directly, <code>client.compute</code> returns a <code>FutureOutput</code> object which can be used to get the output of the computation once it is complete.</li> </ul> <pre><code>from qcio import Structure, ProgramInput\nfrom chemcloud import CCClient\n\nclient = CCClient()\n\n# Create the structure\nh2o = Structure.open(\"h2o.xyz\")\n\n# Define the program input\nprog_input = ProgramInput(\n    structure=h2o,\n    calctype=\"energy\",\n    model={\"method\": \"hf\", \"basis\": \"sto-3g\"},\n    keywords={\"purify\": \"no\", \"restricted\": False},\n)\n\n# Submit the calculation to the server\nfuture_output = client.compute(\"terachem\", prog_input, collect_files=True)\n# Status can be checked at any time\nfuture_result.status\n# Get the output (blocking)\noutput = future_output.get()\n\n# Inspect the output\noutput.input_data # Input data used by the QC program\noutput.success # Whether the calculation succeeded\noutput.results # All structured results from the calculation\noutput.results.files # Any files returned by the calculation\noutput.stdout # Stdout log from the calculation\noutput.pstdout # Shortcut to print out the stdout in human readable format\noutput.provenance # Provenance information about the calculation\noutput.extras # Any extra information not in the schema\noutput.traceback # Stack trace if calculation failed\noutput.ptraceback # Shortcut to print out the traceback in human readable format\n</code></pre>"},{"location":"#examples","title":"Examples","text":"<p>Examples of various computations can be found in the examples directory.</p>"},{"location":"#support","title":"Support","text":"<p>If you have any issues with <code>chemcloud</code> or would like to request a feature, please open an issue.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#unreleased","title":"unreleased","text":""},{"location":"CHANGELOG/#0111-2024-07-19","title":"0.11.1 - 2024-07-19","text":""},{"location":"CHANGELOG/#changed","title":"Changed","text":"<ul> <li>Updated to qcio 0.11..</li> </ul>"},{"location":"CHANGELOG/#0110-2024-07-12","title":"0.11.0 - 2024-07-12","text":""},{"location":"CHANGELOG/#changed_1","title":"Changed","text":"<p>Updated qcio (0.10.1 -&gt; 0.10.2). <code>Structure.ids</code> -&gt; <code>Structure.identifiers</code></p>"},{"location":"CHANGELOG/#0101-2024-07-11","title":"0.10.1 - 2024-07-11","text":""},{"location":"CHANGELOG/#added","title":"Added","text":"<ul> <li><code>py.typed</code> file for type checking in projects that depend upon <code>chemcloud</code>.</li> </ul>"},{"location":"CHANGELOG/#0100-2024-07-10","title":"0.10.0 - 2024-07-10","text":""},{"location":"CHANGELOG/#changed_2","title":"Changed","text":"<ul> <li>Updated to <code>qcio 0.10.1</code> which uses <code>Structure</code> instead of <code>Molecule</code>.</li> </ul>"},{"location":"CHANGELOG/#090-2024-06-14","title":"0.9.0 - 2024-06-14","text":""},{"location":"CHANGELOG/#changed_3","title":"Changed","text":"<ul> <li>Upgraded to <code>qcio</code> Generics data structures.</li> <li>Upgraded <code>black</code> from <code>^23.0.0</code> to <code>^24.0.0</code>.</li> <li>Renamed <code>collect_wavefucntion</code> kwarg to <code>CCClient.compute(...)</code> to <code>collect_wfn</code>.</li> <li>Updated the response returned by ChemCloud server to have attributes <code>status</code> and <code>program_output</code> from <code>state</code> and <code>results</code>.</li> <li>Rebuilt documentation to reflect new <code>qcio</code> Generics and renamed kwargs.</li> </ul>"},{"location":"CHANGELOG/#083-2023-10-20","title":"0.8.3 - 2023-10-20","text":""},{"location":"CHANGELOG/#changed_4","title":"Changed","text":"<ul> <li>Updated GitHub actions to run on <code>pull_request</code> in addition to <code>push</code>.</li> <li>Migrated dependency <code>uiri/toml</code> to <code>hukkin/tomli</code> (Python &lt; 3.11) or the built-in <code>tomllib</code> (Python &gt;= 3.11)</li> <li>Updated GitHub actions to test against both Python 3.8 and Python 3.11</li> </ul>"},{"location":"CHANGELOG/#082-2023-09-25","title":"0.8.2 - 2023-09-25","text":""},{"location":"CHANGELOG/#changed_5","title":"Changed","text":"<ul> <li>Removed <code>pydantic==2.4.0</code> from supported versions due to immediate bug upon this release. When trying to import <code>CCClient</code> a reference count error appears to trigger a <code>KeyError</code>. Bugs are being tracked here: https://github.com/pydantic/pydantic/issues/7617.</li> </ul>"},{"location":"CHANGELOG/#081-2023-09-20","title":"0.8.1 - 2023-09-20","text":""},{"location":"CHANGELOG/#changed_6","title":"Changed","text":"<ul> <li>Updated to <code>qcio&gt;=0.7.0</code> to account for renaming of <code>DualProgramArgs</code> to <code>SubProgramArgs</code>.</li> </ul>"},{"location":"CHANGELOG/#080-2023-09-19","title":"0.8.0 - 2023-09-19","text":""},{"location":"CHANGELOG/#changed_7","title":"Changed","text":"<ul> <li><code>FutureResult</code> objects now called <code>FutureOutput</code> to keep in harmony with <code>qcio</code> nomenclature.</li> <li>Documentation rewritten to capture API changes with <code>qcio</code> and <code>qcop</code>.</li> <li><code>/examples</code> scripts instantiate a <code>Molecule</code> directly rather than opening <code>h2o.xyz</code> so that code examples can be run directly from the documentation website.</li> <li>All <code>mkdocs</code> and associated documentation packages updated to the latest versions.</li> </ul>"},{"location":"CHANGELOG/#070-2023-09-08","title":"0.7.0 - 2023-09-08","text":""},{"location":"CHANGELOG/#changed_8","title":"Changed","text":"<ul> <li>Dropped <code>QCElemental</code> in favor of <code>qcio</code>.</li> <li>Updated client to work with <code>v2</code> of the ChemCloud server using <code>qcio</code>.</li> <li>Updated DevOps stack to be in harmony with other qc* packages (<code>poetry</code>, <code>GitHub Actions</code>, <code>pre-commit</code>, etc).</li> <li>Updated from pydantic <code>v1</code> -&gt; <code>v2</code>, added <code>pydantic-settings</code> to dependencies.</li> <li>Changed settings <code>chemcloud_default_credentials_profile</code> to <code>chemcloud_credentials_profile</code>.</li> <li>Updated a few names from <code>result</code> to <code>output</code> to be more in harmony with <code>qcio</code> nomenclature.</li> </ul>"},{"location":"CHANGELOG/#added_1","title":"Added","text":"<ul> <li>Publish to pypi from GitHub actions.</li> </ul>"},{"location":"CHANGELOG/#062-2022-12-27","title":"0.6.2 - 2022-12-27","text":""},{"location":"CHANGELOG/#changed_9","title":"Changed","text":"<ul> <li>Updated <code>qcelemental==0.24.0 -&gt; 0.25.1</code></li> </ul>"},{"location":"CHANGELOG/#061-2022-07-19","title":"0.6.1 - 2022-07-19","text":""},{"location":"CHANGELOG/#changed_10","title":"Changed","text":"<ul> <li>Pegged <code>qcelemental</code> to version <code>0.24.0</code> since <code>0.25.0</code> introduces breaking changes. Need to keep this version in sync with <code>ChemCloud</code> server version.</li> </ul>"},{"location":"CHANGELOG/#060-2022-07-19","title":"0.6.0 - 2022-07-19","text":""},{"location":"CHANGELOG/#changed_11","title":"Changed","text":"<ul> <li>Updated project name from <code>qccloud</code> to <code>chemcloud</code></li> </ul>"},{"location":"CHANGELOG/#050-2022-07-15","title":"0.5.0 - 2022-07-15","text":""},{"location":"CHANGELOG/#changed_12","title":"Changed","text":"<ul> <li>Updated project name from <code>tccloud</code> to <code>qccloud</code></li> </ul>"},{"location":"CHANGELOG/#041-2022-05-07","title":"0.4.1 - 2022-05-07","text":""},{"location":"CHANGELOG/#changed_13","title":"Changed","text":"<ul> <li>Upped the default timeout on http reads from 5.0s -&gt; 20.0s.</li> </ul>"},{"location":"CHANGELOG/#040-2022-4-02","title":"0.4.0 - 2022-4-02","text":""},{"location":"CHANGELOG/#added_2","title":"Added","text":"<ul> <li><code>to_file()</code> and <code>from_file()</code> methods to easily save compute job ids for later retrieval.</li> </ul>"},{"location":"CHANGELOG/#changed_14","title":"Changed","text":"<ul> <li>Simplified management of task ids between client and server. Only need to send a single id to server even if a batch computation was initiated.</li> </ul>"},{"location":"CHANGELOG/#removed","title":"Removed","text":"<ul> <li>Support for Python3.6. Python3.6 end-of-lif'ed December 23, 2021.</li> </ul>"},{"location":"CHANGELOG/#031-2022-03-27","title":"0.3.1 - 2022-03-27","text":""},{"location":"CHANGELOG/#added_3","title":"Added","text":"<ul> <li>Decode b64 encoded data returned from server in <code>AtomicResult.extra['tcfe:keywords']</code></li> </ul>"},{"location":"CHANGELOG/#changed_15","title":"Changed","text":"<ul> <li>Updated <code>config.settings.tcfe_config_kwargs = \"tcfe:config</code> -&gt; <code>config.settings.tcfe_keywords = \"tcfe:keywords</code></li> </ul>"},{"location":"CHANGELOG/#030-2022-03-26","title":"0.3.0 - 2022-03-26","text":""},{"location":"CHANGELOG/#added_4","title":"Added","text":"<ul> <li>Support for <code>AtomicInput.protocols.native_files</code>. User can now request QC package specific files generated during a computation.</li> <li>Added support for TeraChem-specific <code>native_files</code>. c0/ca0/cb0 bytes files (or any bytes data) placed in <code>AtomicInput.extras['tcfe:keywords']</code> will be automatically base64 encoded and sent to the server. The enables seeding computations with a wave function as an initial guess.</li> <li>Base64 encoded <code>native_files</code> returned from server will be automatically decoded to bytes.</li> </ul>"},{"location":"CHANGELOG/#024-2021-06-07","title":"0.2.4 - 2021-06-07","text":""},{"location":"CHANGELOG/#added_5","title":"Added","text":"<ul> <li>Private compute queues to <code>compute()</code> and <code>compute_procedure()</code></li> </ul>"},{"location":"CHANGELOG/#023-2021-06-04","title":"0.2.3 - 2021-06-04","text":""},{"location":"CHANGELOG/#added_6","title":"Added","text":"<ul> <li>Batch compute for both <code>compute()</code> and <code>compute_procedure()</code> methods</li> <li><code>FutureResultGroup</code> for batch computations</li> </ul>"},{"location":"CHANGELOG/#changed_16","title":"Changed","text":"<ul> <li>Added <code>pydantic</code> <code>BaseModel</code> as base for <code>FutureResult</code> objects.</li> </ul>"},{"location":"CHANGELOG/#022-2021-05-21","title":"0.2.2 - 2021-05-21","text":""},{"location":"CHANGELOG/#added_7","title":"Added","text":"<ul> <li>Extended documentation to include a Code Reference section and much more comprehensive documentation of the main objects.</li> <li>Added <code>compute_procedure</code> to <code>TCClient</code> for geometry optimizations.</li> <li>Added <code>TCClient.version</code> property for quick version checks.</li> </ul>"},{"location":"CHANGELOG/#021-2021-03-05","title":"0.2.1 - 2021-03-05","text":""},{"location":"CHANGELOG/#added_8","title":"Added","text":"<ul> <li>Changelog</li> <li>User documentation</li> <li>Website for documentation</li> </ul>"},{"location":"CHANGELOG/#020-2021-02-26","title":"0.2.0 - 2021-02-26","text":""},{"location":"CHANGELOG/#added_9","title":"Added","text":"<ul> <li>Added <code>TaskStatus</code> enum to hold all task statuses.</li> <li>Basic documentation on main classes.</li> <li>[core_decisions.md] to document thinking behind architectural choices.</li> </ul>"},{"location":"CHANGELOG/#changed_17","title":"Changed","text":"<ul> <li><code>FutureResult.get()</code> to return either an <code>AtomicResult</code> or a <code>FailedComputation</code></li> <li>Simplified README.md overview to use dictionaries instead of classes. Results in simpler tutorial with fewer imports.</li> </ul>"},{"location":"CHANGELOG/#011-2021-01-22","title":"0.1.1 - 2021-01-22","text":""},{"location":"CHANGELOG/#added_10","title":"Added","text":"<ul> <li><code>TCClient</code> that can manage credentials, submit AtomicInput computations, and retrieve AtomicResult output from TeraChem Cloud.</li> <li><code>_RequestsClient</code> class that handles all network requests to TeraChem Cloud server</li> <li><code>FutureResults</code> object that is created from a <code>task_id</code> and can be used to retrieve a result once finished.</li> </ul>"},{"location":"dev-decisions/","title":"Core Development Decisions","text":""},{"location":"dev-decisions/#_requestsclient-class","title":"_RequestsClient Class","text":"<ul> <li><code>_RequestsClient</code> public http methods (like <code>compute()</code> and <code>result()</code> should always return Python objects. This gives a layer of abstraction between callers who want to think in terms of Python data objects and the <code>_RequestsClient</code> which thinks in terms of http requests and <code>json</code> data structures.</li> </ul> <p>I'm starting to have second thoughts about this ^^ decision. It feels like the <code>_RequestsClient</code> is starting to take on too much responsibility. It accepts python data types as parameters, and returns python data types as it if were an end-user class. It isn't. It's meant to be a utility class used by end-user objects such as <code>CCClient</code> and <code>FutureOutput</code> objects. I think it should return data more directly from the ChemCloud API and let the other classes handle this data. This becomes more apparent as I add <code>pydantic</code> to my data models and realize I'd rather have them pass rawer data types to the <code>_RequestsClient</code> and then handle the results of an API call inside their own class. Maybe the <code>compute()</code> method on the <code>_RequestsClient</code> should go away and these should live exclusively on the <code>CCClient</code> object which then utilizes <code>request</code> and <code>authenticated_request</code> to access ChemCloud.</p>"},{"location":"code-reference/CCClient/","title":"CCClient","text":"<p>Main client object to perform computations using ChemCloud.</p> Source code in <code>chemcloud/client.py</code> <pre><code>class CCClient:\n    \"\"\"Main client object to perform computations using ChemCloud.\"\"\"\n\n    def __init__(\n        self,\n        *,\n        chemcloud_username: Optional[str] = None,\n        chemcloud_password: Optional[str] = None,\n        profile: Optional[str] = None,\n        chemcloud_domain: Optional[str] = None,\n    ):\n        \"\"\"\n        Initialize a CCClient object.\n\n        Parameters:\n            chemcloud_username: ChemCloud username\n            chemcloud_password: ChemCloud password\n            profile: Authentication profile name\n            chemcloud_domain: Domain of ChemCloud instance to connect to\n\n        !!! Danger\n            It is not recommended to pass your ChemCloud username and\n            password directly to a `CCClient`. Instead instantiate a client with no\n            credentials `client = CCClient()` and then run `client.configure()` to\n            securely set up your authentication credentials for ChemCloud.\n        \"\"\"\n        self._client = _RequestsClient(\n            chemcloud_username=chemcloud_username,\n            chemcloud_password=chemcloud_password,\n            profile=profile,\n            chemcloud_domain=chemcloud_domain,\n        )\n        self._openapi_spec: Optional[Dict] = None\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"{type(self).__name__}({self._client._chemcloud_domain}, \"\n            f\"profile={self.profile})\"\n        )\n\n    def _set_openapi_specification(self):\n        \"\"\"Gets OpenAPI specification from ChemCloud Server\"\"\"\n        self._openapi_spec = self._client._request(\n            \"get\", \"/openapi.json\", api_call=False\n        )\n\n    @property\n    def version(self) -&gt; str:\n        \"\"\"Returns chemcloud client version\"\"\"\n        return __version__\n\n    @property\n    def profile(self) -&gt; str:\n        \"\"\"Profile being used for authentication with ChemCloud.\n\n        Returns:\n            The name of the credentials profile being used with the current client.\n        \"\"\"\n        return self._client._profile\n\n    @property\n    def supported_programs(self) -&gt; List[str]:\n        \"\"\"Compute programs currently supported by ChemCloud.\n\n        Returns:\n            List of programs currently supported by ChemCloud.\"\"\"\n        if not self._openapi_spec:\n            self._set_openapi_specification()\n        try:\n            assert self._openapi_spec is not None\n            programs = self._openapi_spec[\"components\"][\"schemas\"][\"SupportedPrograms\"][\n                \"enum\"\n            ]\n        except IndexError:\n            print(\"Cannot locate currently supported programs.\")\n            programs = [\"\"]\n        return programs\n\n    def hello_world(self, name: Optional[str] = None) -&gt; str:\n        \"\"\"A simple endpoint to check connectivity to ChemCloud.\n\n        Parameters:\n            name: Your name\n\n        Returns:\n            A message from ChemCloud if the client was able to successfully\n            connect.\n        \"\"\"\n        return self._client.hello_world(name)\n\n    def compute(\n        self,\n        program: str,\n        inp_obj: QCIOInputsOrList,\n        *,\n        collect_stdout: bool = True,\n        collect_files: bool = False,\n        collect_wfn: bool = False,\n        rm_scratch_dir: bool = True,\n        propagate_wfn: bool = False,\n        queue: Optional[str] = None,\n    ) -&gt; Union[FutureOutput, FutureOutputGroup]:\n        \"\"\"Submit a computation to ChemCloud.\n\n        Parameters:\n            program: A program name matching one of the `self.supported_programs`\n            inp_obj: The input object to be used for the computation. This can be a\n                single input object or a list of input objects.\n            collect_stdout: Whether to collect stdout/stderr from the program as output.\n                Failed computations will always collect stdout/stderr.\n            collect_files: Collect all files generated by the QC program as output.\n            collect_wfn: Collect the wavefunction file(s) from the calculation.\n                Not every program will support this. Use collect_files to collect\n                all files including the wavefunction.\n            rm_scratch_dir: Delete the scratch directory after the program exits. Should\n                only be set to False for debugging purposes.\n            propagate_wfn: For any adapter performing a sequential task, such\n                as a geometry optimization, propagate the wavefunction from the previous\n                step to the next step. This is useful for accelerating convergence by\n                using a previously computed wavefunction as a starting guess. This will\n                be ignored if the adapter for a given qc program does not support it.\n            queue: The name of a private compute queue. If None, default queue is used\n\n        Returns:\n            Object providing access to a computation's eventual result. You can check a\n            computation's status by running `.status` on the `FutureOutput` object or\n            `.get()` to block and retrieve the computation's final result.\n        \"\"\"\n        if self.supported_programs is not None:\n            assert (\n                program in self.supported_programs\n            ), f\"Please use one of the following programs: {self.supported_programs}\"\n\n        compute_params = dict(\n            program=program,\n            collect_stdout=collect_stdout,\n            collect_files=collect_files,\n            collect_wfn=collect_wfn,\n            rm_scratch_dir=rm_scratch_dir,\n            propagate_wfn=propagate_wfn,\n            queue=queue,\n        )\n        return self._client.compute(inp_obj, compute_params)\n\n    def configure(self, profile: str = settings.chemcloud_credentials_profile) -&gt; None:\n        \"\"\"Configure profiles for authentication with ChemCloud.\n\n        Parameters:\n            profile: Optional value to create a named profile for use with QC\n                Cloud. No value needs to be passed and most users will only have one\n                login with ChemCloud. CCClient will access the profile by\n                default without a specific name being passed. Pass a value if you have\n                multiple logins to ChemCloud.\n        Note:\n            Configures `chemcloud` to use the passed credentials automatically in the\n            future. You will not need to run `.configure()` the next time you use the\n            `chemcloud`.\n\n        \"\"\"\n        print(\n            \"\u2705 If you don't get have an account please signup at: \"\n            f\"{self._client._chemcloud_domain}/signup\"\n        )\n        access_token, refresh_token = self._client._set_tokens_from_user_input()\n        self._client.write_tokens_to_credentials_file(\n            access_token, refresh_token, profile=profile\n        )\n        print(\n            f\"'{profile}' profile configured! Username/password not required for \"\n            \"future use of CCClient\"\n        )\n</code></pre>"},{"location":"code-reference/CCClient/#chemcloud.client.CCClient.profile","title":"<code>profile: str</code>  <code>property</code>","text":"<p>Profile being used for authentication with ChemCloud.</p> <p>Returns:</p> Type Description <code>str</code> <p>The name of the credentials profile being used with the current client.</p>"},{"location":"code-reference/CCClient/#chemcloud.client.CCClient.supported_programs","title":"<code>supported_programs: List[str]</code>  <code>property</code>","text":"<p>Compute programs currently supported by ChemCloud.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of programs currently supported by ChemCloud.</p>"},{"location":"code-reference/CCClient/#chemcloud.client.CCClient.version","title":"<code>version: str</code>  <code>property</code>","text":"<p>Returns chemcloud client version</p>"},{"location":"code-reference/CCClient/#chemcloud.client.CCClient.__init__","title":"<code>__init__(*, chemcloud_username=None, chemcloud_password=None, profile=None, chemcloud_domain=None)</code>","text":"<p>Initialize a CCClient object.</p> <p>Parameters:</p> Name Type Description Default <code>chemcloud_username</code> <code>Optional[str]</code> <p>ChemCloud username</p> <code>None</code> <code>chemcloud_password</code> <code>Optional[str]</code> <p>ChemCloud password</p> <code>None</code> <code>profile</code> <code>Optional[str]</code> <p>Authentication profile name</p> <code>None</code> <code>chemcloud_domain</code> <code>Optional[str]</code> <p>Domain of ChemCloud instance to connect to</p> <code>None</code> <p>Danger</p> <p>It is not recommended to pass your ChemCloud username and password directly to a <code>CCClient</code>. Instead instantiate a client with no credentials <code>client = CCClient()</code> and then run <code>client.configure()</code> to securely set up your authentication credentials for ChemCloud.</p> Source code in <code>chemcloud/client.py</code> <pre><code>def __init__(\n    self,\n    *,\n    chemcloud_username: Optional[str] = None,\n    chemcloud_password: Optional[str] = None,\n    profile: Optional[str] = None,\n    chemcloud_domain: Optional[str] = None,\n):\n    \"\"\"\n    Initialize a CCClient object.\n\n    Parameters:\n        chemcloud_username: ChemCloud username\n        chemcloud_password: ChemCloud password\n        profile: Authentication profile name\n        chemcloud_domain: Domain of ChemCloud instance to connect to\n\n    !!! Danger\n        It is not recommended to pass your ChemCloud username and\n        password directly to a `CCClient`. Instead instantiate a client with no\n        credentials `client = CCClient()` and then run `client.configure()` to\n        securely set up your authentication credentials for ChemCloud.\n    \"\"\"\n    self._client = _RequestsClient(\n        chemcloud_username=chemcloud_username,\n        chemcloud_password=chemcloud_password,\n        profile=profile,\n        chemcloud_domain=chemcloud_domain,\n    )\n    self._openapi_spec: Optional[Dict] = None\n</code></pre>"},{"location":"code-reference/CCClient/#chemcloud.client.CCClient.compute","title":"<code>compute(program, inp_obj, *, collect_stdout=True, collect_files=False, collect_wfn=False, rm_scratch_dir=True, propagate_wfn=False, queue=None)</code>","text":"<p>Submit a computation to ChemCloud.</p> <p>Parameters:</p> Name Type Description Default <code>program</code> <code>str</code> <p>A program name matching one of the <code>self.supported_programs</code></p> required <code>inp_obj</code> <code>QCIOInputsOrList</code> <p>The input object to be used for the computation. This can be a single input object or a list of input objects.</p> required <code>collect_stdout</code> <code>bool</code> <p>Whether to collect stdout/stderr from the program as output. Failed computations will always collect stdout/stderr.</p> <code>True</code> <code>collect_files</code> <code>bool</code> <p>Collect all files generated by the QC program as output.</p> <code>False</code> <code>collect_wfn</code> <code>bool</code> <p>Collect the wavefunction file(s) from the calculation. Not every program will support this. Use collect_files to collect all files including the wavefunction.</p> <code>False</code> <code>rm_scratch_dir</code> <code>bool</code> <p>Delete the scratch directory after the program exits. Should only be set to False for debugging purposes.</p> <code>True</code> <code>propagate_wfn</code> <code>bool</code> <p>For any adapter performing a sequential task, such as a geometry optimization, propagate the wavefunction from the previous step to the next step. This is useful for accelerating convergence by using a previously computed wavefunction as a starting guess. This will be ignored if the adapter for a given qc program does not support it.</p> <code>False</code> <code>queue</code> <code>Optional[str]</code> <p>The name of a private compute queue. If None, default queue is used</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[FutureOutput, FutureOutputGroup]</code> <p>Object providing access to a computation's eventual result. You can check a</p> <code>Union[FutureOutput, FutureOutputGroup]</code> <p>computation's status by running <code>.status</code> on the <code>FutureOutput</code> object or</p> <code>Union[FutureOutput, FutureOutputGroup]</code> <p><code>.get()</code> to block and retrieve the computation's final result.</p> Source code in <code>chemcloud/client.py</code> <pre><code>def compute(\n    self,\n    program: str,\n    inp_obj: QCIOInputsOrList,\n    *,\n    collect_stdout: bool = True,\n    collect_files: bool = False,\n    collect_wfn: bool = False,\n    rm_scratch_dir: bool = True,\n    propagate_wfn: bool = False,\n    queue: Optional[str] = None,\n) -&gt; Union[FutureOutput, FutureOutputGroup]:\n    \"\"\"Submit a computation to ChemCloud.\n\n    Parameters:\n        program: A program name matching one of the `self.supported_programs`\n        inp_obj: The input object to be used for the computation. This can be a\n            single input object or a list of input objects.\n        collect_stdout: Whether to collect stdout/stderr from the program as output.\n            Failed computations will always collect stdout/stderr.\n        collect_files: Collect all files generated by the QC program as output.\n        collect_wfn: Collect the wavefunction file(s) from the calculation.\n            Not every program will support this. Use collect_files to collect\n            all files including the wavefunction.\n        rm_scratch_dir: Delete the scratch directory after the program exits. Should\n            only be set to False for debugging purposes.\n        propagate_wfn: For any adapter performing a sequential task, such\n            as a geometry optimization, propagate the wavefunction from the previous\n            step to the next step. This is useful for accelerating convergence by\n            using a previously computed wavefunction as a starting guess. This will\n            be ignored if the adapter for a given qc program does not support it.\n        queue: The name of a private compute queue. If None, default queue is used\n\n    Returns:\n        Object providing access to a computation's eventual result. You can check a\n        computation's status by running `.status` on the `FutureOutput` object or\n        `.get()` to block and retrieve the computation's final result.\n    \"\"\"\n    if self.supported_programs is not None:\n        assert (\n            program in self.supported_programs\n        ), f\"Please use one of the following programs: {self.supported_programs}\"\n\n    compute_params = dict(\n        program=program,\n        collect_stdout=collect_stdout,\n        collect_files=collect_files,\n        collect_wfn=collect_wfn,\n        rm_scratch_dir=rm_scratch_dir,\n        propagate_wfn=propagate_wfn,\n        queue=queue,\n    )\n    return self._client.compute(inp_obj, compute_params)\n</code></pre>"},{"location":"code-reference/CCClient/#chemcloud.client.CCClient.configure","title":"<code>configure(profile=settings.chemcloud_credentials_profile)</code>","text":"<p>Configure profiles for authentication with ChemCloud.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>str</code> <p>Optional value to create a named profile for use with QC Cloud. No value needs to be passed and most users will only have one login with ChemCloud. CCClient will access the profile by default without a specific name being passed. Pass a value if you have multiple logins to ChemCloud.</p> <code>chemcloud_credentials_profile</code> <p>Note:     Configures <code>chemcloud</code> to use the passed credentials automatically in the     future. You will not need to run <code>.configure()</code> the next time you use the     <code>chemcloud</code>.</p> Source code in <code>chemcloud/client.py</code> <pre><code>def configure(self, profile: str = settings.chemcloud_credentials_profile) -&gt; None:\n    \"\"\"Configure profiles for authentication with ChemCloud.\n\n    Parameters:\n        profile: Optional value to create a named profile for use with QC\n            Cloud. No value needs to be passed and most users will only have one\n            login with ChemCloud. CCClient will access the profile by\n            default without a specific name being passed. Pass a value if you have\n            multiple logins to ChemCloud.\n    Note:\n        Configures `chemcloud` to use the passed credentials automatically in the\n        future. You will not need to run `.configure()` the next time you use the\n        `chemcloud`.\n\n    \"\"\"\n    print(\n        \"\u2705 If you don't get have an account please signup at: \"\n        f\"{self._client._chemcloud_domain}/signup\"\n    )\n    access_token, refresh_token = self._client._set_tokens_from_user_input()\n    self._client.write_tokens_to_credentials_file(\n        access_token, refresh_token, profile=profile\n    )\n    print(\n        f\"'{profile}' profile configured! Username/password not required for \"\n        \"future use of CCClient\"\n    )\n</code></pre>"},{"location":"code-reference/CCClient/#chemcloud.client.CCClient.hello_world","title":"<code>hello_world(name=None)</code>","text":"<p>A simple endpoint to check connectivity to ChemCloud.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Your name</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A message from ChemCloud if the client was able to successfully</p> <code>str</code> <p>connect.</p> Source code in <code>chemcloud/client.py</code> <pre><code>def hello_world(self, name: Optional[str] = None) -&gt; str:\n    \"\"\"A simple endpoint to check connectivity to ChemCloud.\n\n    Parameters:\n        name: Your name\n\n    Returns:\n        A message from ChemCloud if the client was able to successfully\n        connect.\n    \"\"\"\n    return self._client.hello_world(name)\n</code></pre>"},{"location":"code-reference/FutureOutputs/","title":"FutureOutputs","text":""},{"location":"code-reference/FutureOutputs/#chemcloud.models.FutureOutput","title":"<code>FutureOutput</code>","text":"<p>             Bases: <code>FutureOutputBase</code></p> <p>Single computation result</p> Source code in <code>chemcloud/models.py</code> <pre><code>class FutureOutput(FutureOutputBase):\n    \"\"\"Single computation result\"\"\"\n\n    result: Optional[QCIOOutputs] = None\n</code></pre>"},{"location":"code-reference/FutureOutputs/#chemcloud.models.FutureOutputBase","title":"<code>FutureOutputBase</code>","text":"<p>             Bases: <code>BaseModel</code>, <code>ABC</code></p> <p>Base class for FutureOutputs</p> <p>Attributes:</p> Name Type Description <code>task_id</code> <code>str</code> <p>The task_id for primary task submitted to ChemCloud. May correspond to a single task or group of tasks.</p> <code>client</code> <code>Any</code> <p>The _RequestsClient to use for http requests to ChemCloud.</p> <code>result</code> <code>Optional[QCIOOutputsOrList]</code> <p>Primary return value resulting from computation.</p> Caution <p>A FutureOutput should never be instantiated directly. <code>CCClient.compute(...)</code> will return one when you submit a computation.</p> Source code in <code>chemcloud/models.py</code> <pre><code>class FutureOutputBase(BaseModel, ABC):\n    \"\"\"Base class for FutureOutputs\n\n    Attributes:\n        task_id: The task_id for primary task submitted to ChemCloud. May correspond to\n            a single task or group of tasks.\n        client: The _RequestsClient to use for http requests to ChemCloud.\n        result: Primary return value resulting from computation.\n\n    Caution:\n        A FutureOutput should never be instantiated directly.\n        `CCClient.compute(...)` will return one when you submit a computation.\n    \"\"\"\n\n    task_id: str\n    result: Optional[QCIOOutputsOrList] = None\n    client: Any\n    _state: TaskStatus = TaskStatus.PENDING\n\n    model_config = {\"validate_assignment\": True}\n\n    def get(\n        self,\n        timeout: Optional[float] = None,  # in seconds\n        interval: float = 1.0,\n    ) -&gt; Optional[QCIOOutputsOrList]:\n        \"\"\"Block until a calculation is complete and return the result.\n\n        Parameters:\n            timeout: The number of seconds to wait for a computation before raising a\n                TimeOutError.\n            interval: The amount of time to wait between calls to ChemCloud to\n                check a computation's status.\n\n        Returns:\n            Resultant values from a computation.\n\n        Exceptions:\n            TimeoutError: Raised if timeout interval exceeded.\n        \"\"\"\n        if self.result:\n            return self.result\n\n        start_time = time()\n\n        # self._state check prevents 401 errors from ChemCloud when the job completed\n        # but the server failed to return a result (e.g., due to .program_output not)\n        # being set correctly by qcio/BigChem.\n        # TODO: Make a clearer contract between Server and Client re: states. This got\n        # a bit messy as I switched mimicking celery states to the more simplified setup\n        # I have now. This can be simplified further.\n        while not self.result and self._state not in {\"COMPLETE\", \"FAILURE\"}:\n            # Calling self.status returns status and sets self.result if task complete\n            self.status\n            if timeout:\n                if (time() - start_time) &gt; timeout:\n                    raise TimeoutError(\n                        f\"Your timeout limit of {timeout} seconds was exceeded\"\n                    )\n            sleep(interval)\n\n        return self.result\n\n    def _output(self):\n        \"\"\"Return output from server\"\"\"\n        return self.client.output(self.task_id)\n\n    @property\n    def status(self) -&gt; str:\n        \"\"\"Check status of compute task.\n\n        Returns:\n            Status of computation.\n\n        Note:\n            Sets self.result if task is complete.\n        \"\"\"\n        if self.result:\n            return self._state\n        self._state, self.result = self._output()\n        return self._state\n</code></pre>"},{"location":"code-reference/FutureOutputs/#chemcloud.models.FutureOutputBase.status","title":"<code>status: str</code>  <code>property</code>","text":"<p>Check status of compute task.</p> <p>Returns:</p> Type Description <code>str</code> <p>Status of computation.</p> Note <p>Sets self.result if task is complete.</p>"},{"location":"code-reference/FutureOutputs/#chemcloud.models.FutureOutputBase.get","title":"<code>get(timeout=None, interval=1.0)</code>","text":"<p>Block until a calculation is complete and return the result.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>Optional[float]</code> <p>The number of seconds to wait for a computation before raising a TimeOutError.</p> <code>None</code> <code>interval</code> <code>float</code> <p>The amount of time to wait between calls to ChemCloud to check a computation's status.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>Optional[QCIOOutputsOrList]</code> <p>Resultant values from a computation.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>Raised if timeout interval exceeded.</p> Source code in <code>chemcloud/models.py</code> <pre><code>def get(\n    self,\n    timeout: Optional[float] = None,  # in seconds\n    interval: float = 1.0,\n) -&gt; Optional[QCIOOutputsOrList]:\n    \"\"\"Block until a calculation is complete and return the result.\n\n    Parameters:\n        timeout: The number of seconds to wait for a computation before raising a\n            TimeOutError.\n        interval: The amount of time to wait between calls to ChemCloud to\n            check a computation's status.\n\n    Returns:\n        Resultant values from a computation.\n\n    Exceptions:\n        TimeoutError: Raised if timeout interval exceeded.\n    \"\"\"\n    if self.result:\n        return self.result\n\n    start_time = time()\n\n    # self._state check prevents 401 errors from ChemCloud when the job completed\n    # but the server failed to return a result (e.g., due to .program_output not)\n    # being set correctly by qcio/BigChem.\n    # TODO: Make a clearer contract between Server and Client re: states. This got\n    # a bit messy as I switched mimicking celery states to the more simplified setup\n    # I have now. This can be simplified further.\n    while not self.result and self._state not in {\"COMPLETE\", \"FAILURE\"}:\n        # Calling self.status returns status and sets self.result if task complete\n        self.status\n        if timeout:\n            if (time() - start_time) &gt; timeout:\n                raise TimeoutError(\n                    f\"Your timeout limit of {timeout} seconds was exceeded\"\n                )\n        sleep(interval)\n\n    return self.result\n</code></pre>"},{"location":"code-reference/FutureOutputs/#chemcloud.models.FutureOutputGroup","title":"<code>FutureOutputGroup</code>","text":"<p>             Bases: <code>FutureOutputBase</code></p> <p>Group computation result</p> Source code in <code>chemcloud/models.py</code> <pre><code>class FutureOutputGroup(FutureOutputBase):\n    \"\"\"Group computation result\"\"\"\n\n    result: Optional[List[QCIOOutputs]] = None\n\n    def _output(self):\n        \"\"\"Return result from server. Remove GROUP_ID_PREFIX from id.\"\"\"\n        return self.client.output(self.task_id.replace(GROUP_ID_PREFIX, \"\"))\n\n    @field_validator(\"task_id\")\n    @classmethod\n    def validate_id(cls, val):\n        \"\"\"Prepend id with GROUP_ID_PREFIX.\n\n        NOTE:\n            This makes instantiating FutureOutputGroups from saved ids easier because\n            they are differentiated from FutureOutput ids.\n        \"\"\"\n        if not val.startswith(GROUP_ID_PREFIX):\n            val = GROUP_ID_PREFIX + val\n        return val\n</code></pre>"},{"location":"code-reference/FutureOutputs/#chemcloud.models.FutureOutputGroup.validate_id","title":"<code>validate_id(val)</code>  <code>classmethod</code>","text":"<p>Prepend id with GROUP_ID_PREFIX.</p> NOTE <p>This makes instantiating FutureOutputGroups from saved ids easier because they are differentiated from FutureOutput ids.</p> Source code in <code>chemcloud/models.py</code> <pre><code>@field_validator(\"task_id\")\n@classmethod\ndef validate_id(cls, val):\n    \"\"\"Prepend id with GROUP_ID_PREFIX.\n\n    NOTE:\n        This makes instantiating FutureOutputGroups from saved ids easier because\n        they are differentiated from FutureOutput ids.\n    \"\"\"\n    if not val.startswith(GROUP_ID_PREFIX):\n        val = GROUP_ID_PREFIX + val\n    return val\n</code></pre>"},{"location":"code-reference/FutureOutputs/#chemcloud.models.TaskStatus","title":"<code>TaskStatus</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Tasks status for a submitted compute job.</p> Source code in <code>chemcloud/models.py</code> <pre><code>class TaskStatus(str, Enum):\n    \"\"\"Tasks status for a submitted compute job.\"\"\"\n\n    #: Task state is unknown (assumed pending since you know the id).\n    PENDING = \"PENDING\"\n    COMPLETE = \"COMPLETE\"\n    FAILURE = \"FAILURE\"\n</code></pre>"},{"location":"code-reference/FutureOutputs/#chemcloud.models.from_file","title":"<code>from_file(path, client)</code>","text":"<p>Instantiate FutureOutputs or FutureOutputGroups from file of result ids</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to file containing the ids</p> required <code>client</code> <code>Any</code> <p>Instantiated CCClient object</p> required Source code in <code>chemcloud/models.py</code> <pre><code>def from_file(\n    path: Union[str, Path],\n    client: Any,\n) -&gt; List[Union[FutureOutput, FutureOutputGroup]]:\n    \"\"\"Instantiate FutureOutputs or FutureOutputGroups from file of result ids\n\n    Params:\n        path: Path to file containing the ids\n        client: Instantiated CCClient object\n    \"\"\"\n    frs: List[Union[FutureOutput, FutureOutputGroup]] = []\n    with open(path) as f:\n        for id in f.readlines():\n            id = id.strip()\n            model: Union[Type[FutureOutput], Type[FutureOutputGroup]]\n            if id.startswith(GROUP_ID_PREFIX):\n                model = FutureOutputGroup\n            else:\n                model = FutureOutput\n            frs.append(model(task_id=id, client=client._client))\n\n    assert len(frs) &gt; 0, \"No ids found in file!\"\n    return frs\n</code></pre>"},{"location":"code-reference/FutureOutputs/#chemcloud.models.to_file","title":"<code>to_file(future_results, path, *, append=False)</code>","text":"<p>Write FutureOutputs to disk for later retrieval</p> <p>Parameters:</p> Name Type Description Default <code>future_results</code> <code>Union[FutureOutputBase, List[FutureOutputBase]]</code> <p>List of or single FutureOutput or FutureOutputGroup</p> required <code>path</code> <code>Union[str, Path]</code> <p>File path to results file</p> required <code>append</code> <code>bool</code> <p>Append results to an existing file if True, else create new file</p> <code>False</code> Source code in <code>chemcloud/models.py</code> <pre><code>def to_file(\n    future_results: Union[FutureOutputBase, List[FutureOutputBase]],\n    path: Union[str, Path],\n    *,\n    append: bool = False,\n) -&gt; None:\n    \"\"\"Write FutureOutputs to disk for later retrieval\n\n    Params:\n        future_results: List of or single FutureOutput or FutureOutputGroup\n        path: File path to results file\n        append: Append results to an existing file if True, else create new file\n    \"\"\"\n    if not isinstance(future_results, list):\n        future_results = [future_results]\n\n    with open(path, f\"{'a' if append else 'w'}\") as f:\n        f.writelines([f\"{fr.task_id}\\n\" for fr in future_results])\n</code></pre>"},{"location":"code-reference/ProgramInputs/","title":"ProgramInputs","text":"<p>Input models for quantum chemistry calculations.</p>"},{"location":"code-reference/ProgramInputs/#qcio.models.inputs.DualProgramInput","title":"<code>DualProgramInput</code>","text":"<p>             Bases: <code>ProgramArgsSub</code>, <code>ProgramInput</code></p> <p>Input for a two program calculation.</p> <p>Attributes:</p> Name Type Description <code>calctype</code> <p>The type of calculation to be performed.</p> <code>structure</code> <p>The structure to be used in the calculation.</p> <code>keywords</code> <p>Dict of keywords to be passed to the program. Defaults to empty dict.</p> <code>files</code> <p>A dict mapping filename to str or bytes data.</p> <code>subprogram</code> <p>The name of the subprogram to use.</p> <code>subprogram_args</code> <p>The program input for the subprogram.</p> <code>extras</code> <p>Additional information to bundle with the object. Use for schema development and scratch space.</p> Source code in <code>qcio/models/inputs.py</code> <pre><code>class DualProgramInput(ProgramArgsSub, ProgramInput):\n    \"\"\"Input for a two program calculation.\n\n    Attributes:\n        calctype: The type of calculation to be performed.\n        structure: The structure to be used in the calculation.\n        keywords: Dict of keywords to be passed to the program. Defaults to empty dict.\n        files: A dict mapping filename to str or bytes data.\n        subprogram: The name of the subprogram to use.\n        subprogram_args: The program input for the subprogram.\n        extras: Additional information to bundle with the object. Use for schema\n            development and scratch space.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code-reference/ProgramInputs/#qcio.models.inputs.FileInput","title":"<code>FileInput</code>","text":"<p>             Bases: <code>Files</code></p> <p>File and command line argument inputs for a calculation.</p> <p>Attributes:</p> Name Type Description <code>files</code> <p>A dict mapping filename to str or bytes data.</p> <code>cmdline_args</code> <code>List[str]</code> <p>A list of command line arguments to be passed to the program.</p> <code>extras</code> <code>List[str]</code> <p>Additional information to bundle with the object. Use for schema development and scratch space.</p> Source code in <code>qcio/models/inputs.py</code> <pre><code>class FileInput(Files):\n    \"\"\"File and command line argument inputs for a calculation.\n\n    Attributes:\n        files: A dict mapping filename to str or bytes data.\n        cmdline_args: A list of command line arguments to be passed to the program.\n        extras: Additional information to bundle with the object. Use for schema\n            development and scratch space.\n    \"\"\"\n\n    cmdline_args: List[str] = []\n\n    @classmethod\n    def from_directory(cls, directory: Union[Path, str], **kwargs) -&gt; Self:\n        \"\"\"Collect all files from directory and instantiate an object.\"\"\"\n        obj = cls(**kwargs)\n        directory = Path(directory)\n        obj.add_files(directory)\n        return obj\n</code></pre>"},{"location":"code-reference/ProgramInputs/#qcio.models.inputs.FileInput.from_directory","title":"<code>from_directory(directory, **kwargs)</code>  <code>classmethod</code>","text":"<p>Collect all files from directory and instantiate an object.</p> Source code in <code>qcio/models/inputs.py</code> <pre><code>@classmethod\ndef from_directory(cls, directory: Union[Path, str], **kwargs) -&gt; Self:\n    \"\"\"Collect all files from directory and instantiate an object.\"\"\"\n    obj = cls(**kwargs)\n    directory = Path(directory)\n    obj.add_files(directory)\n    return obj\n</code></pre>"},{"location":"code-reference/ProgramInputs/#qcio.models.inputs.ProgramArgs","title":"<code>ProgramArgs</code>","text":"<p>             Bases: <code>FileInput</code>, <code>_KeywordsMixin</code></p> <p>Generic arguments for a program without a calctype or structure specification.</p> <p>This class is needed for multi-step calculations where the calctype and structure are specified only once for the entire calculation, e.g., multistep_opt in BigChem.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>Model</code> <p>The model for the quantum chemistry calculation.</p> <code>keywords</code> <code>Model</code> <p>A dict of keywords to be passed to the program excluding model and calctype. Defaults to an empty dict.</p> <code>files</code> <code>Model</code> <p>Files to be passed to the QC program.</p> <code>extras</code> <code>Model</code> <p>Additional information to bundle with the object. Use for schema development and scratch space.</p> Source code in <code>qcio/models/inputs.py</code> <pre><code>class ProgramArgs(FileInput, _KeywordsMixin):\n    \"\"\"Generic arguments for a program without a calctype or structure specification.\n\n    This class is needed for multi-step calculations where the calctype and structure\n    are specified only once for the entire calculation, e.g., multistep_opt in BigChem.\n\n    Attributes:\n        model: The model for the quantum chemistry calculation.\n        keywords: A dict of keywords to be passed to the program excluding model and\n            calctype. Defaults to an empty dict.\n        files: Files to be passed to the QC program.\n        extras: Additional information to bundle with the object. Use for schema\n            development and scratch space.\n    \"\"\"\n\n    model: Model\n</code></pre>"},{"location":"code-reference/ProgramInputs/#qcio.models.inputs.ProgramArgsSub","title":"<code>ProgramArgsSub</code>","text":"<p>             Bases: <code>FileInput</code>, <code>_KeywordsMixin</code></p> <p>Generic arguments for a program that also calls a subprogram.</p> <p>This class is needed for multi-step calculations where the calctype and structure are specified only once for the entire calculation, e.g., multistep_opt in BigChem.</p> <p>Attributes:</p> Name Type Description <code>keywords</code> <p>A dict of keywords to be passed to the program excluding model and calctype. Defaults to an empty dict.</p> <code>files</code> <p>Files to be passed to the QC program.</p> <code>subprogram</code> <code>str</code> <p>The name of the subprogram to use.</p> <code>subprogram_args</code> <code>ProgramArgs</code> <p>The ProgramArgs for the subprogram.</p> <code>extras</code> <code>ProgramArgs</code> <p>Additional information to bundle with the object. Use for schema development and scratch space.</p> Source code in <code>qcio/models/inputs.py</code> <pre><code>class ProgramArgsSub(FileInput, _KeywordsMixin):\n    \"\"\"Generic arguments for a program that also calls a subprogram.\n\n    This class is needed for multi-step calculations where the calctype and structure\n    are specified only once for the entire calculation, e.g., multistep_opt in BigChem.\n\n    Attributes:\n        keywords: A dict of keywords to be passed to the program excluding model and\n            calctype. Defaults to an empty dict.\n        files: Files to be passed to the QC program.\n        subprogram: The name of the subprogram to use.\n        subprogram_args: The ProgramArgs for the subprogram.\n        extras: Additional information to bundle with the object. Use for schema\n            development and scratch space.\n    \"\"\"\n\n    model: Optional[Model] = None\n    subprogram: str\n    subprogram_args: ProgramArgs\n</code></pre>"},{"location":"code-reference/ProgramInputs/#qcio.models.inputs.ProgramInput","title":"<code>ProgramInput</code>","text":"<p>             Bases: <code>ProgramArgs</code>, <code>_StructureKeywordsMixin</code></p> <p>Input for a single quantum chemistry program.</p> <p>Attributes:</p> Name Type Description <code>calctype</code> <code>CalcType</code> <p>The type of calculation to perform.</p> <code>model</code> <code>CalcType</code> <p>The model for the quantum chemistry calculation.</p> <code>keywords</code> <code>CalcType</code> <p>A dict of keywords to be passed to the program excluding model and calctype. Defaults to an empty dict.</p> <code>structure</code> <code>CalcType</code> <p>The structure to be used in the calculation.</p> <code>files</code> <code>CalcType</code> <p>Files to be passed to the QC program.</p> <code>extras</code> <code>CalcType</code> <p>Additional information to bundle with the object. Use for schema development and scratch space.</p> Source code in <code>qcio/models/inputs.py</code> <pre><code>class ProgramInput(ProgramArgs, _StructureKeywordsMixin):\n    \"\"\"Input for a single quantum chemistry program.\n\n    Attributes:\n        calctype: The type of calculation to perform.\n        model: The model for the quantum chemistry calculation.\n        keywords: A dict of keywords to be passed to the program excluding model and\n            calctype. Defaults to an empty dict.\n        structure: The structure to be used in the calculation.\n        files: Files to be passed to the QC program.\n        extras: Additional information to bundle with the object. Use for schema\n            development and scratch space.\n    \"\"\"\n\n    calctype: CalcType\n\n    @field_serializer(\"calctype\")\n    def serialize_calctype(self, calctype: CalcType, _info) -&gt; str:\n        \"\"\"Serialize CalcType to string\"\"\"\n        return calctype.value\n</code></pre>"},{"location":"code-reference/ProgramInputs/#qcio.models.inputs.ProgramInput.serialize_calctype","title":"<code>serialize_calctype(calctype, _info)</code>","text":"<p>Serialize CalcType to string</p> Source code in <code>qcio/models/inputs.py</code> <pre><code>@field_serializer(\"calctype\")\ndef serialize_calctype(self, calctype: CalcType, _info) -&gt; str:\n    \"\"\"Serialize CalcType to string\"\"\"\n    return calctype.value\n</code></pre>"},{"location":"code-reference/ProgramOutputs/","title":"ProgramOutputs","text":"<p>End user output and results objects from a calculation.</p>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.OptimizationResults","title":"<code>OptimizationResults</code>","text":"<p>             Bases: <code>Files</code></p> <p>Computed properties for an optimization.</p> <p>Attributes:</p> Name Type Description <code>energies</code> <code>ndarray</code> <p>The energies for each step of the optimization.</p> <code>structures</code> <code>List[Structure]</code> <p>The Structure objects for each step of the optimization.</p> <code>final_structure</code> <code>Structure</code> <p>The final, optimized Structure.</p> <code>trajectory</code> <code>List[Union[ProgramOutput[ProgramInput, SinglePointResults], ProgramOutput[ProgramInput, Files]]]</code> <p>The SinglePointOutput objects for each step of the optimization.</p> Source code in <code>qcio/models/outputs.py</code> <pre><code>class OptimizationResults(Files):\n    \"\"\"Computed properties for an optimization.\n\n    Attributes:\n        energies: The energies for each step of the optimization.\n        structures: The Structure objects for each step of the optimization.\n        final_structure: The final, optimized Structure.\n        trajectory: The SinglePointOutput objects for each step of the optimization.\n    \"\"\"\n\n    trajectory: List[\n        Union[\n            ProgramOutput[ProgramInput, SinglePointResults],\n            ProgramOutput[ProgramInput, Files],\n        ]\n    ] = []\n\n    @property\n    def final_structure(self) -&gt; Structure:\n        \"\"\"The final Structure in the optimization.\"\"\"\n        return self.structures[-1]\n\n    @property\n    def final_molecule(self) -&gt; Structure:\n        warnings.warn(\n            \".final_molecule is being depreciated and will be removed in a future. \"\n            \"Please use .final_structure instead.\",\n            category=FutureWarning,\n            stacklevel=2,\n        )\n        return self.final_structure\n\n    @property\n    def final_energy(self) -&gt; Optional[float]:  # Optional for np.nan\n        \"\"\"The final energy in the optimization.\"\"\"\n        return self.energies[-1]\n\n    @property\n    def energies(self) -&gt; np.ndarray:\n        \"\"\"The energies for each step of the optimization.\"\"\"\n        return np.array(\n            [\n                # ensure_structured_results_on_success validator ensures .results\n                # is not Files if success is True so # type: ignore\n                output.results.energy if output.success else np.nan  # type: ignore\n                for output in self.trajectory\n            ],\n            dtype=float,\n        )\n\n    @property\n    def structures(self) -&gt; List[Structure]:\n        \"\"\"The Structure objects for each step of the optimization.\"\"\"\n        return [output.input_data.structure for output in self.trajectory]\n\n    @property\n    def molecules(self) -&gt; List[Structure]:\n        \"\"\"The Structure objects for each step of the optimization.\"\"\"\n        warnings.warn(\n            \".molecules is being depreciated and will be removed in a future. \"\n            \"Please use .structures instead.\",\n            category=FutureWarning,\n            stacklevel=2,\n        )\n        return self.structures\n\n    def return_result(self, calctype: CalcType) -&gt; Optional[Structure]:\n        \"\"\"Return the primary result of the calculation.\"\"\"\n        return self.final_structure\n\n    def __repr_args__(self):\n        \"\"\"Custom repr to avoid printing the entire collection of objects.\"\"\"\n        return [\n            (\"final_structure\", f\"{self.final_structure}\"),\n            (\"trajectory\", \"[...]\"),\n            (\"energies\", \"[...]\"),\n            (\"structures\", \"[...]\"),\n        ]\n\n    def to_xyz(self) -&gt; str:\n        \"\"\"Return the trajectory as an XYZ file.\"\"\"\n        return \"\".join(\n            prog_output.input_data.structure.to_xyz() for prog_output in self.trajectory\n        )\n\n    def save(\n        self,\n        filepath: Union[Path, str],\n        exclude_none=True,\n        indent: int = 4,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Save an OptimizationOutput to a file.\n\n        Args:\n            filepath: The path to save the molecule to.\n            exclude_none: If True, attributes with a value of None will not be written\n                to the file.\n            **kwargs: Additional keyword arguments to pass to the json serializer.\n\n        Notes:\n            If the filepath has a .xyz extension, the trajectory will be saved to an XYZ\n            file.\n        \"\"\"\n        filepath = Path(filepath)\n        if filepath.suffix == \".xyz\":\n            filepath.write_text(self.to_xyz())\n            return\n        super().save(filepath, exclude_none, indent, **kwargs)\n</code></pre>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.OptimizationResults.energies","title":"<code>energies: np.ndarray</code>  <code>property</code>","text":"<p>The energies for each step of the optimization.</p>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.OptimizationResults.final_energy","title":"<code>final_energy: Optional[float]</code>  <code>property</code>","text":"<p>The final energy in the optimization.</p>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.OptimizationResults.final_structure","title":"<code>final_structure: Structure</code>  <code>property</code>","text":"<p>The final Structure in the optimization.</p>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.OptimizationResults.molecules","title":"<code>molecules: List[Structure]</code>  <code>property</code>","text":"<p>The Structure objects for each step of the optimization.</p>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.OptimizationResults.structures","title":"<code>structures: List[Structure]</code>  <code>property</code>","text":"<p>The Structure objects for each step of the optimization.</p>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.OptimizationResults.__repr_args__","title":"<code>__repr_args__()</code>","text":"<p>Custom repr to avoid printing the entire collection of objects.</p> Source code in <code>qcio/models/outputs.py</code> <pre><code>def __repr_args__(self):\n    \"\"\"Custom repr to avoid printing the entire collection of objects.\"\"\"\n    return [\n        (\"final_structure\", f\"{self.final_structure}\"),\n        (\"trajectory\", \"[...]\"),\n        (\"energies\", \"[...]\"),\n        (\"structures\", \"[...]\"),\n    ]\n</code></pre>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.OptimizationResults.return_result","title":"<code>return_result(calctype)</code>","text":"<p>Return the primary result of the calculation.</p> Source code in <code>qcio/models/outputs.py</code> <pre><code>def return_result(self, calctype: CalcType) -&gt; Optional[Structure]:\n    \"\"\"Return the primary result of the calculation.\"\"\"\n    return self.final_structure\n</code></pre>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.OptimizationResults.save","title":"<code>save(filepath, exclude_none=True, indent=4, **kwargs)</code>","text":"<p>Save an OptimizationOutput to a file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[Path, str]</code> <p>The path to save the molecule to.</p> required <code>exclude_none</code> <p>If True, attributes with a value of None will not be written to the file.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the json serializer.</p> <code>{}</code> Notes <p>If the filepath has a .xyz extension, the trajectory will be saved to an XYZ file.</p> Source code in <code>qcio/models/outputs.py</code> <pre><code>def save(\n    self,\n    filepath: Union[Path, str],\n    exclude_none=True,\n    indent: int = 4,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Save an OptimizationOutput to a file.\n\n    Args:\n        filepath: The path to save the molecule to.\n        exclude_none: If True, attributes with a value of None will not be written\n            to the file.\n        **kwargs: Additional keyword arguments to pass to the json serializer.\n\n    Notes:\n        If the filepath has a .xyz extension, the trajectory will be saved to an XYZ\n        file.\n    \"\"\"\n    filepath = Path(filepath)\n    if filepath.suffix == \".xyz\":\n        filepath.write_text(self.to_xyz())\n        return\n    super().save(filepath, exclude_none, indent, **kwargs)\n</code></pre>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.OptimizationResults.to_xyz","title":"<code>to_xyz()</code>","text":"<p>Return the trajectory as an XYZ file.</p> Source code in <code>qcio/models/outputs.py</code> <pre><code>def to_xyz(self) -&gt; str:\n    \"\"\"Return the trajectory as an XYZ file.\"\"\"\n    return \"\".join(\n        prog_output.input_data.structure.to_xyz() for prog_output in self.trajectory\n    )\n</code></pre>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.ProgramOutput","title":"<code>ProgramOutput</code>","text":"<p>             Bases: <code>QCIOModelBase</code>, <code>Generic[InputType, ResultsType]</code></p> Source code in <code>qcio/models/outputs.py</code> <pre><code>class ProgramOutput(QCIOModelBase, Generic[InputType, ResultsType]):\n    input_data: InputType\n    provenance: Provenance\n    success: Literal[True, False]\n    results: ResultsType\n    stdout: Optional[str] = None\n    traceback: Optional[str] = None\n\n    def __init__(self, **data: Any):\n        \"\"\"Backwards compatibility for files attribute.\"\"\"\n\n        if \"files\" in data:\n            warnings.warn(\n                \"The 'files' attribute has been moved to 'results.files'. Please \"\n                \"update your code accordingly.\",\n                category=FutureWarning,\n                stacklevel=2,\n            )\n\n            # This moves files from the top level to the results attribute\n            if isinstance(data[\"results\"], dict):\n                results_files_dict = data[\"results\"].get(\"files\", {})\n            else:  # data[\"results\"] is Files, SinglePointResults, OptimizationResults\n                results_files_dict = data[\"results\"].files\n\n            results_files_dict.update(**data.pop(\"files\"))\n\n        super().__init__(**data)\n\n    def model_post_init(self, __context) -&gt; None:\n        \"\"\"Parameterize the class (if not set explicitly).\"\"\"\n        # Check if the current class is still generic, do not override if explicitly set\n        if self.__class__ is ProgramOutput:\n            input_type = type(self.input_data)\n            results_type = type(self.results)\n            self.__class__ = ProgramOutput[input_type, results_type]  # type: ignore # noqa 501\n\n    @model_validator(mode=\"after\")\n    def ensure_traceback_on_failure(self) -&gt; Self:\n        if self.success is False:\n            assert (\n                self.traceback is not None\n            ), \"A traceback must be provided for failed calculations.\"\n        return self\n\n    @model_validator(mode=\"after\")\n    def ensure_structured_results_on_success(self) -&gt; Self:\n        \"\"\"Ensure structured results are provided for successful, non FileInputs.\"\"\"\n        # Covers case of ProgramInput and DualProgramInput\n        if self.success is True and isinstance(self.input_data, ProgramInput):\n            assert type(self.results) is not Files, (\n                \"Structured results must be provided for successful, non FileInput \"\n                \"calculations.\"\n            )\n\n        return self\n\n    @model_validator(mode=\"after\")\n    def ensure_primary_result_on_success(self) -&gt; Self:\n        if type(self.results) is SinglePointResults:\n            # Ensure the primary calctype result is present\n            calctype_val = self.input_data.calctype.value  # type: ignore\n            assert (\n                getattr(self.results, calctype_val) is not None\n            ), f\"Missing the primary result: {calctype_val}.\"\n\n        return self\n\n    @property\n    def pstdout(self) -&gt; None:\n        \"\"\"Print the stdout text\"\"\"\n        print(self.stdout)\n\n    @property\n    def ptraceback(self) -&gt; None:\n        \"\"\"Print the traceback text\"\"\"\n        print(self.traceback)\n\n    def __repr_args__(self) -&gt; List[Tuple[str, Any]]:\n        \"\"\"Exclude stdout and traceback from the repr and ensure success is first\"\"\"\n        args = super().__repr_args__()\n\n        # Replace stdout and traceback with \"&lt;...&gt;\"\n        filtered_args = [\n            (key, value if key not in {\"stdout\", \"traceback\"} else \"&lt;...&gt;\")\n            for key, value in args\n        ]\n        # Ensure success is first\n        success_arg = [(key, value) for key, value in filtered_args if key == \"success\"]\n        other_args = [(key, value) for key, value in filtered_args if key != \"success\"]\n        return success_arg + other_args\n\n    @property\n    def files(self) -&gt; Dict[str, Union[str, bytes]]:\n        \"\"\"Return the files attribute.\"\"\"\n        # Depreciation warning\n        warnings.warn(\n            \".files has been moved to .results.files. \"\n            \"Please access it there going forward.\",\n            category=FutureWarning,\n            stacklevel=2,\n        )\n        return self.results.files\n\n    @property\n    def return_result(self) -&gt; Union[float, SerializableNDArray, Optional[Structure]]:\n        \"\"\"Return the primary result of the calculation.\"\"\"\n        warnings.warn(\n            \".return_result is being depreciated and will be removed in a future. \"\n            \"Please access results directly at .results instead.\",\n            category=FutureWarning,\n            stacklevel=2,\n        )\n        # For mypy\n        assert self.results is not None, \"No results exist on this ProgramOutput\"\n        assert type(self.input_data) is not FileInput, \"FileInputs have no results.\"\n        return self.results.return_result(self.input_data.calctype)  # type: ignore\n</code></pre>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.ProgramOutput.files","title":"<code>files: Dict[str, Union[str, bytes]]</code>  <code>property</code>","text":"<p>Return the files attribute.</p>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.ProgramOutput.pstdout","title":"<code>pstdout: None</code>  <code>property</code>","text":"<p>Print the stdout text</p>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.ProgramOutput.ptraceback","title":"<code>ptraceback: None</code>  <code>property</code>","text":"<p>Print the traceback text</p>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.ProgramOutput.return_result","title":"<code>return_result: Union[float, SerializableNDArray, Optional[Structure]]</code>  <code>property</code>","text":"<p>Return the primary result of the calculation.</p>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.ProgramOutput.__init__","title":"<code>__init__(**data)</code>","text":"<p>Backwards compatibility for files attribute.</p> Source code in <code>qcio/models/outputs.py</code> <pre><code>def __init__(self, **data: Any):\n    \"\"\"Backwards compatibility for files attribute.\"\"\"\n\n    if \"files\" in data:\n        warnings.warn(\n            \"The 'files' attribute has been moved to 'results.files'. Please \"\n            \"update your code accordingly.\",\n            category=FutureWarning,\n            stacklevel=2,\n        )\n\n        # This moves files from the top level to the results attribute\n        if isinstance(data[\"results\"], dict):\n            results_files_dict = data[\"results\"].get(\"files\", {})\n        else:  # data[\"results\"] is Files, SinglePointResults, OptimizationResults\n            results_files_dict = data[\"results\"].files\n\n        results_files_dict.update(**data.pop(\"files\"))\n\n    super().__init__(**data)\n</code></pre>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.ProgramOutput.__repr_args__","title":"<code>__repr_args__()</code>","text":"<p>Exclude stdout and traceback from the repr and ensure success is first</p> Source code in <code>qcio/models/outputs.py</code> <pre><code>def __repr_args__(self) -&gt; List[Tuple[str, Any]]:\n    \"\"\"Exclude stdout and traceback from the repr and ensure success is first\"\"\"\n    args = super().__repr_args__()\n\n    # Replace stdout and traceback with \"&lt;...&gt;\"\n    filtered_args = [\n        (key, value if key not in {\"stdout\", \"traceback\"} else \"&lt;...&gt;\")\n        for key, value in args\n    ]\n    # Ensure success is first\n    success_arg = [(key, value) for key, value in filtered_args if key == \"success\"]\n    other_args = [(key, value) for key, value in filtered_args if key != \"success\"]\n    return success_arg + other_args\n</code></pre>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.ProgramOutput.ensure_structured_results_on_success","title":"<code>ensure_structured_results_on_success()</code>","text":"<p>Ensure structured results are provided for successful, non FileInputs.</p> Source code in <code>qcio/models/outputs.py</code> <pre><code>@model_validator(mode=\"after\")\ndef ensure_structured_results_on_success(self) -&gt; Self:\n    \"\"\"Ensure structured results are provided for successful, non FileInputs.\"\"\"\n    # Covers case of ProgramInput and DualProgramInput\n    if self.success is True and isinstance(self.input_data, ProgramInput):\n        assert type(self.results) is not Files, (\n            \"Structured results must be provided for successful, non FileInput \"\n            \"calculations.\"\n        )\n\n    return self\n</code></pre>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.ProgramOutput.model_post_init","title":"<code>model_post_init(__context)</code>","text":"<p>Parameterize the class (if not set explicitly).</p> Source code in <code>qcio/models/outputs.py</code> <pre><code>def model_post_init(self, __context) -&gt; None:\n    \"\"\"Parameterize the class (if not set explicitly).\"\"\"\n    # Check if the current class is still generic, do not override if explicitly set\n    if self.__class__ is ProgramOutput:\n        input_type = type(self.input_data)\n        results_type = type(self.results)\n        self.__class__ = ProgramOutput[input_type, results_type]  # type: ignore # noqa 501\n</code></pre>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.SinglePointResults","title":"<code>SinglePointResults</code>","text":"<p>             Bases: <code>Files</code></p> <p>The computed results from a single point calculation.</p> <p>Attributes:</p> Name Type Description <code>calcinfo_natoms</code> <code>Optional[int]</code> <p>The number of atoms as computed by the program.</p> <code>calcinfo_nalpha</code> <code>Optional[int]</code> <p>The number of alpha electrons as computed by the program.</p> <code>calcinfo_nbeta</code> <code>Optional[int]</code> <p>The number of beta electrons as computed by the program.</p> <code>calcinfo_nbasis</code> <code>Optional[int]</code> <p>The number of basis functions in the calculation.</p> <code>calcinfo_nmo</code> <code>Optional[int]</code> <p>The number of molecular orbitals in the calculation</p> <code>energy</code> <code>Optional[float]</code> <p>The electronic energy of the structure in Hartrees.</p> <code>gradient</code> <code>Optional[SerializableNDArray]</code> <p>The gradient of the structure in Hartrees/Bohr.</p> <code>hessian</code> <code>Optional[SerializableNDArray]</code> <p>The hessian of the structure in Hartrees/Bohr^2.</p> <code>nuclear_repulsion_energy</code> <code>Optional[float]</code> <p>The nuclear repulsion energy of the structure in Hartrees.</p> <code>wavefunction</code> <code>Optional[Wavefunction]</code> <p>Wavefunction data from the calculation.</p> <code>freqs_wavenumber</code> <code>List[float]</code> <p>The frequencies of the structure in wavenumbers.</p> <code>normal_modes_cartesian</code> <code>Optional[SerializableNDArray]</code> <p>3D n_vibmodes x n_atoms x 3 array containing un-mass-weighted Cartesian displacements of each normal mode.</p> <code>gibbs_free_energy</code> <code>Optional[float]</code> <p>Gibbs free energy (i.e. thermochemical analysis) in Hartrees of a system where translation / rotation / vibration degrees of freedom are approximated using ideal gas / rigid rotor / harmonic oscillator respectively.</p> <code>scf_dipole_moment</code> <code>Optional[List[float]]</code> <p>The x, y, z component of the dipole moment of the structure in units of e a0 (NOT Debye!).</p> Source code in <code>qcio/models/outputs.py</code> <pre><code>class SinglePointResults(Files):\n    \"\"\"The computed results from a single point calculation.\n\n    Attributes:\n        calcinfo_natoms: The number of atoms as computed by the program.\n        calcinfo_nalpha: The number of alpha electrons as computed by the program.\n        calcinfo_nbeta: The number of beta electrons as computed by the program.\n        calcinfo_nbasis: The number of basis functions in the calculation.\n        calcinfo_nmo: The number of molecular orbitals in the calculation\n\n        energy: The electronic energy of the structure in Hartrees.\n        gradient: The gradient of the structure in Hartrees/Bohr.\n        hessian: The hessian of the structure in Hartrees/Bohr^2.\n        nuclear_repulsion_energy: The nuclear repulsion energy of the structure in\n            Hartrees.\n\n        wavefunction: Wavefunction data from the calculation.\n\n        freqs_wavenumber: The frequencies of the structure in wavenumbers.\n        normal_modes_cartesian: 3D n_vibmodes x n_atoms x 3 array containing\n            un-mass-weighted Cartesian displacements of each normal mode.\n        gibbs_free_energy: Gibbs free energy (i.e. thermochemical analysis) in Hartrees\n            of a system where translation / rotation / vibration degrees of freedom are\n            approximated using ideal gas / rigid rotor / harmonic oscillator\n            respectively.\n        scf_dipole_moment: The x, y, z component of the dipole moment of the structure\n            in units of e a0 (NOT Debye!).\n\n    \"\"\"\n\n    # calcinfo contains general information about the calculation\n    calcinfo_natoms: Optional[int] = None\n    calcinfo_nbasis: Optional[int] = None\n    calcinfo_nmo: Optional[int] = None\n    calcinfo_nalpha: Optional[int] = None\n    calcinfo_nbeta: Optional[int] = None\n\n    # Core properties\n    energy: Optional[float] = None\n    gradient: Optional[SerializableNDArray] = None  # Coerced to 2D array\n    hessian: Optional[SerializableNDArray] = None  # Coerced to 2D array\n    nuclear_repulsion_energy: Optional[float] = None\n\n    # Wavefunction data\n    wavefunction: Optional[Wavefunction] = None\n\n    # Frequency data\n    freqs_wavenumber: List[float] = []\n    normal_modes_cartesian: Optional[SerializableNDArray] = None  # Coerced to 3D array\n    gibbs_free_energy: Optional[float] = None\n\n    # SCF results\n    scf_dipole_moment: Optional[List[float]] = None\n\n    @field_validator(\"normal_modes_cartesian\")\n    @classmethod\n    def validate_normal_modes_cartesian_shape(cls, v: SerializableNDArray):\n        if v is not None:\n            # Assume array has length of the number of normal modes\n            n_normal_modes = len(v)\n            return np.asarray(v).reshape(n_normal_modes, -1, 3)\n\n    @field_validator(\"gradient\")\n    @classmethod\n    def validate_gradient_shape(cls, v: SerializableNDArray):\n        \"\"\"Validate gradient is n x 3\"\"\"\n        if v is not None:\n            return np.asarray(v).reshape(-1, 3)\n\n    @field_validator(\"hessian\")\n    @classmethod\n    def validate_hessian_shape(cls, v: SerializableNDArray):\n        \"\"\"Validate hessian is square\"\"\"\n        if v is not None:\n            v = np.asarray(v)\n            n = int(np.sqrt(v.size))\n            return v.reshape((n, n))\n\n    def return_result(self, calctype: CalcType) -&gt; Union[float, SerializableNDArray]:\n        \"\"\"Return the primary result of the calculation.\"\"\"\n        return getattr(self, calctype.value)\n\n    @model_validator(mode=\"after\")\n    def ensure_results(self) -&gt; Self:\n        \"\"\"Ensure that at least one result is present.\"\"\"\n        if all(\n            result is None\n            for result in [\n                self.energy,\n                self.gradient,\n                self.hessian,\n            ]\n        ):\n            raise ValueError(\n                \"SinglePointResults requires either an energy, gradient, or hessian \"\n                \"value.\"\n            )\n        return self\n</code></pre>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.SinglePointResults.ensure_results","title":"<code>ensure_results()</code>","text":"<p>Ensure that at least one result is present.</p> Source code in <code>qcio/models/outputs.py</code> <pre><code>@model_validator(mode=\"after\")\ndef ensure_results(self) -&gt; Self:\n    \"\"\"Ensure that at least one result is present.\"\"\"\n    if all(\n        result is None\n        for result in [\n            self.energy,\n            self.gradient,\n            self.hessian,\n        ]\n    ):\n        raise ValueError(\n            \"SinglePointResults requires either an energy, gradient, or hessian \"\n            \"value.\"\n        )\n    return self\n</code></pre>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.SinglePointResults.return_result","title":"<code>return_result(calctype)</code>","text":"<p>Return the primary result of the calculation.</p> Source code in <code>qcio/models/outputs.py</code> <pre><code>def return_result(self, calctype: CalcType) -&gt; Union[float, SerializableNDArray]:\n    \"\"\"Return the primary result of the calculation.\"\"\"\n    return getattr(self, calctype.value)\n</code></pre>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.SinglePointResults.validate_gradient_shape","title":"<code>validate_gradient_shape(v)</code>  <code>classmethod</code>","text":"<p>Validate gradient is n x 3</p> Source code in <code>qcio/models/outputs.py</code> <pre><code>@field_validator(\"gradient\")\n@classmethod\ndef validate_gradient_shape(cls, v: SerializableNDArray):\n    \"\"\"Validate gradient is n x 3\"\"\"\n    if v is not None:\n        return np.asarray(v).reshape(-1, 3)\n</code></pre>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.SinglePointResults.validate_hessian_shape","title":"<code>validate_hessian_shape(v)</code>  <code>classmethod</code>","text":"<p>Validate hessian is square</p> Source code in <code>qcio/models/outputs.py</code> <pre><code>@field_validator(\"hessian\")\n@classmethod\ndef validate_hessian_shape(cls, v: SerializableNDArray):\n    \"\"\"Validate hessian is square\"\"\"\n    if v is not None:\n        v = np.asarray(v)\n        n = int(np.sqrt(v.size))\n        return v.reshape((n, n))\n</code></pre>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.Wavefunction","title":"<code>Wavefunction</code>","text":"<p>             Bases: <code>QCIOModelBase</code></p> <p>The wavefunction for a single point calculation.</p> <p>Attributes:</p> Name Type Description <code>scf_eigenvalues_a</code> <code>Optional[SerializableNDArray]</code> <p>The SCF alpha-spin orbital eigenvalues.</p> <code>scf_eigenvalues_b</code> <code>Optional[SerializableNDArray]</code> <p>The SCF beta-spin orbital eigenvalues.</p> <code>scf_occupations_a</code> <code>Optional[SerializableNDArray]</code> <p>The SCF alpha-spin orbital occupations.</p> <code>scf_occupations_b</code> <code>Optional[SerializableNDArray]</code> <p>The SCF beta-spin orbital occupations.</p> Source code in <code>qcio/models/outputs.py</code> <pre><code>class Wavefunction(QCIOModelBase):\n    \"\"\"The wavefunction for a single point calculation.\n\n    Attributes:\n        scf_eigenvalues_a: The SCF alpha-spin orbital eigenvalues.\n        scf_eigenvalues_b: The SCF beta-spin orbital eigenvalues.\n        scf_occupations_a: The SCF alpha-spin orbital occupations.\n        scf_occupations_b: The SCF beta-spin orbital occupations.\n    \"\"\"\n\n    scf_eigenvalues_a: Optional[SerializableNDArray] = None\n    scf_eigenvalues_b: Optional[SerializableNDArray] = None\n    scf_occupations_a: Optional[SerializableNDArray] = None\n    scf_occupations_b: Optional[SerializableNDArray] = None\n\n    @field_validator(\n        \"scf_eigenvalues_a\",\n        \"scf_eigenvalues_b\",\n        \"scf_occupations_a\",\n        \"scf_occupations_b\",\n    )\n    @classmethod\n    def to_numpy(cls, val, _info) -&gt; Optional[np.ndarray]:\n        return np.asarray(val) if val is not None else None\n</code></pre>"},{"location":"code-reference/exceptions/","title":"Exceptions","text":""},{"location":"code-reference/exceptions/#chemcloud.exceptions.BaseError","title":"<code>BaseError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Exception Base for client.</p> Source code in <code>chemcloud/exceptions.py</code> <pre><code>class BaseError(Exception):\n    \"\"\"Exception Base for client.\"\"\"\n</code></pre>"},{"location":"code-reference/exceptions/#chemcloud.exceptions.TimeoutError","title":"<code>TimeoutError</code>","text":"<p>             Bases: <code>BaseError</code></p> <p>A timeout parameter was exceeded</p> Source code in <code>chemcloud/exceptions.py</code> <pre><code>class TimeoutError(BaseError):\n    \"\"\"A timeout parameter was exceeded\"\"\"\n</code></pre>"},{"location":"tutorial/authentication/","title":"Authentication","text":"<p>Authentication is the process of supplying your credentials (usually a username and password) to <code>chemcloud</code> so that you can perform computations. <code>chemcloud</code> provides a few easy ways for you to authenticate. If you do not have a ChemCloud account you can get one for free here or at the address of the ChemCloud server you want to interact with: https://chemcloud.mtzlab.com/signup</p>"},{"location":"tutorial/authentication/#clientconfigure-recommended-for-most-cases","title":"<code>client.configure()</code> (recommended for most cases)","text":"<pre><code>from chemcloud import CCClient\nclient = CCClient()\nclient.configure()\n\u2705 If you dont get have an account please signup at: https://chemcloud.mtzlab.com/signup\nPlease enter your ChemCloud username: your_username@email.com\nPlease enter your ChemCloud password:\nAuthenticating...\n'default' profile configured! Username/password not required for future use of CCClient\n</code></pre> <p>Performing this action will configure your local client by writing authentication tokens to <code>~/.chemcloud/credentials</code>. You will not need to execute <code>configure()</code> ever again. Under the hood <code>CCClient</code> will access your tokens, refresh them when necessary, and keep you logged in to ChemCloud. Note that this will write a file to your home directory with sensitive access tokens, so if you are on a shared computer or using a device where you would not want to write this information to disk do not use this option. If you would like to write the <code>credentials</code> file to a different directory than <code>~/.chemcloud</code>, set the <code>CHEMCLOUD_BASE_DIRECTORY</code> environment variable to the path of interest.</p> <p>You can configure multiple profiles in case you have multiple logins to ChemCloud by passing a profile name to <code>configure()</code>:</p> <pre><code>client.configure('mtz_lab')\n\u2705 If you dont get have an account please signup at: https://chemcloud.mtzlab.com/signup\nPlease enter your ChemCloud username: your_username@email.om\nPlease enter your ChemCloud password:\nAuthenticating...\n'mtz_lab' profile configured! Username/password not required for future use of CCClient\n</code></pre> <p>To use one of these profiles pass the profile option to your client instance. The \"default\" profile is used when no profile name is passed:</p> <pre><code>from chemcloud import CCClient\n# Use default profile\nclient = CCClient()\n\n# Use named profile\nclient = CCClient(profile=\"mtz_lab\")\n</code></pre>"},{"location":"tutorial/authentication/#environment-variables","title":"Environment Variables","text":"<p>You can set your ChemCloud username and password in your environment and the <code>client</code> will find them automatically. Set <code>CHEMCLOUD_USERNAME</code> and <code>CHEMCLOUD_PASSWORD</code>. When you create a client it will find these values and maintain all access tokens in memory only.</p>"},{"location":"tutorial/authentication/#usernamepassword-when-prompted-after-calling-clientcompute","title":"Username/Password when prompted after calling <code>client.compute(...)</code>","text":"<p>If you have not run <code>client.configure()</code> or set environment variables you will be requested for your username and password when you submit a computation to ChemCloud using <code>client.compute(...)</code>. The client will use your username and password to get access tokens and will maintain access tokens for you in memory only. Your login session will be valid for the duration of your Python session.</p>"},{"location":"tutorial/authentication/#pass-usernamepassword-to-client-not-recommended","title":"Pass Username/Password to Client (not recommended)","text":"<p>You can directly pass a username and password to the <code>client</code> object. This is not recommended as it opens up the possibility of your credentials accidentally being committed to your code repo. However, it can be used in rare circumstances when necessary.</p> <pre><code>from chemcloud import CCClient\nclient = CCClient(\n    chemcloud_username=\"your_username@email.com\", chemcloud_password=\"super_secret_password\"  # pragma: allowlist secret\n    )\n</code></pre>"},{"location":"tutorial/batch-computations/","title":"Batch Computations","text":"<p>Calculations can be submitted in bulk by passing a list of <code>Input</code> objects to <code>client.compute()</code> rather than a single object.</p> <pre><code>from qcio import ProgramInput, Structure\n\nfrom chemcloud import CCClient\n\nwater = Structure(\n    symbols=[\"O\", \"H\", \"H\"],\n    geometry=[\n        [0.0000, 0.00000, 0.0000],\n        [0.2774, 0.89290, 0.2544],\n        [0.6067, -0.23830, -0.7169],\n    ],\n)\n\nclient = CCClient()\n\nprog_inp = ProgramInput(\n    structure=water,\n    model={\"method\": \"b3lyp\", \"basis\": \"6-31g\"},\n    calctype=\"energy\",\n    keywords={},\n)\nfuture_result = client.compute(\"psi4\", [prog_inp] * 2)\nprog_output = future_result.get()\n# Array of ProgramOutput objects containing all returned data\nprint(prog_output)\n</code></pre>"},{"location":"tutorial/bigchem-algorithms/","title":"BigChem Algorithms","text":"<p>BigChem implements some of its own concurrent algorithms that leverage its horizontally scalable backend infrastructure. These include a parallel hessian algorithm and parallel frequency analysis algorithm. To use them submit a <code>hessian</code> calculation to ChemCloud using <code>bigchem</code> as the engine. See examples the <code>parallel_hessian.py</code> and <code>parallel_frequency_analysis.py</code> scripts in the examples directory.</p>"},{"location":"tutorial/bigchem-algorithms/#hessian","title":"Hessian","text":"<pre><code>from qcio import DualProgramInput, ProgramOutput, Structure\n\nfrom chemcloud import CCClient\n\nwater = Structure(\n    symbols=[\"O\", \"H\", \"H\"],\n    geometry=[\n        [0.0000, 0.00000, 0.0000],\n        [0.2774, 0.89290, 0.2544],\n        [0.6067, -0.23830, -0.7169],\n    ],\n)\n\nclient = CCClient()\n\nprog_inp = DualProgramInput(\n    structure=water,\n    calctype=\"hessian\",\n    subprogram=\"psi4\",\n    subprogram_args={\"model\": {\"method\": \"b3lyp\", \"basis\": \"6-31g\"}},\n)\n\n\n# Submit calculation\nfuture_result = client.compute(\"bigchem\", prog_inp)\nprog_output: ProgramOutput = future_result.get()\n\n# ProgramOutput object containing all returned data\nprint(prog_output)\nprint(prog_output.results.hessian)\n# Frequency data always included too\nprint(f\"Wavenumbers: {prog_output.results.freqs_wavenumber}\")\nprint(prog_output.results.normal_modes_cartesian)\nprint(prog_output.results.gibbs_free_energy)\n</code></pre>"},{"location":"tutorial/bigchem-algorithms/#frequency-analysis","title":"Frequency Analysis","text":"<pre><code>from qcio import DualProgramInput, ProgramOutput, Structure\n\nfrom chemcloud import CCClient\n\nwater = Structure(\n    symbols=[\"O\", \"H\", \"H\"],\n    geometry=[\n        [0.0000, 0.00000, 0.0000],\n        [0.2774, 0.89290, 0.2544],\n        [0.6067, -0.23830, -0.7169],\n    ],\n)\n\nclient = CCClient()\n\nprog_inp = DualProgramInput(\n    structure=water,\n    calctype=\"hessian\",\n    subprogram=\"psi4\",\n    subprogram_args={\"model\": {\"method\": \"b3lyp\", \"basis\": \"6-31g\"}},\n)\n\n\n# Submit calculation\nfuture_result = client.compute(\"bigchem\", prog_inp)\nprog_output: ProgramOutput = future_result.get()\n\n# ProgramOutput object containing all returned data\nprint(prog_output)\nprint(f\"Wavenumbers: {prog_output.results.freqs_wavenumber}\")\nprint(prog_output.results.normal_modes_cartesian)\nprint(prog_output.results.gibbs_free_energy)\n</code></pre> <p>Keywords for the BigChem algorithms:</p> Keyword Type Description Default Value <code>dh</code> <code>float</code> Displacement for gradient geometries for finite difference <code>5.0e-3</code> <code>temperature</code> <code>float</code> Temperature passed to the harmonic free energy module <code>300.0</code> <code>pressure</code> <code>float</code> Pressure passed to the harmonic free energy module <code>1.0</code>"},{"location":"tutorial/compute/","title":"Compute","text":"<p>Computations are physically executed by a BigChem instance fronted by a ChemCloud server. The chemcloud python client submits jobs to and retrieves work from the ChemCloud server. Computations are submitted using the CCClient object.</p> <p>Computations require a QC proram and <code>ProgramInput</code> or <code>DualProgramInput</code> object. The <code>ProgramInput</code> object contains all the information necessary to run a single calculation. The <code>DualProgramInput</code> object is used when two QC programs are used in tandem, such as when performing a geometry optimization with one program that uses a subprogram for the energy and gradient calculations.</p>"},{"location":"tutorial/compute/#basic-single-point-calculation","title":"Basic Single Point Calculation","text":"<pre><code>from qcio import ProgramInput, ProgramOutput, Structure\n\nfrom chemcloud import CCClient\n\nwater = Structure(\n    symbols=[\"O\", \"H\", \"H\"],\n    geometry=[\n        [0.0000, 0.00000, 0.0000],\n        [0.2774, 0.89290, 0.2544],\n        [0.6067, -0.23830, -0.7169],\n    ],\n)\n\nclient = CCClient()\n\nprog_inp = ProgramInput(\n    structure=water,\n    model={\"method\": \"b3lyp\", \"basis\": \"6-31g\"},\n    calctype=\"energy\",  # Or \"gradient\" or \"hessian\"\n    keywords={},\n)\nfuture_result = client.compute(\"terachem\", prog_inp, collect_files=True)\nprog_output: ProgramOutput = future_result.get()\n# ProgramOutput object containing all returned data\nprint(prog_output.stdout)\nprint(prog_output)\n# The energy value requested\n\nif prog_output.success:\n    print(prog_output.results.energy)\n    print(prog_output.results.files.keys())\nelse:\n    print(prog_output.traceback)\n</code></pre>"},{"location":"tutorial/compute/#including-files-in-the-input","title":"Including Files in the Input","text":"<pre><code>from qcio import ProgramInput, ProgramOutput, Structure\n\nfrom chemcloud import CCClient\n\nwater = Structure(\n    symbols=[\"O\", \"H\", \"H\"],\n    geometry=[\n        [0.0000, 0.00000, 0.0000],\n        [0.2774, 0.89290, 0.2544],\n        [0.6067, -0.23830, -0.7169],\n    ],\n)\n\nclient = CCClient()\n\nprog_inp = ProgramInput(\n    structure=water,\n    model={\"method\": \"b3lyp\", \"basis\": \"6-31g\"},\n    calctype=\"energy\",\n    keywords={\"guess\": \"c0\"},\n    files={\n        \"c0\": b'\\xdf4R\\xdea\\xd7\\xef?\\xc1-\\xbdg2\\xd0\\xca?\\x8e\\xc4\\x94\\x02\\xe5\\xcd\\xae\\xbe\\xd9kP\\xd8R2\\xb7\\xbfhV\\xc1\\x136\\xe5\\xbe\\xbe\\xad\\x0b#2\\xabp\\xb6?\\xe9\\x91\\x99\\xbf\\xd7\\xe9e&gt;LQ\\x05\\xa4F\\xaa\\xa6&gt;&gt;k\\xab\\xa4\\xd4j\\xa1\\xbf\\xd1#\\xbf\\x14\\t\\xdf\\xd8&gt;\\x99Qq\\x1b\\x07\\x0b\\xb4?$*\\x0ed\\x95\\x91\\x97\\xbe\\r\\xc8\\xfb\\xca\\xbb\\x82\\xab?\\'d\\x0c-Y\\x8e\\x9c?\\x8c\\x10\\xf1\\xd9I\\xb5\\xdd\\xbf\\xf7\\xea%X\\xd0\\x02\\xbf&gt;==urA\\xc8\\xc9?\\xe0f\\xbb#^\\t\\xc8&gt;\\xe3\\xfb\\x8b\\xc2C\\x94\\xc3\\xbf\\xd0]m\\x85\\xd1\\xd7\\xb5&gt;\\xa2\\x1c\\x03Un0\\xd6\\xbe\\xc1\\x90\\xb8\\xec\\n\"\\xc9??\\xd3\\x90\\x80q\\xeb\\x06\\xbf,\\xa9\\x0f\\xc0\\x8dZ\\xdf\\xbf% \\xcc\\x86L\\x85\\xc2\\xbe\\xdf\\xae\\xb07\\xe4\\x91\\xfa\\xbf\\xa9\\x97q\\x07\\xff\\xd0\\x8a\\xbf\\x04\\xad\\xabq\\xc8\\xed\\xdc\\xbf\\xb3]B\\x0c\\xcc\\xa4\\xca&gt;\\x00\\xaaX\\xed\\xd7\\xe9\\xd7?\\xa5\\xbf\\xc0\\x05O\\xb2\\xe1&gt;&gt;c\\x1f\\xef\\x924\\xf1\\xbf\\xf9\\xac0\\xe1r-\\xcf\\xbe\\xe3]\\x92[g\\x18\\xe4&gt;Zm8\\x07@\\xbd\\xd2\\xbf\\xae\\x86\\xa3\\x19Hl\\x0b?e\\xb2\\x81\\xdd\\xdbz\\xc0?\\xc04\\xaea,1\\xe0&gt;t&amp;x\\xceH\\xf5\\x05@\\xc7\\'\\xb0\\xb9\\xd1g#?\\x82Hm\\x14\\xba\\x14\\xc3\\xbfT\\x19p\\xa8T\\x00\\xd1?\\xc5 \\xfc\\xae\\xabf\\xc2\\xbfm2\\xf0t\\xde\\x84\\xd0\\xbe#(\\x16bTh\\xb9?\\xd7i&amp;\\x01\\xc8\\xb7\\xb9?\\x02\\xdc\\xe5m\\xea\\n\\xef\\xbf\\xf6\\xfb\\x86\\n\\x97O\\xe7\\xbfX\\xe7\\xdfb\\x00\\xb8\\x1d?\\x19!\\x83a\\xb5\\xeb\\xe4?\\xa5\\x0b\\xf5&gt;wJ\\x9e?\\xcf\\xdb\\x884z\\xee\\xde\\xbf\\xea\\xbf\\xa7\\xd3@\\xd7h?F5\\x9b\\x1f\\x93\"@\\xbf/\\x8d\\x1e.\\x84o\\xc3?\\x08!\\xa9\\\\\\xc5d\\xbb\\xbf=\\x18s\\x1a\\xf6\\xa3\\xd2\\xben\\xf7\\x8e\\xb5B\\xbe\\xed?\\x96\\xd0:\\xeb\\xbdI\\xf4?\\xa1b\\x81\\x15QU\\xe6?7\\xf1\\xb6\\xac\\xd4i\\xe3?\\xc2\\xf35\\x18\\xc7\\x90\\x10\\xbf\\xc4 \\xf3\\xe5\\x93\\x94\\xc6\\xbfE\\x96\\xe1\\xa1\\xb2\\xe6\\xec?b\\xf4\\xd8K\\x1a|\\xe3\\xbf\\xabKE\\x9a+g#?I&gt;t\\xa1\\xc7\\x14\\xc3\\xbfM\\xd7\\x13\\xb7V\\x00\\xd1\\xbf\\xc4\\x1e\\xf1\\x02\\xa1f\\xc2\\xbf\\x16\\x8d\\x03l\\xd3\\x8e\\xa6\\xbe\\xdd$uFwh\\xb9?\\xcap6\\x18\\xfd\\xb7\\xb9\\xbf|\\xff&amp;\\xa8/\\x0b\\xef?\\x8c+\\x9eG0O\\xe7\\xbf\\xf6\\xfd$\\x1eY\\xdc\\x15?4L\\x99\\xf7\\xbd\\xeb\\xe4?\\xdd=\\xbaD\\xdbM\\x9e\\xbff\\x04*Q\\x81\\xee\\xde\\xbfZ\\x12\\x87\\x8eF\\xd7h?\\n6\\xbd1\\x84&amp;@\\xbf \\xbd#\\x84\\x88o\\xc3\\xbf\\xf2\\x9bj\\x08\\x9dd\\xbb\\xbf\\xcc\\x90aR\\xded\\xb8&gt;\\x18\\xcd\\t\\xf5H\\xbe\\xed?\\xdaw\\x8a\\xa3\\xb6I\\xf4\\xbf\\t\\xe3\\xf8\\xf0\\x92U\\xe6\\xbf\\x83\\xe8\\x9d\\x93\\xadi\\xe3?p\\x0bF\\xfe\\x9a\\x11\\x18\\xbf\\xd9A\\xc7g\\xc4\\x94\\xc6\\xbf\\x8e\\xdd\\xeb\\xa4\\xb0\\xe6\\xec\\xbfJ\\xb6@\\xbb\\x15|\\xe3\\xbf\\x08\\xe1\\xfa\\xa9\\xc0\\xb1Z?\\xf2\\x88\\x88!\\xff\\xaa\\xbc\\xbf[.\\xb8e\\xa8x\\xbc\\xbf\\x07\\x90nr\\xb8\\xc3\\xd9\\xbf4\\x99\\xf9\\x99\\x80Q\\xda\\xbf\\x05\\xd8$t\\x9e\\xfc\\xcb\\xbf\\xf5\\xfe|\\xa6gH\\xb7?\\xbf\\x0e\\xb8L@V\\xa6\\xbf\\xc8\\xa2\\x05\\x84\\xba\\x05\\xe2?\\xa2I\\xa0\\x1f\\x9f\\x80\\xe3\\xbfGv\\xefeG\\\\\\xdc?\\xeb\\x18\\xd63\\xc1\\x19\\xcb\\xbfW\"\\xb9\\x87P\\x92\\xc1\\xbf\\x05\\x13\\xa3IY\\xc3S?\\xa8\\xa2\\x18?\\x0e9\\xb5\\xbf \\xd9\\xcbJNq\\xd8?x\\xa8\\xa4/6\\x13\\xd3\\xbf\\xbdLJA\\xcc\\n\\xd0?\\xb6i\\xb5\\x01\\x1b\\xb8\\xc4\\xbf\\xa7eF\\xef.\\xfd\\xd3\\xbf\\rf\\x06.Z*\\xc3?\\x0b\\xaf\\xbb\\xe4\\xe1\\xb0\\xda?u\\x91\\xb0I\\x9d\\xc5\\xd7?^\\x9c\\xffh\\xa3\\xfe\\xd4?\\xdf\\x0ec\\xf3\\xc0D\\xe7?`\\xd6\\xfb\\xfd\\xf3\\x04\\xba\\xbf\\x8c\\xf1\\xcd\\x98\\x93\\xedK\\xbfv\"!\\xed\\x91\\xfd\\xad?ey\\xdd\\x08\\xc5\\xfc\\xd4?r\\xb7&gt;\\\\\\x83\\xf4\\xca?\\x84M\\xaf\\x8f\\xbb\\x9b\\xdb\\xbfk\\xa36\\xd6UG\\xbd?\\xd9\\xfd\\x0f\\x18\\xdb)\\xd1\\xbf\\xfb`\\x8e\\xf0\\xf0t\\xc0?9\\x1f\\x0b\\xb9h\\xdc\\xd2\\xbf\\xadk\\t_\\xa5t\\xe4\\xbf\\xc1dH\\r`\\xaa\\xcd\\xbf\\xb8\\xbe\\xa9n\\xea\\xfa\\xe3?\\xaa\\x927\\x94 b\\xb2?\\'\\x84E8\\x0e\\x84`\\xbf\\xcf\\xc9\\xaa$\\xae\\xaf\\xaa\\xbf\\xefb}_82\\xaa\\xbf\\xd4\\xfeS\\xc3N\\xc0\\xd1\\xbf\\xdf\\xd5k\\x1b\\x08\\x8b\\xd4\\xbf\\xcf\\x02\\xa6\\xe9\\xaa=\\xd5\\xbfLI\\xad\\x02m\\xb6\\xc4?\\xe9=\\x13\\xecr\\xe2\\xba\\xbf\\xd4\\xf5\\x91\\xd75\\xfb\\xd5\\xbfa\\xaa\\xb0\\x86S*\\xe5?#\\x92\\xd8\\x85\\x1f\\x8d\\xea\\xbf\\x04\\x8e\\xfa\\xde\\xe4\\xf1\\xd6?\\xdd\\xf3\\xc8[.\\xc9\\xe4?\\xae\\xef\\x9f\\x01{tX\\xbf\\xfdG\\xb1\\xd6\\xa1\\xc1\\xa3\\xbfe\\xa4\\xa5\\xacy}\\xc6?/\\xe3&gt;s\\xcfH\\xca\\xbf\\xb4\\xe7\\xd4\\xf9\\x0e\\x0b\\xc9?\\xe0\\xf7\\xf8B]s\\xcf\\xbf/$\\x91\\x9dh\\xc8\\xe1\\xbfk\\xa6\\x86\\xed\\xfd\\x15\\xd7?\\x9fo\\xed~OG\\xd0\\xbft9\\xe6\\xcd\\xa9\\xcd\\xd9\\xbfa\\xa6&gt;\"\\xeb\\xa7\\xe3\\xbfj?\\xea\\xd6\\x11\\xb3\\xf3\\xbf\\xf2=JS\\xf6\\xc6\\xde?9BT]PGQ?\\xe9\\x80\\xd0\\x08\\xfe\\xea\\x9b?\\xf5G\\xb1\\x83\\xa0O\\xc3?\\xef\\x96y[9\\x92\\xc2?\\xc7\\xb6\\xd7\\x87\\xce\\x8c\\xd5\\xbf\\xd1Q\\x02l\\x958\\xc6?C\\xd8\\x13\\x1c\\xdb\\x89\\xde\\xbf2\\x02y\\'\\xa4\\xd2\\xd3?^\\xef\\x1f\\xd70\\x03\\xc7?\\xacm2\\x05s3\\xe6?\\xc0\\xde\\x00pP\\xc6\\xdb?\\x0fx\\x8c\\xdfP\\xea\\xf0\\xbf\\xa7\\xd4\\x80E\\xc9\\xbe\\xd5\\xbf'  # noqa: E501\n    },\n)\nfuture_result = client.compute(\"terachem\", prog_inp, collect_files=True)\nprog_output: ProgramOutput = future_result.get()\n# ProgramOutput object containing all returned data\nprint(prog_output.stdout)\nprint(prog_output)\n# The energy value requested\nprint(prog_output.results.energy)\nprint(prog_output.results.files.keys())\n</code></pre> <p>Files can also be added to an input objects using the <code>open_file</code> method.</p> <pre><code>prog_input.open_file(\"some_file.dat\")\n</code></pre>"},{"location":"tutorial/geometry-optimization/","title":"Geometry optimization","text":""},{"location":"tutorial/geometry-optimization/#basic-working-example","title":"Basic Working Example","text":"<pre><code>from qcio import DualProgramInput, OptimizationOutput, Structure\n\nfrom chemcloud import CCClient\n\nwater = Structure(\n    symbols=[\"O\", \"H\", \"H\"],\n    geometry=[\n        [-0.11904094, -0.36695321, -0.21996706],\n        [1.24615604, -0.14134141, 0.99915579],\n        [-0.24300973, 1.16287522, -1.24168873],\n    ],\n)\n\nclient = CCClient()\n\nprog_inp = DualProgramInput(\n    structure=water,\n    calctype=\"optimization\",\n    keywords={\"maxiter\": 25},\n    subprogram=\"psi4\",\n    subprogram_args={\"model\": {\"method\": \"b3lyp\", \"basis\": \"6-31g\"}},\n)\n\n\n# Submit calculation\nfuture_result = client.compute(\"geometric\", prog_inp)\noutput: OptimizationOutput = future_result.get()\n\nif output.success:\n    print(\"Optimization succeeded!\")\n    # Will be OptimizationResult object\n    print(output)\n    # The final structure of the geometry optimization\n    print(output.results.final_structure)\n    # Initial structure\n    print(output.input_data.structure)\n    # A list of ordered AtomicResult objects for each step in the optimization\n    print(output.results.trajectory)\n    # A list of ordered energies for each step in the optimization\n    print(output.results.energies)\nelse:\n    print(\"Optimization failed!\")\n    # Will be FailedOperation object\n    print(output)\n    # Error information\n    print(output.traceback)\n</code></pre>"},{"location":"tutorial/geometry-optimization/#using-force-fields","title":"Using Force Fields","text":"<p><code>rdkit</code> can be specified as a compute backend to perform optimizations using force field methods instead of quantum chemistry backends. To use <code>rdkit</code> force field methods simply modify the model specification and <code>subprogram</code> specification as shown below. Also note that <code>rdkit</code> requires the molecular connectivity to be defined.</p> <pre><code>water = Structure(\n    symbols=[\"O\", \"H\", \"H\"],\n    geometry=[\n        [0.0000, 0.00000, 0.0000],\n        [0.2774, 0.89290, 0.2544],\n        [0.6067, -0.23830, -0.7169],\n    ],\n    # Add bond connectivity to water (from_atom, to_atom, bond_order)\n    connectivity=[(0, 1, 1.0), (0, 2, 1.0)],\n)\n\nopt_input = DualProgramInput(\n    ...\n    subprogram=\"rdkit\",\n    subprogram_args={\"model\": {\"method\": \"UFF\"}} # or any other force field\n)\n\nfuture_output = client.compute(\"geometric\", opt_input)\n</code></pre>"},{"location":"tutorial/geometry-optimization/#berny-specifics","title":"Berny Specifics","text":"<p>The <code>berny</code> procedure uses the pyberny package to perform a geometry optimization. <code>berny</code> specific keywords are subject to change as the <code>berny</code> package evolves, but for simplicity a short list is included here with default values noted:</p> Keyword Description Default Value <code>maxsteps</code> Maximum number of steps in the optimization <code>100</code> <code>gradientmax</code> Convergence criteria (AU) <code>0.45e-3</code> <code>gradientrms</code> Convergence criteria (AU) <code>0.15e-3</code> <code>stepmax</code> Step in internal coordinates, assuming radian units for angles (AU) <code>1.8e-3</code> <code>steprms</code> Step in internal coordinates, assuming radian units for angles (AU) <code>0.45e-3</code> <code>trust</code> Initial trust radius in AU. It is the maximum RMS of the quadratic step <code>0.3</code> <code>dihedral</code> Form dihedral angles <code>True</code> <code>superweakdih</code> Form dihedral angles containing two or more noncovalent bonds <code>False</code>"},{"location":"tutorial/geometry-optimization/#geometric-specifics","title":"geomeTRIC Specifics","text":"<p>The <code>geometric</code> procedure uses the geomeTRIC package to perform a geometry optimization. <code>geomeTRIC</code> specific keywords are subject to change as the <code>geomeTRIC</code> package evolves. Since <code>geomeTRIC</code> has considerably more keywords, here's the source code that defines various parameters for an optimization. Keywords noted below can be included in the <code>OptimizationInput</code> keywords dictionary. If these options are overwhelming, keep in mind you can run both the <code>berny</code> and <code>geometric</code> optimizers without any keywords and the optimizers will use sensible defaults.</p> <pre><code>class OptParams(object):\n    \"\"\"\n    Container for optimization parameters.\n    The parameters used to be contained in the command-line \"args\",\n    but this was dropped in order to call Optimize() from another script.\n    \"\"\"\n    def __init__(self, **kwargs):\n        # Whether we are optimizing for a transition state. This changes a number of default parameters.\n        self.transition = kwargs.get('transition', False)\n        # CI optimizations sometimes require tiny steps\n        self.meci = kwargs.get('meci', False)\n        # Handle convergence criteria; this edits the kwargs\n        self.convergence_criteria(**kwargs)\n        # Threshold (in a.u. / rad) for activating alternative algorithm that enforces precise constraint satisfaction\n        self.enforce = kwargs.get('enforce', 0.0)\n        # Small eigenvalue threshold\n        self.epsilon = kwargs.get('epsilon', 1e-5)\n        # Interval for checking the coordinate system for changes\n        self.check = kwargs.get('check', 0)\n        # More verbose printout\n        self.verbose = kwargs.get('verbose', False)\n        # Starting value of the trust radius\n        # Because TS optimization is experimental, use conservative trust radii\n        self.trust = kwargs.get('trust', 0.01 if self.transition else 0.1)\n        # Maximum value of trust radius\n        self.tmax = kwargs.get('tmax', 0.03 if self.transition else 0.3)\n        # Minimum value of the trust radius\n        self.tmin = kwargs.get('tmin', 0.0 if (self.transition or self.meci) else min(1.2e-3, self.Convergence_drms))\n        # Minimum size of a step that can be rejected\n        self.thre_rj = kwargs.get('thre_rj', 1e-4 if (self.transition or self.meci) else 1e-2)\n        # Sanity checks on trust radius\n        if self.tmax &lt; self.tmin:\n            raise ParamError(\"Max trust radius must be larger than min\")\n        # The trust radius should not be outside (tmin, tmax)\n        self.trust = min(self.tmax, self.trust)\n        self.trust = max(self.tmin, self.trust)\n        # Maximum number of optimization cycles\n        self.maxiter = kwargs.get('maxiter', 300)\n        # Use updated constraint algorithm implemented 2019-03-20\n        self.conmethod = kwargs.get('conmethod', 0)\n        # Write Hessian matrix at optimized structure to text file\n        self.write_cart_hess = kwargs.get('write_cart_hess', None)\n        # Output .xyz file name may be set separately in\n        # run_optimizer() prior to calling Optimize().\n        self.xyzout = kwargs.get('xyzout', None)\n        # Name of the qdata.txt file to be written.\n        # The CLI is designed so the user passes true/false instead of the file name.\n        self.qdata = 'qdata.txt' if kwargs.get('qdata', False) else None\n        # Whether to calculate or read a Hessian matrix.\n        self.hessian = kwargs.get('hessian', None)\n        if self.hessian is None:\n            # Default is to calculate Hessian in the first step if searching for a transition state.\n            # Otherwise the default is to never calculate the Hessian.\n            if self.transition: self.hessian = 'first'\n            else: self.hessian = 'never'\n        if self.hessian.startswith('file:'):\n            if os.path.exists(self.hessian[5:]):\n                # If a path is provided for reading a Hessian file, read it now.\n                self.hess_data = np.loadtxt(self.hessian[5:])\n            else:\n                raise IOError(\"No Hessian data file found at %s\" % self.hessian)\n        elif self.hessian.lower() in ['never', 'first', 'each', 'stop', 'last', 'first+last']:\n            self.hessian = self.hessian.lower()\n        else:\n            raise RuntimeError(\"Hessian command line argument can only be never, first, last, first+last, each, stop, or file:&lt;path&gt;\")\n        # Perform a frequency analysis whenever a cartesian Hessian is computed\n        self.frequency = kwargs.get('frequency', None)\n        if self.frequency is None: self.frequency = True\n        # Temperature and pressure for harmonic free energy\n        self.temperature, self.pressure = kwargs.get('thermo', [300.0, 1.0])\n        # Number of desired samples from Wigner distribution\n        self.wigner = kwargs.get('wigner', 0)\n        if self.wigner and not self.frequency:\n            raise ParamError('Wigner sampling requires frequency analysis')\n        # Reset Hessian to guess whenever eigenvalues drop below epsilon\n        self.reset = kwargs.get('reset', None)\n        if self.reset is None: self.reset = not (self.transition or self.meci or self.hessian == 'each')\n</code></pre> <p>And convergence criteria:</p> <pre><code>def convergence_criteria(self, **kwargs):\n        criteria = kwargs.get('converge', [])\n        if len(criteria)%2 != 0:\n            raise RuntimeError('Please pass an even number of options to --converge')\n        for i in range(int(len(criteria)/2)):\n            key = 'convergence_' + criteria[2*i].lower()\n            try:\n                val = float(criteria[2*i+1])\n                logger.info('Using convergence criteria: %s %.2e\\n' % (key, val))\n            except ValueError:\n                # This must be a set\n                val = str(criteria[2*i+1])\n                logger.info('Using convergence criteria set: %s %s\\n' % (key, val))\n            kwargs[key] = val\n        # convergence dictionary to store criteria stored in order of energy, grms, gmax, drms, dmax\n        # 'GAU' contains the default convergence criteria that are used when nothing is passed.\n        convergence_sets = {'GAU': [1e-6, 3e-4, 4.5e-4, 1.2e-3, 1.8e-3],\n                            'NWCHEM_LOOSE': [1e-6, 3e-3, 4.5e-3, 3.6e-3, 5.4e-3],\n                            'GAU_LOOSE': [1e-6, 1.7e-3, 2.5e-3, 6.7e-3, 1e-2],\n                            'TURBOMOLE': [1e-6, 5e-4, 1e-3, 5.0e-4, 1e-3],\n                            'INTERFRAG_TIGHT': [1e-6, 1e-5, 1.5e-5, 4.0e-4, 6.0e-4],\n                            'GAU_TIGHT': [1e-6, 1e-5, 1.5e-5, 4e-5, 6e-5],\n                            'GAU_VERYTIGHT': [1e-6, 1e-6, 2e-6, 4e-6, 6e-6]}\n        # Q-Chem style convergence criteria (i.e. gradient and either energy or displacement)\n        self.qccnv = kwargs.get('qccnv', False)\n        # Molpro style convergence criteria (i.e. gradient and either energy or displacement, with different defaults)\n        self.molcnv = kwargs.get('molcnv', False)\n        # Check if there is a convergence set passed else use the default\n        set_name = kwargs.get('convergence_set', 'GAU').upper()\n        # If we have extra keywords apply them here else use the set\n        # Convergence criteria in a.u. and Angstrom\n        self.Convergence_energy = kwargs.get('convergence_energy', convergence_sets[set_name][0])\n        self.Convergence_grms = kwargs.get('convergence_grms', convergence_sets[set_name][1])\n        self.Convergence_gmax = kwargs.get('convergence_gmax', convergence_sets[set_name][2])\n        self.Convergence_drms = kwargs.get('convergence_drms', convergence_sets[set_name][3])\n        self.Convergence_dmax = kwargs.get('convergence_dmax', convergence_sets[set_name][4])\n        # Convergence criteria that are only used if molconv is set to True\n        self.Convergence_molpro_gmax = kwargs.get('convergence_molpro_gmax', 3e-4)\n        self.Convergence_molpro_dmax = kwargs.get('convergence_molpro_dmax', 1.2e-3)\n</code></pre>"},{"location":"tutorial/supported-programs/","title":"Supported programs","text":"<p>Supported compute engines in chemcloud can be checked as follows:</p> <pre><code>from chemcloud import CCClient\n\nclient = CCClient()\nclient.supported_engines\n[\"psi4\", \"terachem_fe\", \"rdkit\", ...]\n</code></pre> <p>Please see BigChem Algorithms for details on parallel execution algorithms unique to the BigChem compute engine.</p>"}]}