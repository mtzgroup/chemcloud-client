{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"chemcloud","text":""},{"location":"#chemcloud-a-python-client-for-chemcloud","title":"chemcloud - A Python Client for ChemCloud","text":"<p><code>chemcloud</code> is a python client for the ChemCloud Server. The client provides a simple yet powerful interface to perform computational chemistry calculations at scale using nothing but modern Python and an internet connection.</p> <p>Documentation: https://mtzgroup.github.io/chemcloud-client</p> <p><code>chemcloud</code> works in harmony with a suite of other quantum chemistry tools for fast, structured, and interoperable quantum chemistry.</p>"},{"location":"#the-qc-suite-of-programs","title":"The QC Suite of Programs","text":"<ul> <li>qcio - Elegant and intuitive data structures for quantum chemistry, featuring seamless Jupyter Notebook visualizations. Documentation</li> <li>qcparse - A library for efficient parsing of quantum chemistry data into structured <code>qcio</code> objects.</li> <li>qcop - A package for operating quantum chemistry programs using <code>qcio</code> standardized data structures. Compatible with <code>TeraChem</code>, <code>psi4</code>, <code>QChem</code>, <code>NWChem</code>, <code>ORCA</code>, <code>Molpro</code>, <code>geomeTRIC</code>, and many more, featuring seamless Jupyter Notebook visualizations.</li> <li>BigChem - A distributed application for running quantum chemistry calculations at scale across clusters of computers or the cloud. Bring multi-node scaling to your favorite quantum chemistry program, featuring seamless Jupyter Notebook visualizations.</li> <li><code>ChemCloud</code> - A web application and associated Python client for exposing a BigChem cluster securely over the internet, featuring seamless Jupyter Notebook visualizations.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install chemcloud\n</code></pre>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Run calculations just like you would with <code>qcop</code> except calling <code>chemcloud.compute</code> instead of <code>qcop.compute</code>. You may also pass list of inputs to <code>chemcloud.compute</code> to run calculations in parallel. By default <code>chemcloud.compute</code> will return <code>ProgramOutput</code> objects for all calculations, even those that failed, rather than raising exceptions. Check if calculations were successful by accessing <code>output.success</code>.</p> <pre><code>from qcio import Structure, ProgramInput\nfrom chemcloud import compute\n\n# Create the structure\nh2o = Structure.open(\"h2o.xyz\")\n\n# Define the program input\nprog_input = ProgramInput(\n    structure=h2o,\n    calctype=\"energy\",\n    model={\"method\": \"hf\", \"basis\": \"sto-3g\"},\n    keywords={\"purify\": \"no\", \"restricted\": False},\n)\n\n# Submit the calculation to the server\noutput = compute(\"terachem\", prog_input)\n\n# Inspect the output\noutput.input_data # Input data used by the QC program\noutput.success # Whether the calculation succeeded\noutput.results # All structured results from the calculation\noutput.stdout # Stdout log from the calculation\noutput.pstdout # Shortcut to print out the stdout in human readable format\noutput.files # Any files returned by the calculation\noutput.provenance # Provenance information about the calculation\noutput.extras # Any extra information not in the schema\noutput.traceback # Stack trace if calculation failed\noutput.ptraceback # Shortcut to print out the traceback in human readable format\n</code></pre> <p>Submit thousands of calculations simultaneously and collect results parallel:</p> <pre><code>prog_inputs = [prog_input] * 10\noutputs = compute(\"terachem\", prog_inputs)\n\nfor output in outputs:\n    # Process outputs\n    output.save(...)\n</code></pre> <p>Or stream results from the server as they complete:</p> <pre><code>prog_inputs = [prog_input] * 10\n# Submit the calculation to the server\nfuture = compute(\"terachem\", prog_inputs, return_future=True)\nfor output in future.as_completed():\n    # Outputs returned as they complete\n    output.save(...)\n</code></pre> <p>If you want to use a non-blocking API, pass <code>return_future=True</code> to <code>compute</code>. Calling <code>.get()</code> on the future will return a <code>ProgramOutput</code> or list of <code>ProgramOutput</code> once the calculations are complete.</p> <pre><code>prog_inputs = [prog_input] * 10\n# Submit the calculation to the server\nfuture = compute(\"terachem\", prog_inputs, return_future=True)\n# Check the status of calculations\nfuture.is_ready\n# Block and retrieve results\noutputs = future.get()\nfor output in outputs:\n    # Process outputs\n    output.save(...)\n</code></pre> <p>Save a <code>future</code> to disk and then collect results later:</p> <pre><code># Submit the calculation to the server\nfuture = compute(\"terachem\", prog_inputs, return_future=True)\nfuture.save(\"myfuture.json\")\n\n# Later in a different script\nfuture.open(\"myfuture.json\")\noutputs = future.get()\n</code></pre>"},{"location":"#examples","title":"Examples","text":"<p>More examples can be found in the examples directory.</p>"},{"location":"#visualization","title":"\u2728 Visualization \u2728","text":"<p>Visualize all your results with a single line of code!</p> <p>First install the visualization module:</p> <pre><code>pip install qcio[view]\n</code></pre> <p>or if your shell requires <code>''</code> around arguments with brackets:</p> <pre><code>pip install 'qcio[view]'\n</code></pre> <p>Then in a Jupyter notebook import the <code>qcio</code> view module and call <code>view.view(...)</code> passing it one or any number of <code>qcio</code> objects you want to visualizing including <code>Structure</code> objects or any <code>ProgramOutput</code> object. You may also pass an array of <code>titles</code> and/or <code>subtitles</code> to add additional information to the molecular structure display. If no titles are passed <code>qcio</code> with look for <code>Structure</code> identifiers such as a name or SMILES to label the <code>Structure</code>.</p> <p></p> <p>Seamless visualizations for <code>ProgramOutput</code> objects make results analysis easy!</p> <p></p> <p>Single point calculations display their results in a table.</p> <p></p> <p>If you want to use the HTML generated by the viewer to build your own dashboards use the functions inside of <code>qcio.view.py</code> that begin with the word <code>generate_</code> to create HTML you can insert into any dashboard.</p>"},{"location":"#support","title":"Support","text":"<p>If you have any issues with <code>chemcloud</code> or would like to request a feature, please open an issue.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#unreleased","title":"unreleased","text":""},{"location":"CHANGELOG/#0150-2025-02-25","title":"0.15.0 - 2025-02-25","text":""},{"location":"CHANGELOG/#added","title":"Added","text":"<ul> <li>Temporary <code>._token_refresh_lock</code> <code>asyncio.Lock</code> bound to the new event loop for synchronous request invocations.</li> <li><code>DELETE</code> request to the ChemCloud server after successfully receiving <code>ProgramOutput</code>.</li> <li>Adaptive polling interval to <code>FutureOutput.get_async()</code> so that the interval is reset if results are collected.</li> </ul>"},{"location":"CHANGELOG/#removed","title":"Removed","text":"<ul> <li><code>_HTTPClient._httpx_timeout</code>.</li> </ul>"},{"location":"CHANGELOG/#0140-2025-02-20","title":"0.14.0 - 2025-02-20","text":""},{"location":"CHANGELOG/#added_1","title":"Added","text":"<ul> <li>Full async API for <code>chemcloud</code>. This enables Jupyter support. All <code>chemcloud</code> methods have an <code>_async</code> version that can be awaited as follows:</li> </ul> <pre><code>from chemcloud import compute_async\n\n...\noutput = await compute_async(\"terachem\", prog_inputs)\n</code></pre>"},{"location":"CHANGELOG/#0133-2025-02-19","title":"0.13.3 - 2025-02-19","text":""},{"location":"CHANGELOG/#added_2","title":"Added","text":"<ul> <li><code>FutureOutput.save()</code> and <code>FutureOutput.open()</code> methods to serialize futures to disks and then open the later for retrieval.</li> </ul>"},{"location":"CHANGELOG/#changed","title":"Changed","text":"<ul> <li><code>FutureOutput.single_input</code> to <code>.return_single_output</code>.</li> </ul>"},{"location":"CHANGELOG/#0132-2025-02-18","title":"0.13.2 - 2025-02-18","text":""},{"location":"CHANGELOG/#added_3","title":"Added","text":"<ul> <li><code>FutureOutput.single_input</code> so that list of len 1 submitted to <code>compute()</code> still get returned as list. May want to refactor into <code>FutureOutput</code> and <code>FutureOutputs</code>, but this solution works for a quick fix for today's presentation.</li> </ul>"},{"location":"CHANGELOG/#0131-2025-02-17","title":"0.13.1 - 2025-02-17","text":""},{"location":"CHANGELOG/#added_4","title":"Added","text":"<ul> <li>Usage examples for main <code>chemcloud</code> functions.</li> <li>Tests for main <code>chemcloud</code> functions.</li> <li><code>queue</code> can be passed to <code>configure_client()</code> or <code>CCClient()</code> to specify that all calculations should be submitted to a particular queue.</li> </ul>"},{"location":"CHANGELOG/#changed_1","title":"Changed","text":"<ul> <li><code>ProgramOutput</code> objects are removed from the <code>FutureOutput.output</code> list as they are returned by <code>.as_completed()</code> to reduce memory footprint for collecting large batches of results.</li> </ul>"},{"location":"CHANGELOG/#0130-2025-02-16","title":"0.13.0 - 2025-02-16","text":""},{"location":"CHANGELOG/#added_5","title":"Added","text":"<ul> <li>High level <code>compute()</code> interface for doing calculations without needing to first instantiate a client.</li> <li>More complete <code>TaskStatus</code> enum.</li> <li>Parallel task submission and retrieval with ChemCloud server via asynchronous coroutines.</li> <li><code>asyncio.Lock()</code> to auth requests so that token refreshes are not duplicated by multiple coroutines.</li> <li><code>.save()</code> and <code>.open()</code> methods to FutureOutput to serialize to/from disk.</li> </ul>"},{"location":"CHANGELOG/#changed_2","title":"Changed","text":"<ul> <li>Refactored <code>CCClient</code>, <code>_RequestsClient</code> and <code>FutureOutput</code> to have cleaner interface and more clearly defined roles.</li> <li><code>CCClient.configure()</code> renamed to <code>.setup_profile()</code> to improve clarity and reserve the term <code>configure</code> for the new <code>configure_client</code> function.</li> <li><code>compute()</code> and <code>client.compute()</code> are now synchronous by default. If end users want to run calculations asynchronously and have a future object returned pass <code>return_future=True</code>.</li> <li><code>_RequestsClient</code> is entirely <code>async</code> now with a <code>.run_parallel_requests()</code> method that can be used for synchronous tasks.</li> <li>Lists of <code>ProgramInput</code> objects submitted to <code>CCClient.compute()</code> are now submitted individually (and concurrently) rather than as a batched, single request. This will prevent the server from having to retrieve large batch calculations which occasionally fills server memory and crashes it.</li> <li><code>_HTTPClient</code> and updated requests methods to reuse these clients across requests rather than creating a new connection for each request. This enables connection pooling and reuse of <code>TCP/SSL</code> connections, greatly speeding up requests and lowering server load.</li> <li>Refactored and renamed methods on <code>_HTTPClient</code> for clarity and maintainability.</li> <li>Updated documentation to use new <code>compute()</code> API instead of instantiating a <code>client</code>.</li> </ul>"},{"location":"CHANGELOG/#removed_1","title":"Removed","text":"<ul> <li><code>TaskStatus.complete</code>. <code>TaskStatus</code> has been expanded to mirror celery's states.</li> <li><code>FutureOutputGroup</code> in favor of a single <code>FutureResult</code> object that can handle both single tasks and arrays of tasks.</li> <li>Convenience types defined in <code>models</code>.</li> </ul>"},{"location":"CHANGELOG/#0125-2025-02-12","title":"0.12.5 - 2025-02-12","text":""},{"location":"CHANGELOG/#fixed","title":"Fixed","text":"<ul> <li>Retry logic for <code>httpx.RequestError</code> now correctly raises an exception after <code>max_attempts</code>. Requests that fail due to sporadic connection/network issues will now be retried up to <code>max_attempts</code> times.</li> </ul>"},{"location":"CHANGELOG/#changed_3","title":"Changed","text":"<ul> <li>Removed retry logic for 4xx and 5xx errors.</li> </ul>"},{"location":"CHANGELOG/#0124-2025-02-11","title":"0.12.4 - 2025-02-11","text":""},{"location":"CHANGELOG/#added_6","title":"Added","text":"<ul> <li>Retry requests for 4xx and 5xx status codes. This is a short term fix for the sporadic 500 errors related to <code>LookupError: unknown encoding: idna</code> on the server.</li> </ul>"},{"location":"CHANGELOG/#0123-2025-02-10","title":"0.12.3 - 2025-02-10","text":""},{"location":"CHANGELOG/#added_7","title":"Added","text":"<ul> <li>Retry loop for HTTP requests to handle ssl handshake errors or other non-HTTP status code errors.</li> </ul>"},{"location":"CHANGELOG/#0122-2025-02-07","title":"0.12.2 - 2025-02-07","text":""},{"location":"CHANGELOG/#changed_4","title":"Changed","text":"<ul> <li>Loosened dependency specifications for <code>qcio</code> and <code>httpx</code>.</li> </ul>"},{"location":"CHANGELOG/#0121-2024-09-11","title":"0.12.1 - 2024-09-11","text":""},{"location":"CHANGELOG/#changed_5","title":"Changed","text":"<ul> <li>Using <code>FutureOutput</code> for arrays of inputs of length 1.</li> <li>Updated to Python 3.9 typing syntax.</li> </ul>"},{"location":"CHANGELOG/#0120-2024-08-06","title":"0.12.0 - 2024-08-06","text":""},{"location":"CHANGELOG/#changed_6","title":"Changed","text":"<ul> <li>Removed <code>black</code> and <code>isort</code> in favor for <code>ruff</code></li> </ul>"},{"location":"CHANGELOG/#updated","title":"Updated","text":"<ul> <li>\ud83d\udea8 <code>python</code> (<code>&gt;=3.8</code> -&gt; <code>&gt;=3.9</code>)</li> <li><code>tomli</code> (<code>^1.0</code> -&gt; <code>^2.0</code>)</li> <li><code>httpx</code> (<code>^0.23.1</code> -&gt; <code>^0.27</code>)</li> <li><code>ruff</code> (<code>^0.0287</code> -&gt; <code>^0.5</code>)</li> <li><code>pytest-httpx</code> (<code>&lt;0.23.0</code> -&gt; <code>&gt;=0.23.0</code>)</li> <li><code>format.sh</code> script dropped <code>black</code> and <code>isort</code>.</li> </ul>"},{"location":"CHANGELOG/#0111-2024-07-19","title":"0.11.1 - 2024-07-19","text":""},{"location":"CHANGELOG/#changed_7","title":"Changed","text":"<ul> <li>Updated to qcio 0.11..</li> </ul>"},{"location":"CHANGELOG/#0110-2024-07-12","title":"0.11.0 - 2024-07-12","text":""},{"location":"CHANGELOG/#changed_8","title":"Changed","text":"<p>Updated qcio (0.10.1 -&gt; 0.10.2). <code>Structure.ids</code> -&gt; <code>Structure.identifiers</code></p>"},{"location":"CHANGELOG/#0101-2024-07-11","title":"0.10.1 - 2024-07-11","text":""},{"location":"CHANGELOG/#added_8","title":"Added","text":"<ul> <li><code>py.typed</code> file for type checking in projects that depend upon <code>chemcloud</code>.</li> </ul>"},{"location":"CHANGELOG/#0100-2024-07-10","title":"0.10.0 - 2024-07-10","text":""},{"location":"CHANGELOG/#changed_9","title":"Changed","text":"<ul> <li>Updated to <code>qcio 0.10.1</code> which uses <code>Structure</code> instead of <code>Molecule</code>.</li> </ul>"},{"location":"CHANGELOG/#090-2024-06-14","title":"0.9.0 - 2024-06-14","text":""},{"location":"CHANGELOG/#changed_10","title":"Changed","text":"<ul> <li>Upgraded to <code>qcio</code> Generics data structures.</li> <li>Upgraded <code>black</code> from <code>^23.0.0</code> to <code>^24.0.0</code>.</li> <li>Renamed <code>collect_wavefucntion</code> kwarg to <code>CCClient.compute(...)</code> to <code>collect_wfn</code>.</li> <li>Updated the response returned by ChemCloud server to have attributes <code>status</code> and <code>program_output</code> from <code>state</code> and <code>results</code>.</li> <li>Rebuilt documentation to reflect new <code>qcio</code> Generics and renamed kwargs.</li> </ul>"},{"location":"CHANGELOG/#083-2023-10-20","title":"0.8.3 - 2023-10-20","text":""},{"location":"CHANGELOG/#changed_11","title":"Changed","text":"<ul> <li>Updated GitHub actions to run on <code>pull_request</code> in addition to <code>push</code>.</li> <li>Migrated dependency <code>uiri/toml</code> to <code>hukkin/tomli</code> (Python &lt; 3.11) or the built-in <code>tomllib</code> (Python &gt;= 3.11)</li> <li>Updated GitHub actions to test against both Python 3.8 and Python 3.11</li> </ul>"},{"location":"CHANGELOG/#082-2023-09-25","title":"0.8.2 - 2023-09-25","text":""},{"location":"CHANGELOG/#changed_12","title":"Changed","text":"<ul> <li>Removed <code>pydantic==2.4.0</code> from supported versions due to immediate bug upon this release. When trying to import <code>CCClient</code> a reference count error appears to trigger a <code>KeyError</code>. Bugs are being tracked here: https://github.com/pydantic/pydantic/issues/7617.</li> </ul>"},{"location":"CHANGELOG/#081-2023-09-20","title":"0.8.1 - 2023-09-20","text":""},{"location":"CHANGELOG/#changed_13","title":"Changed","text":"<ul> <li>Updated to <code>qcio&gt;=0.7.0</code> to account for renaming of <code>DualProgramArgs</code> to <code>SubProgramArgs</code>.</li> </ul>"},{"location":"CHANGELOG/#080-2023-09-19","title":"0.8.0 - 2023-09-19","text":""},{"location":"CHANGELOG/#changed_14","title":"Changed","text":"<ul> <li><code>FutureResult</code> objects now called <code>FutureOutput</code> to keep in harmony with <code>qcio</code> nomenclature.</li> <li>Documentation rewritten to capture API changes with <code>qcio</code> and <code>qcop</code>.</li> <li><code>/examples</code> scripts instantiate a <code>Molecule</code> directly rather than opening <code>h2o.xyz</code> so that code examples can be run directly from the documentation website.</li> <li>All <code>mkdocs</code> and associated documentation packages updated to the latest versions.</li> </ul>"},{"location":"CHANGELOG/#070-2023-09-08","title":"0.7.0 - 2023-09-08","text":""},{"location":"CHANGELOG/#changed_15","title":"Changed","text":"<ul> <li>Dropped <code>QCElemental</code> in favor of <code>qcio</code>.</li> <li>Updated client to work with <code>v2</code> of the ChemCloud server using <code>qcio</code>.</li> <li>Updated DevOps stack to be in harmony with other qc* packages (<code>poetry</code>, <code>GitHub Actions</code>, <code>pre-commit</code>, etc).</li> <li>Updated from pydantic <code>v1</code> -&gt; <code>v2</code>, added <code>pydantic-settings</code> to dependencies.</li> <li>Changed settings <code>chemcloud_default_credentials_profile</code> to <code>chemcloud_credentials_profile</code>.</li> <li>Updated a few names from <code>result</code> to <code>output</code> to be more in harmony with <code>qcio</code> nomenclature.</li> </ul>"},{"location":"CHANGELOG/#added_9","title":"Added","text":"<ul> <li>Publish to pypi from GitHub actions.</li> </ul>"},{"location":"CHANGELOG/#062-2022-12-27","title":"0.6.2 - 2022-12-27","text":""},{"location":"CHANGELOG/#changed_16","title":"Changed","text":"<ul> <li>Updated <code>qcelemental==0.24.0 -&gt; 0.25.1</code></li> </ul>"},{"location":"CHANGELOG/#061-2022-07-19","title":"0.6.1 - 2022-07-19","text":""},{"location":"CHANGELOG/#changed_17","title":"Changed","text":"<ul> <li>Pegged <code>qcelemental</code> to version <code>0.24.0</code> since <code>0.25.0</code> introduces breaking changes. Need to keep this version in sync with <code>ChemCloud</code> server version.</li> </ul>"},{"location":"CHANGELOG/#060-2022-07-19","title":"0.6.0 - 2022-07-19","text":""},{"location":"CHANGELOG/#changed_18","title":"Changed","text":"<ul> <li>Updated project name from <code>qccloud</code> to <code>chemcloud</code></li> </ul>"},{"location":"CHANGELOG/#050-2022-07-15","title":"0.5.0 - 2022-07-15","text":""},{"location":"CHANGELOG/#changed_19","title":"Changed","text":"<ul> <li>Updated project name from <code>tccloud</code> to <code>qccloud</code></li> </ul>"},{"location":"CHANGELOG/#041-2022-05-07","title":"0.4.1 - 2022-05-07","text":""},{"location":"CHANGELOG/#changed_20","title":"Changed","text":"<ul> <li>Upped the default timeout on http reads from 5.0s -&gt; 20.0s.</li> </ul>"},{"location":"CHANGELOG/#040-2022-4-02","title":"0.4.0 - 2022-4-02","text":""},{"location":"CHANGELOG/#added_10","title":"Added","text":"<ul> <li><code>to_file()</code> and <code>from_file()</code> methods to easily save compute job ids for later retrieval.</li> </ul>"},{"location":"CHANGELOG/#changed_21","title":"Changed","text":"<ul> <li>Simplified management of task ids between client and server. Only need to send a single id to server even if a batch computation was initiated.</li> </ul>"},{"location":"CHANGELOG/#removed_2","title":"Removed","text":"<ul> <li>Support for Python3.6. Python3.6 end-of-lif'ed December 23, 2021.</li> </ul>"},{"location":"CHANGELOG/#031-2022-03-27","title":"0.3.1 - 2022-03-27","text":""},{"location":"CHANGELOG/#added_11","title":"Added","text":"<ul> <li>Decode b64 encoded data returned from server in <code>AtomicResult.extra['tcfe:keywords']</code></li> </ul>"},{"location":"CHANGELOG/#changed_22","title":"Changed","text":"<ul> <li>Updated <code>config.settings.tcfe_config_kwargs = \"tcfe:config</code> -&gt; <code>config.settings.tcfe_keywords = \"tcfe:keywords</code></li> </ul>"},{"location":"CHANGELOG/#030-2022-03-26","title":"0.3.0 - 2022-03-26","text":""},{"location":"CHANGELOG/#added_12","title":"Added","text":"<ul> <li>Support for <code>AtomicInput.protocols.native_files</code>. User can now request QC package specific files generated during a computation.</li> <li>Added support for TeraChem-specific <code>native_files</code>. c0/ca0/cb0 bytes files (or any bytes data) placed in <code>AtomicInput.extras['tcfe:keywords']</code> will be automatically base64 encoded and sent to the server. The enables seeding computations with a wave function as an initial guess.</li> <li>Base64 encoded <code>native_files</code> returned from server will be automatically decoded to bytes.</li> </ul>"},{"location":"CHANGELOG/#024-2021-06-07","title":"0.2.4 - 2021-06-07","text":""},{"location":"CHANGELOG/#added_13","title":"Added","text":"<ul> <li>Private compute queues to <code>compute()</code> and <code>compute_procedure()</code></li> </ul>"},{"location":"CHANGELOG/#023-2021-06-04","title":"0.2.3 - 2021-06-04","text":""},{"location":"CHANGELOG/#added_14","title":"Added","text":"<ul> <li>Batch compute for both <code>compute()</code> and <code>compute_procedure()</code> methods</li> <li><code>FutureResultGroup</code> for batch computations</li> </ul>"},{"location":"CHANGELOG/#changed_23","title":"Changed","text":"<ul> <li>Added <code>pydantic</code> <code>BaseModel</code> as base for <code>FutureResult</code> objects.</li> </ul>"},{"location":"CHANGELOG/#022-2021-05-21","title":"0.2.2 - 2021-05-21","text":""},{"location":"CHANGELOG/#added_15","title":"Added","text":"<ul> <li>Extended documentation to include a Code Reference section and much more comprehensive documentation of the main objects.</li> <li>Added <code>compute_procedure</code> to <code>TCClient</code> for geometry optimizations.</li> <li>Added <code>TCClient.version</code> property for quick version checks.</li> </ul>"},{"location":"CHANGELOG/#021-2021-03-05","title":"0.2.1 - 2021-03-05","text":""},{"location":"CHANGELOG/#added_16","title":"Added","text":"<ul> <li>Changelog</li> <li>User documentation</li> <li>Website for documentation</li> </ul>"},{"location":"CHANGELOG/#020-2021-02-26","title":"0.2.0 - 2021-02-26","text":""},{"location":"CHANGELOG/#added_17","title":"Added","text":"<ul> <li>Added <code>TaskStatus</code> enum to hold all task statuses.</li> <li>Basic documentation on main classes.</li> <li>[core_decisions.md] to document thinking behind architectural choices.</li> </ul>"},{"location":"CHANGELOG/#changed_24","title":"Changed","text":"<ul> <li><code>FutureResult.get()</code> to return either an <code>AtomicResult</code> or a <code>FailedComputation</code></li> <li>Simplified README.md overview to use dictionaries instead of classes. Results in simpler tutorial with fewer imports.</li> </ul>"},{"location":"CHANGELOG/#011-2021-01-22","title":"0.1.1 - 2021-01-22","text":""},{"location":"CHANGELOG/#added_18","title":"Added","text":"<ul> <li><code>TCClient</code> that can manage credentials, submit AtomicInput computations, and retrieve AtomicResult output from TeraChem Cloud.</li> <li><code>_RequestsClient</code> class that handles all network requests to TeraChem Cloud server</li> <li><code>FutureResults</code> object that is created from a <code>task_id</code> and can be used to retrieve a result once finished.</li> </ul>"},{"location":"dev-decisions/","title":"Core Development Decisions","text":""},{"location":"dev-decisions/#_requestsclient-class","title":"_RequestsClient Class","text":"<ul> <li><code>_RequestsClient</code> public http methods (like <code>compute()</code> and <code>result()</code> should always return Python objects. This gives a layer of abstraction between callers who want to think in terms of Python data objects and the <code>_RequestsClient</code> which thinks in terms of http requests and <code>json</code> data structures.</li> </ul> <p>I'm starting to have second thoughts about this ^^ decision. It feels like the <code>_RequestsClient</code> is starting to take on too much responsibility. It accepts python data types as parameters, and returns python data types as it if were an end-user class. It isn't. It's meant to be a utility class used by end-user objects such as <code>CCClient</code> and <code>FutureOutput</code> objects. I think it should return data more directly from the ChemCloud API and let the other classes handle this data. This becomes more apparent as I add <code>pydantic</code> to my data models and realize I'd rather have them pass rawer data types to the <code>_RequestsClient</code> and then handle the results of an API call inside their own class. Maybe the <code>compute()</code> method on the <code>_RequestsClient</code> should go away and these should live exclusively on the <code>CCClient</code> object which then utilizes <code>request</code> and <code>authenticated_request</code> to access ChemCloud.</p>"},{"location":"api-documentation/CCClient/","title":"CCClient","text":""},{"location":"api-documentation/CCClient/#chemcloud.client.CCClient","title":"chemcloud.client.CCClient","text":"<pre><code>CCClient(\n    *,\n    chemcloud_username: Optional[str] = None,\n    chemcloud_password: Optional[str] = None,\n    profile: Optional[str] = None,\n    chemcloud_domain: Optional[str] = None,\n    settings: Settings = settings,\n    queue: Optional[str] = None,\n)\n</code></pre> <p>Main client object to perform computations using ChemCloud.</p> <p>Parameters:</p> Name Type Description Default <code>chemcloud_username</code> <code>Optional[str]</code> <p>Your ChemCloud username (full email address).</p> <code>None</code> <code>chemcloud_password</code> <code>Optional[str]</code> <p>Your ChemCloud password.</p> <code>None</code> <code>profile</code> <code>Optional[str]</code> <p>A named profile for authentication with ChemCloud. No value needs to be passed and most users will only have one login with ChemCloud. CCClient will access the profile by default without a specific name being passed. Pass a value if you have multiple logins to ChemCloud.</p> <code>None</code> <code>chemcloud_domain</code> <code>Optional[str]</code> <p>The domain for the ChemCloud server. Defaults to https://chemcloud.mtzlab.com.</p> <code>None</code> <code>settings</code> <code>Settings</code> <p>An instance of the Settings class. Defaults to the global settings object.</p> <code>settings</code> <code>queue</code> <code>Optional[str]</code> <p>The name of a desired compute queue. If None, default queue is used from settings.</p> <code>None</code> Responsibilities <ul> <li>Expose domain-specific methods (e.g., compute, output) that operate with Python objects.</li> <li>Translate raw JSON responses into domain objects (e.g., FutureOutput).</li> <li>Handle OpenAPI specification caching, parameter validation, etc.</li> </ul> Source code in <code>chemcloud/client.py</code> <pre><code>def __init__(\n    self,\n    *,\n    chemcloud_username: Optional[str] = None,\n    chemcloud_password: Optional[str] = None,\n    profile: Optional[str] = None,\n    chemcloud_domain: Optional[str] = None,\n    settings: Settings = settings,\n    queue: Optional[str] = None,\n):\n    self._http_client = _HttpClient(\n        chemcloud_username=chemcloud_username,\n        chemcloud_password=chemcloud_password,\n        profile=profile,\n        chemcloud_domain=chemcloud_domain,\n        settings=settings,\n    )\n    self.queue = queue\n    self._settings = settings\n    self._openapi_spec: Optional[dict[str, Any]] = None\n</code></pre>"},{"location":"api-documentation/CCClient/#chemcloud.client.CCClient.version","title":"version  <code>property</code>","text":"<pre><code>version: str\n</code></pre> <p>Returns chemcloud client version</p>"},{"location":"api-documentation/CCClient/#chemcloud.client.CCClient.supported_programs","title":"supported_programs  <code>property</code>","text":"<pre><code>supported_programs: list[str]\n</code></pre> <p>Sync wrapper for supported_programs_async.</p>"},{"location":"api-documentation/CCClient/#chemcloud.client.CCClient.compute_async","title":"compute_async  <code>async</code>","text":"<pre><code>compute_async(\n    program: str,\n    inp_obj: Union[Any, list[Any]],\n    *,\n    collect_stdout: bool = True,\n    collect_files: bool = False,\n    collect_wfn: bool = False,\n    rm_scratch_dir: bool = True,\n    propagate_wfn: bool = False,\n    queue: Optional[str] = None,\n    return_future: bool = False,\n) -&gt; Union[\n    ProgramOutput, list[ProgramOutput], FutureOutput\n]\n</code></pre> <p>Asynchronously submit a computation to ChemCloud.</p> <p>Parameters:</p> Name Type Description Default <code>program</code> <code>str</code> <p>A program name matching one of the self.supported_programs</p> required <code>inp_obj</code> <code>Union[Any, list[Any]]</code> <p>The input object to be used for the computation. This can be a single input object or a list of input objects.</p> required <code>collect_stdout</code> <code>bool</code> <p>Whether to collect stdout/stderr from the program as output. Failed computations will always collect stdout/stderr.</p> <code>True</code> <code>collect_files</code> <code>bool</code> <p>Collect all files generated by the QC program as output.</p> <code>False</code> <code>collect_wfn</code> <code>bool</code> <p>Collect the wavefunction file(s) from the calculation. Not every program will support this. Use collect_files to collect all files including the wavefunction.</p> <code>False</code> <code>rm_scratch_dir</code> <code>bool</code> <p>Delete the scratch directory after the program exits. Should only be set to False for debugging purposes.</p> <code>True</code> <code>propagate_wfn</code> <code>bool</code> <p>For any adapter performing a sequential task, such as a geometry optimization, propagate the wavefunction from the previous step to the next step. This is useful for accelerating convergence by using a previously computed wavefunction as a starting guess. This will be ignored if the adapter for a given qc program does not support it.</p> <code>False</code> <code>queue</code> <code>Optional[str]</code> <p>The name of a private compute queue. If None, default queue is used from settings.</p> <code>None</code> <code>return_future</code> <code>bool</code> <p>If True, return a FutureOutput object. If False, block and return the ProgramOutput object(s) directly.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[ProgramOutput, list[ProgramOutput], FutureOutput]</code> <p>Object providing access to a computation's eventual result. You can check a</p> <code>Union[ProgramOutput, list[ProgramOutput], FutureOutput]</code> <p>computation's status by running .status on the FutureOutput object or</p> <code>Union[ProgramOutput, list[ProgramOutput], FutureOutput]</code> <p>.get() to block and retrieve the computation's final result.</p> Source code in <code>chemcloud/client.py</code> <pre><code>async def compute_async(\n    self,\n    program: str,\n    inp_obj: Union[Any, list[Any]],\n    *,\n    collect_stdout: bool = True,\n    collect_files: bool = False,\n    collect_wfn: bool = False,\n    rm_scratch_dir: bool = True,\n    propagate_wfn: bool = False,\n    queue: Optional[str] = None,\n    return_future: bool = False,\n) -&gt; Union[ProgramOutput, list[ProgramOutput], FutureOutput]:\n    \"\"\"Asynchronously submit a computation to ChemCloud.\n\n    Parameters:\n        program: A program name matching one of the self.supported_programs\n        inp_obj: The input object to be used for the computation. This can be a\n            single input object or a list of input objects.\n        collect_stdout: Whether to collect stdout/stderr from the program as output.\n            Failed computations will always collect stdout/stderr.\n        collect_files: Collect all files generated by the QC program as output.\n        collect_wfn: Collect the wavefunction file(s) from the calculation.\n            Not every program will support this. Use collect_files to collect\n            all files including the wavefunction.\n        rm_scratch_dir: Delete the scratch directory after the program exits. Should\n            only be set to False for debugging purposes.\n        propagate_wfn: For any adapter performing a sequential task, such\n            as a geometry optimization, propagate the wavefunction from the previous\n            step to the next step. This is useful for accelerating convergence by\n            using a previously computed wavefunction as a starting guess. This will\n            be ignored if the adapter for a given qc program does not support it.\n        queue: The name of a private compute queue. If None, default queue is used\n            from settings.\n        return_future: If True, return a FutureOutput object. If False, block and\n            return the ProgramOutput object(s) directly.\n\n    Returns:\n        Object providing access to a computation's eventual result. You can check a\n        computation's status by running .status on the FutureOutput object or\n        .get() to block and retrieve the computation's final result.\n    \"\"\"\n    if not inp_obj:\n        raise ValueError(\"Please provide input objects for the computation.\")\n\n    logger.info(\n        f\"Submitting compute job for program {program} with inputs {inp_obj}.\"\n    )\n    supported_programs = await self.supported_programs_async()\n    if program not in supported_programs:\n        raise UnsupportedProgramError(\n            f\"Please use one of the following programs: {supported_programs}\"\n        )\n    url_params = {\n        \"program\": program,\n        \"collect_stdout\": collect_stdout,\n        \"collect_files\": collect_files,\n        \"collect_wfn\": collect_wfn,\n        \"rm_scratch_dir\": rm_scratch_dir,\n        \"propagate_wfn\": propagate_wfn,\n        \"queue\": queue or self.queue or self._settings.chemcloud_queue,\n    }\n\n    # Normalize inputs to a list.\n    inp_list = [inp_obj] if not isinstance(inp_obj, list) else inp_obj\n\n    # Create a list of coroutines to submit compute requests.\n    coroutines = [\n        self._http_client._authenticated_request_async(\n            \"post\", \"/compute\", data=inp, params=url_params\n        )\n        for inp in inp_list\n    ]\n    # Use asyncio.gather to run them concurrently.\n    task_ids = await asyncio.gather(*coroutines)\n\n    future = FutureOutput(\n        task_ids=task_ids,\n        inputs=inp_list,\n        program=program,\n        client=self,\n        return_single_output=not isinstance(inp_obj, list),\n    )\n    if return_future:\n        return future\n    return await future.get_async()\n</code></pre>"},{"location":"api-documentation/CCClient/#chemcloud.client.CCClient.compute","title":"compute","text":"<pre><code>compute(\n    *args, **kwargs\n) -&gt; Union[\n    ProgramOutput, list[ProgramOutput], FutureOutput\n]\n</code></pre> <p>Synchronous wrapper for compute_async.</p> Source code in <code>chemcloud/client.py</code> <pre><code>def compute(\n    self, *args, **kwargs\n) -&gt; Union[ProgramOutput, list[ProgramOutput], FutureOutput]:\n    \"\"\"Synchronous wrapper for compute_async.\"\"\"\n    return self.run(self.compute_async(*args, **kwargs))\n</code></pre>"},{"location":"api-documentation/CCClient/#chemcloud.client.CCClient.fetch_output_async","title":"fetch_output_async  <code>async</code>","text":"<pre><code>fetch_output_async(\n    task_id: str, delete: bool = True\n) -&gt; tuple[TaskStatus, Optional[ProgramOutput]]\n</code></pre> <p>Get the status and output (if it is complete) of a task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to check.</p> required <code>delete</code> <code>bool</code> <p>Whether to delete the output from the server after fetching.</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[TaskStatus, Optional[ProgramOutput]]</code> <p>A tuple of the task status and the output object if available.</p> Source code in <code>chemcloud/client.py</code> <pre><code>async def fetch_output_async(\n    self, task_id: str, delete: bool = True\n) -&gt; tuple[TaskStatus, Optional[ProgramOutput]]:\n    \"\"\"\n    Get the status and output (if it is complete) of a task.\n\n    Parameters:\n        task_id: The ID of the task to check.\n        delete: Whether to delete the output from the server after fetching.\n\n    Returns:\n        A tuple of the task status and the output object if available.\n    \"\"\"\n    response = await self._http_client._authenticated_request_async(\n        \"get\", f\"/compute/output/{task_id}\"\n    )\n    status = TaskStatus(response.get(\"status\", TaskStatus.PENDING))\n    output = response.get(\"program_output\")\n    if output is not None:\n        output = ProgramOutput(**output)\n    if status in READY_STATES and delete:\n        # Fire-and-forget the deletion task\n        asyncio.create_task(self.delete_output_async(task_id))\n    return status, output\n</code></pre>"},{"location":"api-documentation/CCClient/#chemcloud.client.CCClient.fetch_output","title":"fetch_output","text":"<pre><code>fetch_output(\n    task_id: str,\n) -&gt; tuple[\n    TaskStatus,\n    Optional[Union[ProgramOutput, list[ProgramOutput]]],\n]\n</code></pre> <p>Sync wrapper for <code>fetch_output_async</code>.</p> Source code in <code>chemcloud/client.py</code> <pre><code>def fetch_output(\n    self, task_id: str\n) -&gt; tuple[TaskStatus, Optional[Union[ProgramOutput, list[ProgramOutput]]]]:\n    \"\"\"Sync wrapper for `fetch_output_async`.\"\"\"\n    return self.run(self.fetch_output_async(task_id))\n</code></pre>"},{"location":"api-documentation/CCClient/#chemcloud.client.CCClient.delete_output_async","title":"delete_output_async  <code>async</code>","text":"<pre><code>delete_output_async(task_id: str) -&gt; None\n</code></pre> <p>Delete a task's output from the ChemCloud server.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to delete.</p> required Source code in <code>chemcloud/client.py</code> <pre><code>async def delete_output_async(self, task_id: str) -&gt; None:\n    \"\"\"\n    Delete a task's output from the ChemCloud server.\n\n    Parameters:\n        task_id: The ID of the task to delete.\n    \"\"\"\n    logger.debug(f\"Deleting output for task {task_id}\")\n    await self._http_client._authenticated_request_async(\n        \"delete\", f\"/compute/output/{task_id}\"\n    )\n    logger.debug(f\"Output deleted for task {task_id}\")\n</code></pre>"},{"location":"api-documentation/CCClient/#chemcloud.client.CCClient.delete_output","title":"delete_output","text":"<pre><code>delete_output(task_id: str) -&gt; None\n</code></pre> <p>Sync wrapper for <code>delete_output_async</code>.</p> Source code in <code>chemcloud/client.py</code> <pre><code>def delete_output(self, task_id: str) -&gt; None:\n    \"\"\"Sync wrapper for `delete_output_async`.\"\"\"\n    return self.run(self.delete_output_async(task_id))\n</code></pre>"},{"location":"api-documentation/CCClient/#chemcloud.client.CCClient.run","title":"run","text":"<pre><code>run(coro: Coroutine[Any, Any, Any]) -&gt; Any\n</code></pre> <p>Synchronous runner for async methods. Akin to asyncio.run() but centralized on CCClient since we have to modify the ._http_client._async_client and semaphore.</p> Source code in <code>chemcloud/client.py</code> <pre><code>def run(self, coro: Coroutine[Any, Any, Any]) -&gt; Any:\n    \"\"\"\n    Synchronous runner for async methods. Akin to asyncio.run() but centralized\n    on CCClient since we have to modify the ._http_client._async_client and\n    semaphore.\n    \"\"\"\n    return asyncio.run(self._run_helper(coro))\n</code></pre>"},{"location":"api-documentation/CCClient/#chemcloud.client.CCClient.hello_world","title":"hello_world","text":"<pre><code>hello_world(name: Optional[str] = None) -&gt; str\n</code></pre> <p>A simple endpoint to check connectivity to ChemCloud.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Your name</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A message from ChemCloud if the client was able to successfully</p> <code>str</code> <p>connect.</p> Source code in <code>chemcloud/client.py</code> <pre><code>def hello_world(self, name: Optional[str] = None) -&gt; str:\n    \"\"\"A simple endpoint to check connectivity to ChemCloud.\n\n    Parameters:\n        name: Your name\n\n    Returns:\n        A message from ChemCloud if the client was able to successfully\n        connect.\n    \"\"\"\n    logger.info(f\"Sending hello_world request with name: {name}\")\n\n    # Run a single asynchronous request synchronously via run_parallel_requests.\n    return self.run(\n        self._http_client._request_async(\n            \"get\", \"/hello-world\", params={\"name\": name}, api_call=False\n        )\n    )\n</code></pre>"},{"location":"api-documentation/CCClient/#chemcloud.client.CCClient.openapi_spec_async","title":"openapi_spec_async  <code>async</code>","text":"<pre><code>openapi_spec_async() -&gt; dict[str, Any]\n</code></pre> <p>Asynchronously retrieves and caches the OpenAPI specification from the ChemCloud server.</p> Source code in <code>chemcloud/client.py</code> <pre><code>async def openapi_spec_async(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Asynchronously retrieves and caches the OpenAPI specification from the ChemCloud server.\n    \"\"\"\n    if self._openapi_spec is None:\n        result = await self._http_client._request_async(\n            \"get\", \"/openapi.json\", api_call=False\n        )\n        self._openapi_spec = result\n    return self._openapi_spec\n</code></pre>"},{"location":"api-documentation/CCClient/#chemcloud.client.CCClient.supported_programs_async","title":"supported_programs_async  <code>async</code>","text":"<pre><code>supported_programs_async() -&gt; list[str]\n</code></pre> <p>Asynchronously returns the list of supported programs from the OpenAPI specification.</p> Source code in <code>chemcloud/client.py</code> <pre><code>async def supported_programs_async(self) -&gt; list[str]:\n    \"\"\"\n    Asynchronously returns the list of supported programs from the OpenAPI specification.\n    \"\"\"\n    spec = await self.openapi_spec_async()\n    try:\n        programs = spec[\"components\"][\"schemas\"][\"SupportedPrograms\"][\"enum\"]\n    except (KeyError, IndexError):\n        logger.warning(\"Cannot locate currently supported programs.\")\n        programs = [\"\"]\n    return programs\n</code></pre>"},{"location":"api-documentation/CCClient/#chemcloud.client.CCClient.setup_profile","title":"setup_profile","text":"<pre><code>setup_profile(profile: Optional[str] = None) -&gt; None\n</code></pre> <p>Setup profiles for authentication with ChemCloud.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[str]</code> <p>Optional value to create a named profile for use with QC Cloud. No value needs to be passed and most users will only have one login with ChemCloud. CCClient will access the profile by default without a specific name being passed. Pass a value if you have multiple logins to ChemCloud.</p> <code>None</code> <p>Note:     Configures <code>chemcloud</code> to use the passed credentials automatically in the     future. You only need to run this method once per profile. Credentials will     be loaded automatically from the credentials file in the future.</p> Source code in <code>chemcloud/client.py</code> <pre><code>def setup_profile(self, profile: Optional[str] = None) -&gt; None:\n    \"\"\"Setup profiles for authentication with ChemCloud.\n\n    Parameters:\n        profile: Optional value to create a named profile for use with QC\n            Cloud. No value needs to be passed and most users will only have one\n            login with ChemCloud. CCClient will access the profile by\n            default without a specific name being passed. Pass a value if you have\n            multiple logins to ChemCloud.\n    Note:\n        Configures `chemcloud` to use the passed credentials automatically in the\n        future. You only need to run this method once per profile. Credentials will\n        be loaded automatically from the credentials file in the future.\n    \"\"\"\n    profile = profile or self._settings.chemcloud_credentials_profile\n    print(\n        f\"\u2705 If you don't have an account, please signup at: {self._http_client._chemcloud_domain}/signup\"\n    )\n    # Use the async _set_tokens_from_user_input wrapped via run_parallel_requests\n    access_token, refresh_token = self.run(\n        self._http_client._set_tokens_from_user_input()\n    )\n    self._http_client.write_tokens_to_credentials_file(\n        access_token, refresh_token, profile=profile\n    )\n    print(\n        f\"'{profile}' profile configured! Username/password not required for future use.\"\n    )\n</code></pre>"},{"location":"api-documentation/FutureOutput/","title":"FutureOutput","text":""},{"location":"api-documentation/FutureOutput/#chemcloud.models","title":"chemcloud.models","text":""},{"location":"api-documentation/FutureOutput/#chemcloud.models.TaskStatus","title":"TaskStatus","text":"<p>Tasks status for a submitted compute job</p>"},{"location":"api-documentation/FutureOutput/#chemcloud.models.FutureOutput","title":"FutureOutput","text":"<p>Represents one or more asynchronous compute tasks.</p> Developer Note <p>Rather than refactoring into a <code>BaseFutureOutput</code> with <code>FutureOutput</code> and <code>FutureOutputs</code> subclass, we use the <code>return_single_output</code> flag to determine when the <code>.get()</code> method should return a <code>ProgramOutput</code> or <code>list[ProgramOutput]</code> and when to enable the <code>.task_id</code> attribute. This simplifies the API, reduces code complexity, removes the need for <code>isinstance</code> checks, and still gives the same end user experience. We can rethink this design if it becomes an issue.</p> <p>Attributes:</p> Name Type Description <code>task_ids</code> <code>list[str]</code> <p>A list of task IDs from a compute submission.</p> <code>input_data</code> <code>list[str]</code> <p>A list of input data objects for each task.</p> <code>program</code> <code>str</code> <p>The program used for the computation.</p> <code>client</code> <code>Any</code> <p>A <code>CCClient</code> instance that can perform HTTP requests to check task status.</p> <code>return_single_output</code> <code>bool</code> <p>If True, indicates that the <code>.get()</code> method will return a single ProgramOutput rather than a list. Also enables the <code>.task_id</code> property.</p> <code>outputs</code> <code>list[Optional[ProgramOutput]]</code> <p>A list of ProgramOutputs once tasks are completed (order corresponds to task_ids). Generally not passed by the user, but used internally to track task outputs.</p> <code>statuses</code> <code>list[TaskStatus]</code> <p>A list of TaskStatus enums corresponding to the status of each task. Generally not passed by the user, but used internally to track task status.</p>"},{"location":"api-documentation/FutureOutput/#chemcloud.models.FutureOutput.task_id","title":"task_id  <code>property</code>","text":"<pre><code>task_id: str\n</code></pre> <p>Return the task id if only a single computation was submitted.</p>"},{"location":"api-documentation/FutureOutput/#chemcloud.models.FutureOutput.is_ready","title":"is_ready  <code>property</code>","text":"<pre><code>is_ready: bool\n</code></pre> <p>Synch wrapper around <code>is_ready_async</code>.</p>"},{"location":"api-documentation/FutureOutput/#chemcloud.models.FutureOutput.refresh_async","title":"refresh_async  <code>async</code>","text":"<pre><code>refresh_async() -&gt; None\n</code></pre> <p>Refresh the status and output for uncollected tasks.</p> Source code in <code>chemcloud/models.py</code> <pre><code>async def refresh_async(self) -&gt; None:\n    \"\"\"Refresh the status and output for uncollected tasks.\"\"\"\n    logger.debug(\"Refreshing task statuses and outputs.\")\n\n    # Identify unfinished tasks\n    assert self.statuses is not None  # For mypy\n    unfinished_indices = [\n        i for i, status in enumerate(self.statuses) if status not in READY_STATES\n    ]\n    if not unfinished_indices:\n        logger.debug(\"No unfinished tasks to refresh.\")\n        return  # Nothing to refresh\n\n    # Build coroutines to refresh unfinished tasks\n    coroutines = [\n        self.client.fetch_output_async(self.task_ids[i]) for i in unfinished_indices\n    ]\n    # Run the coroutines in parallel; collect statues and results.\n    logger.info(f\"Refreshing {len(unfinished_indices)} unfinished task(s).\")\n    results = await asyncio.gather(*coroutines, return_exceptions=True)\n\n    # Update statuses and outputs based on results\n    for i, result in zip(unfinished_indices, results):\n        # Insulate users against all HTTP errors\n        if isinstance(result, HTTPError):\n            logger.error(\n                f\"Error collecting task {self.task_ids[i]}: {result}\", exc_info=True\n            )\n            self.statuses[i] = TaskStatus.FAILURE\n            self.outputs[i] = self._output_from_exception(result, self.inputs[i])\n        else:\n            assert (\n                isinstance(result, tuple) and len(result) == 2\n            ), \"Invalid result returned.\"\n            logger.debug(f\"Task {self.task_ids[i]} collected: status {result[0]}\")\n            self.statuses[i], self.outputs[i] = result\n</code></pre>"},{"location":"api-documentation/FutureOutput/#chemcloud.models.FutureOutput.refresh","title":"refresh","text":"<pre><code>refresh()\n</code></pre> <p>Sync wrapper around <code>refresh_async</code>.</p> Source code in <code>chemcloud/models.py</code> <pre><code>def refresh(self):\n    \"\"\"Sync wrapper around `refresh_async`.\"\"\"\n    return self.client.run(self.refresh_async())\n</code></pre>"},{"location":"api-documentation/FutureOutput/#chemcloud.models.FutureOutput.get_async","title":"get_async  <code>async</code>","text":"<pre><code>get_async(\n    timeout: Optional[float] = None,\n    initial_interval: float = 1.0,\n) -&gt; Union[ProgramOutput, list[ProgramOutput]]\n</code></pre> <p>Block until all tasks complete and return their ProgramOutputs.</p> <p>If only one task was submitted, returns the single result; otherwise, returns a list of program_outputs.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>Optional[float]</code> <p>The maximum time to wait for all tasks to complete.</p> <code>None</code> <code>initial_interval</code> <code>float</code> <p>The initial interval between status checks.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>Union[ProgramOutput, list[ProgramOutput]]</code> <p>The ProgramOutput objects for all tasks once they are complete.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the timeout is exceeded before all tasks complete.</p> Source code in <code>chemcloud/models.py</code> <pre><code>async def get_async(\n    self, timeout: Optional[float] = None, initial_interval: float = 1.0\n) -&gt; Union[ProgramOutput, list[ProgramOutput]]:\n    \"\"\"\n    Block until all tasks complete and return their ProgramOutputs.\n\n    If only one task was submitted, returns the single result;\n    otherwise, returns a list of program_outputs.\n\n    Parameters:\n        timeout: The maximum time to wait for all tasks to complete.\n        initial_interval: The initial interval between status checks.\n\n    Returns:\n        The ProgramOutput objects for all tasks once they are complete.\n\n    Raises:\n        TimeoutError: If the timeout is exceeded before all tasks complete.\n    \"\"\"\n    start = time()\n    interval = initial_interval\n    completed = 0\n    while not await self.is_ready_async():\n        # Check for timeout\n        elapsed = time() - start\n        logger.debug(\n            f\"Waiting for tasks to complete... elapsed time: {elapsed:.2f}s\"\n        )\n        if timeout is not None and elapsed &gt; timeout:\n            raise TimeoutError(\n                f\"Timeout of {timeout} seconds exceeded while waiting for tasks.\"\n            )\n        # Refresh statuses and outputs\n        await self.refresh_async()\n        # Check for new completions\n        new_completed = sum(status in READY_STATES for status in self.statuses)\n        if new_completed &gt; completed:\n            completed = new_completed\n            interval = initial_interval  # Reset interval if new completions found\n        else:\n            # Increase interval gradually (up to a max value)\n            interval = min(interval * 1.5, 30.0)\n        logger.debug(f\"Sleeping for {interval:.2f} seconds before next poll.\")\n        await asyncio.sleep(interval)\n\n    logger.info(\"All tasks are ready. Returning results.\")\n    assert all(\n        output is not None for output in self.outputs\n    ), \"All outputs should be collected at this point.\"\n    if self.return_single_output:\n        return cast(ProgramOutput, self.outputs[0])\n    return cast(list[ProgramOutput], self.outputs)\n</code></pre>"},{"location":"api-documentation/FutureOutput/#chemcloud.models.FutureOutput.get","title":"get","text":"<pre><code>get(\n    *args, **kwargs\n) -&gt; Union[ProgramOutput, list[ProgramOutput]]\n</code></pre> <p>Sync wrapper around <code>get_async</code>.</p> Source code in <code>chemcloud/models.py</code> <pre><code>def get(self, *args, **kwargs) -&gt; Union[ProgramOutput, list[ProgramOutput]]:\n    \"\"\"Sync wrapper around `get_async`.\"\"\"\n    return self.client.run(self.get_async(*args, **kwargs))\n</code></pre>"},{"location":"api-documentation/FutureOutput/#chemcloud.models.FutureOutput.is_ready_async","title":"is_ready_async  <code>async</code>","text":"<pre><code>is_ready_async() -&gt; bool\n</code></pre> <p>Asynchronously refreshes the statuses and checks if all tasks are complete.</p> Source code in <code>chemcloud/models.py</code> <pre><code>async def is_ready_async(self) -&gt; bool:\n    \"\"\"\n    Asynchronously refreshes the statuses and checks if all tasks are complete.\n    \"\"\"\n    await self.refresh_async()\n    return all(status in READY_STATES for status in self.statuses)\n</code></pre>"},{"location":"api-documentation/FutureOutput/#chemcloud.models.FutureOutput.as_completed_async","title":"as_completed_async  <code>async</code>","text":"<pre><code>as_completed_async(\n    initial_interval: float = 1.0,\n) -&gt; AsyncGenerator[ProgramOutput, None]\n</code></pre> <p>Yields ProgramOutput objects as tasks become ready (SUCCESS, FAILURE, or REVOKED). Blocks until all tasks have finished or the generator is exhausted.</p> <p>This uses the same refresh logic as <code>.get_async()</code>, so it will automatically handle errors and generate ProgramOutput objects (including error placeholders) in the same way. The order in which results are yielded is not guaranteed to match the exact order tasks finish on the server.</p> <p>Parameters:</p> Name Type Description Default <code>initial_interval</code> <code>float</code> <p>The initial interval (in seconds) between refresh calls.</p> <code>1.0</code> <p>Yields:</p> Type Description <code>AsyncGenerator[ProgramOutput, None]</code> <p>ProgramOutput objects for each task as they become ready.</p> <code>AsyncGenerator[ProgramOutput, None]</code> <p>If a task fails, the yielded ProgramOutput will contain</p> <code>AsyncGenerator[ProgramOutput, None]</code> <p>error/traceback information (just like <code>.get_async()</code>).</p> Source code in <code>chemcloud/models.py</code> <pre><code>async def as_completed_async(\n    self, initial_interval: float = 1.0\n) -&gt; AsyncGenerator[ProgramOutput, None]:\n    \"\"\"\n    Yields ProgramOutput objects as tasks become ready (SUCCESS, FAILURE, or REVOKED).\n    Blocks until all tasks have finished or the generator is exhausted.\n\n    This uses the same refresh logic as `.get_async()`, so it will automatically\n    handle errors and generate ProgramOutput objects (including error placeholders)\n    in the same way. The order in which results are yielded is not guaranteed\n    to match the exact order tasks finish on the server.\n\n    Parameters:\n        initial_interval: The initial interval (in seconds) between refresh calls.\n        This interval is increased by a factor of 1.5 on every poll cycle that\n        finds no newly completed tasks, up to a maximum of 30 seconds.\n\n    Yields:\n        ProgramOutput objects for each task as they become ready.\n        If a task fails, the yielded ProgramOutput will contain\n        error/traceback information (just like `.get_async()`).\n    \"\"\"\n    done_indices: set[int] = set()\n    interval = initial_interval\n    while len(done_indices) &lt; len(self.task_ids):\n        logger.debug(\"Polling for task completions...\")\n        await self.refresh_async()\n        any_new = False\n        for i, status in enumerate(self.statuses):\n            if i not in done_indices and status in READY_STATES:\n                logger.info(\n                    f\"Task {self.task_ids[i]} is complete with status {status}.\"\n                )\n                done_indices.add(i)\n                any_new = True\n                if self.outputs[i] is not None:\n                    yield cast(ProgramOutput, self.outputs[i])\n                    self.outputs[i] = None  # Optional: clear to free memory\n\n        if any_new:\n            # Reset interval if new completions were found.\n            interval = initial_interval\n\n        else:\n            interval = min(interval * 1.5, 30.0)\n            logger.debug(f\"No new completions; sleeping {interval:.2f} seconds.\")\n            await asyncio.sleep(interval)\n</code></pre>"},{"location":"api-documentation/FutureOutput/#chemcloud.models.FutureOutput.as_completed","title":"as_completed","text":"<pre><code>as_completed(\n    initial_interval: float = 1.0,\n) -&gt; Generator[ProgramOutput, None, None]\n</code></pre> <p>Synchronous implementation of <code>as_completed_async</code>.</p> <p>Cannot directly wrap async version due to it containing an AsyncGenerator, and asyncio.sleep() so we must reimplement the logic here.</p> Source code in <code>chemcloud/models.py</code> <pre><code>def as_completed(\n    self, initial_interval: float = 1.0\n) -&gt; Generator[ProgramOutput, None, None]:\n    \"\"\"\n    Synchronous implementation of `as_completed_async`.\n\n    Cannot directly wrap async version due to it containing an AsyncGenerator, and\n    asyncio.sleep() so we must reimplement the logic here.\n    \"\"\"\n    done_indices: set[int] = set()\n    interval = initial_interval\n\n    # Keep polling until all tasks are completed\n    while len(done_indices) &lt; len(self.task_ids):\n        logger.debug(\"Polling for task completions...\")\n        self.refresh()\n        any_new = False\n        for i, status in enumerate(self.statuses):\n            if i not in done_indices and status in READY_STATES:\n                logger.info(\n                    f\"Task {self.task_ids[i]} is complete with status {status}.\"\n                )\n                done_indices.add(i)\n                any_new = True\n                assert self.outputs[i] is not None\n                yield cast(ProgramOutput, self.outputs[i])\n                self.outputs[i] = None  # Clear the output to save memory\n\n        if any_new:\n            # Reset interval if new completions were found.\n            interval = initial_interval\n        else:\n            # Increase interval if nothing new was found.\n            interval = min(interval * 1.5, 30.0)\n            logger.debug(f\"No new completions; sleeping {interval:.2f} seconds.\")\n            sleep(interval)\n</code></pre>"},{"location":"api-documentation/FutureOutput/#chemcloud.models.FutureOutput.save","title":"save","text":"<pre><code>save(path: Optional[Union[str, Path]] = None) -&gt; None\n</code></pre> <p>Save the FutureOutput to a JSON file.</p> Source code in <code>chemcloud/models.py</code> <pre><code>def save(self, path: Optional[Union[str, Path]] = None) -&gt; None:\n    \"\"\"Save the FutureOutput to a JSON file.\"\"\"\n    path = (\n        Path(path)\n        if path is not None\n        else Path.cwd() / f\"future-{uuid4().hex}.json\"\n    )\n    path.parent.mkdir(parents=True, exist_ok=True)\n    path.write_text(json.dumps(self.model_dump()))\n</code></pre>"},{"location":"api-documentation/FutureOutput/#chemcloud.models.FutureOutput.open","title":"open  <code>classmethod</code>","text":"<pre><code>open(path: Union[str, Path]) -&gt; FutureOutput\n</code></pre> <p>Load a FutureOutput from a JSON file.</p> Source code in <code>chemcloud/models.py</code> <pre><code>@classmethod\ndef open(self, path: Union[str, Path]) -&gt; \"FutureOutput\":\n    \"\"\"Load a FutureOutput from a JSON file.\"\"\"\n    data = json.loads(Path(path).read_text())\n    return FutureOutput(**data)\n</code></pre>"},{"location":"api-documentation/Main%20Methods/","title":"Main Methods","text":"<p>Top-level methods for running calculations with <code>chemcloud</code>. Most users should never need to use anything except these methods for running calculations on chemcloud.</p>"},{"location":"api-documentation/Main%20Methods/#chemcloud","title":"chemcloud","text":"<p>ChemCloud python client. Scalable compute, easy to learn, fast to code.</p>"},{"location":"api-documentation/Main%20Methods/#chemcloud.compute","title":"compute","text":"<pre><code>compute(\n    *args, **kwargs\n) -&gt; Union[\n    ProgramOutput, list[ProgramOutput], FutureOutput\n]\n</code></pre> <p>Submit a compute job using the default client.</p> <p>See CCClient.compute for more information.</p> Usage <pre><code>from qcio import ProgramInput, Structure\nfrom chemcloud import compute\n\nstruct = Structure.open(\"structure.xyz\")\nprog_input = ProgramInput(\n    calctype=\"energy\",\n    structure=struct,\n    model={\"method\": \"b3lyp\", \"basis\": \"6-31g\"},\n    keywords={},  # Optional keywords for the program\n    )\n\n# Submit a single job\noutput = compute(\"psi4\", prog_input)\n\n# Submit multiple jobs\nprog_inputs = [prog_input] * 100  # List of ProgramInput objects\noutputs = compute(\"psi4\", prog_inputs)\n</code></pre> <p>Results may be collected asynchronously if desired:</p> <pre><code>future = compute(\"psi4\", prog_inputs, return_future=True)\nfuture.is_ready  # Checks if all tasks are complete (not required)\noutputs = future.get()  # Collects results\n</code></pre> <p>Or stream results from the server as they complete:</p> <pre><code>future = compute(\"psi4\", prog_inputs, return_future=True)\nfor output in future.as_completed():  # Will return results as the complete\n    # Process outputs\n</code></pre> Source code in <code>chemcloud/__init__.py</code> <pre><code>def compute(*args, **kwargs) -&gt; Union[ProgramOutput, list[ProgramOutput], FutureOutput]:\n    \"\"\"Submit a compute job using the default client.\n\n    See [CCClient.compute][chemcloud.client.CCClient.compute] for more information.\n\n    Usage:\n        ```python\n        from qcio import ProgramInput, Structure\n        from chemcloud import compute\n\n        struct = Structure.open(\"structure.xyz\")\n        prog_input = ProgramInput(\n            calctype=\"energy\",\n            structure=struct,\n            model={\"method\": \"b3lyp\", \"basis\": \"6-31g\"},\n            keywords={},  # Optional keywords for the program\n            )\n\n        # Submit a single job\n        output = compute(\"psi4\", prog_input)\n\n        # Submit multiple jobs\n        prog_inputs = [prog_input] * 100  # List of ProgramInput objects\n        outputs = compute(\"psi4\", prog_inputs)\n        ```\n\n        Results may be collected asynchronously if desired:\n\n        ```python\n        future = compute(\"psi4\", prog_inputs, return_future=True)\n        future.is_ready  # Checks if all tasks are complete (not required)\n        outputs = future.get()  # Collects results\n        ```\n\n        Or stream results from the server as they complete:\n\n        ```python\n        future = compute(\"psi4\", prog_inputs, return_future=True)\n        for output in future.as_completed():  # Will return results as the complete\n            # Process outputs\n        ```\n    \"\"\"\n    global _default_client\n    if _default_client is None:\n        _default_client = CCClient()\n    return _default_client.compute(*args, **kwargs)\n</code></pre>"},{"location":"api-documentation/Main%20Methods/#chemcloud.configure_client","title":"configure_client","text":"<pre><code>configure_client(**kwargs) -&gt; None\n</code></pre> <p>Configure the default ChemCloud client.</p> <p>Passes keyword arguments to CCClient constructor. See CCClient for more information.</p> Usage <p>Pass any of the following keyword arguments before calling compute to configure the client.</p> <pre><code>from chemcloud import configure_client\n\nconfigure_client(\n    chemcloud_username=\"testuser\",  # Not recommended\n    chemcloud_password=\"testpassword\",  # Not recommended  # pragma: allowlist secret\n    chemcloud_domain=\"https://example.com\",\n    profile=\"testprofile\",\n    queue=\"myqueue\",\n    )\n</code></pre> Source code in <code>chemcloud/__init__.py</code> <pre><code>def configure_client(**kwargs) -&gt; None:\n    \"\"\"Configure the default ChemCloud client.\n\n    Passes keyword arguments to CCClient constructor.\n    See [CCClient][chemcloud.client.CCClient] for more information.\n\n    Usage:\n        Pass any of the following keyword arguments before calling\n        [compute][chemcloud.compute] to configure the client.\n\n        ```python\n        from chemcloud import configure_client\n\n        configure_client(\n            chemcloud_username=\"testuser\",  # Not recommended\n            chemcloud_password=\"testpassword\",  # Not recommended  # pragma: allowlist secret\n            chemcloud_domain=\"https://example.com\",\n            profile=\"testprofile\",\n            queue=\"myqueue\",\n            )\n        ```\n    \"\"\"\n    global _default_client\n    _default_client = CCClient(**kwargs)\n</code></pre>"},{"location":"api-documentation/Main%20Methods/#chemcloud.setup_profile","title":"setup_profile","text":"<pre><code>setup_profile(profile: Optional[str] = None) -&gt; None\n</code></pre> <p>Setup a profile for the ChemCloud client.</p> <p>See CCClient.setup_profile for more information.</p> Source code in <code>chemcloud/__init__.py</code> <pre><code>def setup_profile(profile: Optional[str] = None) -&gt; None:\n    \"\"\"Setup a profile for the ChemCloud client.\n\n    See [CCClient.setup_profile][chemcloud.client.CCClient.setup_profile] for more information.\n    \"\"\"\n    client = CCClient()\n    client.setup_profile(profile)\n</code></pre>"},{"location":"api-documentation/Main%20Methods/#chemcloud.fetch_output","title":"fetch_output","text":"<pre><code>fetch_output(*args, **kwargs)\n</code></pre> <p>Fetch the status and output of a compute job using the default client.</p> <p>Only needed if you want on manually check the status of a compute job. This function is usually not used by end users.</p> <p>See CCClient.fetch_output for more information.</p> Source code in <code>chemcloud/__init__.py</code> <pre><code>def fetch_output(*args, **kwargs):\n    \"\"\"Fetch the status and output of a compute job using the default client.\n\n    Only needed if you want on manually check the status of a compute job. This function\n    is usually not used by end users.\n\n    See [CCClient.fetch_output][chemcloud.client.CCClient.fetch_output] for more information.\n    \"\"\"\n    global _default_client\n    if _default_client is None:\n        _default_client = CCClient()\n    return _default_client.fetch_output(*args, **kwargs)\n</code></pre>"},{"location":"api-documentation/Main%20Methods/#chemcloud.hello_world","title":"hello_world","text":"<pre><code>hello_world(name: Optional[str] = None) -&gt; str\n</code></pre> <p>Return a greeting message from the ChemCloud server.</p> <p>See CCClient.hello_world for more information.</p> Source code in <code>chemcloud/__init__.py</code> <pre><code>def hello_world(name: Optional[str] = None) -&gt; str:\n    \"\"\"Return a greeting message from the ChemCloud server.\n\n    See [CCClient.hello_world][chemcloud.client.CCClient.hello_world] for more information.\n    \"\"\"\n    global _default_client\n    if _default_client is None:\n        _default_client = CCClient()\n    return _default_client.hello_world(name)\n</code></pre>"},{"location":"api-documentation/ProgramInputs/","title":"ProgramInputs","text":"<p>More extensive documentation is available at https://qcio.coltonhicks.com</p>"},{"location":"api-documentation/ProgramInputs/#qcio.models.inputs.ProgramInput","title":"qcio.models.inputs.ProgramInput","text":"<pre><code>ProgramInput(**data: Any)\n</code></pre> <p>Input for a single quantum chemistry program. This is the most common input type.</p> <p>Attributes:</p> Name Type Description <code>calctype</code> <code>CalcType</code> <p>The type of calculation to perform.</p> <code>model</code> <code>Model</code> <p>The model for the quantum chemistry calculation.</p> <code>keywords</code> <code>Dict[str, Any]</code> <p>A dict of keywords to be passed to the program excluding model and calctype. Defaults to an empty dict.</p> <code>structure</code> <code>Structure</code> <p>The structure to be used in the calculation.</p> <code>files</code> <code>Files</code> <p>Files to be passed to the QC program.</p> <code>extras</code> <code>Dict[str, Any]</code> <p>Additional information to bundle with the object. Use for schema development and scratch space.</p> Example <pre><code>from qcio.models import ProgramInput, Structure\n\nstruct = Structure.open(\"path/to/structure.xyz\")\n\nprog_inp = ProgramInput(\n    calctype = \"energy\",\n    structure = struct,\n    model = {\"method\": \"hf\", \"basis\": \"6-31G\"},\n    keywords = {\"maxsteps\": \"250\"},  # Optional\n    files = {\"file1\": b\"binary data\"}  # Optional\n)\n</code></pre> Source code in <code>qcio/models/inputs.py</code> <pre><code>def __init__(self, **data: Any):\n    \"\"\"Backwards compatibility for 'molecule' attribute.\"\"\"\n\n    # TODO: Remove in future versions.\n    if \"molecule\" in data:\n        warnings.warn(\n            \"Use of 'molecule' attribute is deprecated. Use 'structure' instead.\",\n            FutureWarning,\n            stacklevel=2,\n        )\n        data[\"structure\"] = data.pop(\"molecule\")\n    super().__init__(**data)\n</code></pre>"},{"location":"api-documentation/ProgramInputs/#qcio.models.inputs.DualProgramInput","title":"qcio.models.inputs.DualProgramInput","text":"<pre><code>DualProgramInput(**data: Any)\n</code></pre> <p>Input for a two program calculation.</p> <p>Attributes:</p> Name Type Description <code>calctype</code> <code>CalcType</code> <p>The type of calculation to perform.</p> <code>model</code> <code>Model</code> <p>The model for the quantum chemistry calculation.</p> <code>keywords</code> <code>Dict[str, Any]</code> <p>A dict of keywords to be passed to the program excluding model and calctype. Defaults to an empty dict.</p> <code>structure</code> <code>Structure</code> <p>The structure to be used in the calculation.</p> <code>files</code> <code>Files</code> <p>Files to be passed to the QC program.</p> <code>subprogram</code> <code>str</code> <p>The name of the subprogram to use.</p> <code>subprogram_args</code> <code>ProgramArgs</code> <p>The ProgramArgs for the subprogram.</p> <code>extras</code> <code>Dict[str, Any]</code> <p>Additional information to bundle with the object. Use for schema development and scratch space.</p> Example <pre><code>from qcio.models import DualProgramInput, Structure\n\nstruct = Structure.open(\"path/to/structure.xyz\")\n\nprog_inp = DualProgramInput(\n    calctype = \"optimization\",\n    structure = struct,\n    keywords = {\"maxiter\": \"250\"},  # Optional\n    subprogram = \"orca\",\n    subprogram_args = ProgramArgs(\n        model = {\"method\": \"wb97x-d3\", \"basis\": \"def2-SVP\"},\n        keywords = {\"convthre\": \"1e-6\"},  # Optional\n    )\n)\n</code></pre> Source code in <code>qcio/models/inputs.py</code> <pre><code>def __init__(self, **data: Any):\n    \"\"\"Backwards compatibility for 'molecule' attribute.\"\"\"\n\n    # TODO: Remove in future versions.\n    if \"molecule\" in data:\n        warnings.warn(\n            \"Use of 'molecule' attribute is deprecated. Use 'structure' instead.\",\n            FutureWarning,\n            stacklevel=2,\n        )\n        data[\"structure\"] = data.pop(\"molecule\")\n    super().__init__(**data)\n</code></pre>"},{"location":"api-documentation/ProgramInputs/#qcio.models.inputs.FileInput","title":"qcio.models.inputs.FileInput","text":"<p>File and command line argument inputs for a calculation.</p> <p>Attributes:</p> Name Type Description <code>files</code> <code>Files</code> <p>A dict mapping filename to str or bytes data.</p> <code>cmdline_args</code> <code>list[str]</code> <p>A list of command line arguments to be passed to the program.</p> <code>extras</code> <code>Dict[str, Any]</code> <p>Additional information to bundle with the object. Use for schema development and scratch space.</p>"},{"location":"api-documentation/ProgramInputs/#qcio.models.inputs.FileInput.from_directory","title":"from_directory  <code>classmethod</code>","text":"<pre><code>from_directory(\n    directory: Union[Path, str], **kwargs\n) -&gt; Self\n</code></pre> <p>Create a new FileInput and collect all files in the directory.</p> Source code in <code>qcio/models/inputs.py</code> <pre><code>@classmethod\ndef from_directory(cls, directory: Union[Path, str], **kwargs) -&gt; Self:\n    \"\"\"Create a new FileInput and collect all files in the directory.\"\"\"\n    obj = cls(**kwargs)\n    directory = Path(directory)\n    obj.add_files(directory)\n    return obj\n</code></pre>"},{"location":"api-documentation/ProgramOutput/","title":"ProgramOutput","text":"<p>More extensive documentation is available at https://qcio.coltonhicks.com.</p>"},{"location":"api-documentation/ProgramOutput/#qcio.models.outputs.ProgramOutput","title":"qcio.models.outputs.ProgramOutput","text":"<pre><code>ProgramOutput(**data: Any)\n</code></pre> <p>The core output object from a quantum chemistry calculation.</p> <p>Attributes:</p> Name Type Description <code>input_data</code> <code>InputType</code> <p>The input data for the calculation. Any of <code>qcio.Inputs</code>.</p> <code>success</code> <code>Literal[True, False]</code> <p>Whether the calculation was successful.</p> <code>results</code> <code>ResultsType</code> <p>The results of the calculation. Contains parsed values and files. Any of <code>qcio.Results</code>.</p> <code>stdout</code> <code>str | None</code> <p>The standard output from the calculation.</p> <code>traceback</code> <code>str | None</code> <p>The traceback from the calculation, if it failed.</p> <code>provenance</code> <code>Provenance</code> <p>The provenance information for the calculation.</p> <code>extras</code> <code>Dict[str, Any]</code> <p>Additional information to bundle with the object. Use for schema development and scratch space.</p> <code>pstdout</code> <code>str</code> <p><code>@property</code> Print the stdout text.</p> <code>ptraceback</code> <code>str</code> <p><code>@property</code> Print the traceback text.</p> Source code in <code>qcio/models/outputs.py</code> <pre><code>def __init__(self, **data: Any):\n    \"\"\"Backwards compatibility for files attribute.\"\"\"\n\n    if \"files\" in data:\n        warnings.warn(\n            \"The 'files' attribute has been moved to 'results.files'. Please \"\n            \"update your code accordingly.\",\n            category=FutureWarning,\n            stacklevel=2,\n        )\n\n        # This moves files from the top level to the results attribute\n        if isinstance(data[\"results\"], dict):\n            results_files_dict = data[\"results\"].get(\"files\", {})\n        else:  # data[\"results\"] is Files, SinglePointResults, OptimizationResults\n            results_files_dict = data[\"results\"].files\n\n        results_files_dict.update(**data.pop(\"files\"))\n\n    super().__init__(**data)\n</code></pre>"},{"location":"api-documentation/ProgramOutput/#qcio.models.outputs.ProgramOutput.pstdout","title":"pstdout  <code>property</code>","text":"<pre><code>pstdout: None\n</code></pre> <p>Print the stdout text</p>"},{"location":"api-documentation/ProgramOutput/#qcio.models.outputs.ProgramOutput.ptraceback","title":"ptraceback  <code>property</code>","text":"<pre><code>ptraceback: None\n</code></pre> <p>Print the traceback text</p>"},{"location":"api-documentation/ProgramOutput/#qcio.models.outputs.ProgramOutput.files","title":"files  <code>property</code>","text":"<pre><code>files: dict[str, str | bytes]\n</code></pre> <p>Return the files attribute.</p>"},{"location":"api-documentation/ProgramOutput/#qcio.models.outputs.ProgramOutput.return_result","title":"return_result  <code>property</code>","text":"<pre><code>return_result: (\n    float | SerializableNDArray | Structure | None\n)\n</code></pre> <p>Return the primary result of the calculation.</p>"},{"location":"api-documentation/ProgramOutput/#qcio.models.outputs.SinglePointResults","title":"qcio.models.outputs.SinglePointResults","text":"<p>The computed results from a single point calculation.</p> <p>Attributes:</p> Name Type Description <code>calcinfo_natoms</code> <code>int | None</code> <p>The number of atoms as computed by the program.</p> <code>calcinfo_nalpha</code> <code>int | None</code> <p>The number of alpha electrons as computed by the program.</p> <code>calcinfo_nbeta</code> <code>int | None</code> <p>The number of beta electrons as computed by the program.</p> <code>calcinfo_nbasis</code> <code>int | None</code> <p>The number of basis functions in the calculation.</p> <code>calcinfo_nmo</code> <code>int | None</code> <p>The number of molecular orbitals in the calculation.</p> <code>energy</code> <code>float | None</code> <p>The electronic energy of the structure in <code>Hartrees</code>.</p> <code>gradient</code> <code>SerializableNDArray | None</code> <p>The gradient of the structure in <code>Hartrees/Bohr</code>.</p> <code>hessian</code> <code>SerializableNDArray | None</code> <p>The hessian of the structure in <code>Hartrees/Bohr^2</code>.</p> <code>nuclear_repulsion_energy</code> <code>float | None</code> <p>The nuclear repulsion energy of the structure in Hartrees.</p> <code>wavefunction</code> <code>Wavefunction | None</code> <p>Wavefunction data from the calculation.</p> <code>freqs_wavenumber</code> <code>list[float]</code> <p>The frequencies of the structure in wavenumbers.</p> <code>normal_modes_cartesian</code> <code>SerializableNDArray | None</code> <p>3D n_vibmodes x n_atoms x 3 array containing un-mass-weighted Cartesian displacements of each normal mode in Bohr.</p> <code>gibbs_free_energy</code> <code>float | None</code> <p>Gibbs free energy (i.e. thermochemical analysis) in Hartrees of a system where translation / rotation / vibration degrees of freedom are approximated using ideal gas / rigid rotor / harmonic oscillator respectively.</p> <code>scf_dipole_moment</code> <code>list[float] | None</code> <p>The x, y, z component of the dipole moment of the structure in units of e a0 (NOT Debye!).</p>"},{"location":"api-documentation/ProgramOutput/#qcio.models.outputs.SinglePointResults.return_result","title":"return_result","text":"<pre><code>return_result(\n    calctype: CalcType,\n) -&gt; float | SerializableNDArray\n</code></pre> <p>Return the primary result of the calculation.</p> Source code in <code>qcio/models/outputs.py</code> <pre><code>def return_result(self, calctype: CalcType) -&gt; float | SerializableNDArray:\n    \"\"\"Return the primary result of the calculation.\"\"\"\n    return getattr(self, calctype.value)\n</code></pre>"},{"location":"api-documentation/ProgramOutput/#qcio.models.outputs.OptimizationResults","title":"qcio.models.outputs.OptimizationResults","text":"<p>Computed properties for an optimization.</p> <p>Attributes:</p> Name Type Description <code>energies</code> <code>ndarray</code> <p>The energies for each step of the optimization.</p> <code>structures</code> <code>list[Structure]</code> <p>The Structure objects for each step of the optimization.</p> <code>final_structure</code> <code>Structure</code> <p>The final, optimized Structure.</p> <code>trajectory</code> <code>list[ProgramOutput[ProgramInput, SinglePointResults] | ProgramOutput[ProgramInput, Files]]</code> <p>The SinglePointOutput objects for each step of the optimization.</p>"},{"location":"api-documentation/ProgramOutput/#qcio.models.outputs.OptimizationResults.final_structure","title":"final_structure  <code>property</code>","text":"<pre><code>final_structure: Structure\n</code></pre> <p>The final Structure in the optimization.</p>"},{"location":"api-documentation/ProgramOutput/#qcio.models.outputs.OptimizationResults.final_energy","title":"final_energy  <code>property</code>","text":"<pre><code>final_energy: float | None\n</code></pre> <p>The final energy in the optimization. Is <code>np.nan</code> if final calculation failed.</p>"},{"location":"api-documentation/ProgramOutput/#qcio.models.outputs.OptimizationResults.energies","title":"energies  <code>property</code>","text":"<pre><code>energies: ndarray\n</code></pre> <p>The energies for each step of the optimization.</p>"},{"location":"api-documentation/ProgramOutput/#qcio.models.outputs.OptimizationResults.structures","title":"structures  <code>property</code>","text":"<pre><code>structures: list[Structure]\n</code></pre> <p>The Structure objects for each step of the optimization.</p>"},{"location":"api-documentation/ProgramOutput/#qcio.models.outputs.OptimizationResults.molecules","title":"molecules  <code>property</code>","text":"<pre><code>molecules: list[Structure]\n</code></pre> <p>The Structure objects for each step of the optimization.</p>"},{"location":"api-documentation/ProgramOutput/#qcio.models.outputs.OptimizationResults.return_result","title":"return_result","text":"<pre><code>return_result(calctype: CalcType) -&gt; Structure | None\n</code></pre> <p>Return the primary result of the calculation.</p> Source code in <code>qcio/models/outputs.py</code> <pre><code>def return_result(self, calctype: CalcType) -&gt; Structure | None:\n    \"\"\"Return the primary result of the calculation.\"\"\"\n    return self.final_structure\n</code></pre>"},{"location":"api-documentation/ProgramOutput/#qcio.models.outputs.OptimizationResults.to_xyz","title":"to_xyz","text":"<pre><code>to_xyz() -&gt; str\n</code></pre> <p>Return the trajectory as an <code>xyz</code> string.</p> Source code in <code>qcio/models/outputs.py</code> <pre><code>def to_xyz(self) -&gt; str:\n    \"\"\"Return the trajectory as an `xyz` string.\"\"\"\n    return to_multi_xyz(\n        prog_output.input_data.structure for prog_output in self.trajectory\n    )\n</code></pre>"},{"location":"api-documentation/ProgramOutput/#qcio.models.outputs.OptimizationResults.save","title":"save","text":"<pre><code>save(\n    filepath: Path | str,\n    exclude_none: bool = True,\n    exclude_unset: bool = True,\n    indent: int = 4,\n    **kwargs: dict[str, Any],\n) -&gt; None\n</code></pre> <p>Save an OptimizationOutput to a file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Path | str</code> <p>The path to save the molecule to.</p> required <code>exclude_none</code> <code>bool</code> <p>If True, attributes with a value of None will not be written to the file.</p> <code>True</code> <code>exclude_unset</code> <code>bool</code> <p>If True, attributes that have not been set will not be written to the file.</p> <code>True</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional keyword arguments to pass to the json serializer.</p> <code>{}</code> Note <p>If the filepath has a <code>.xyz</code> extension, the trajectory will be saved to a multi-structure <code>xyz</code> file.</p> Source code in <code>qcio/models/outputs.py</code> <pre><code>def save(\n    self,\n    filepath: Path | str,\n    exclude_none: bool = True,\n    exclude_unset: bool = True,\n    indent: int = 4,\n    **kwargs: dict[str, Any],\n) -&gt; None:\n    \"\"\"Save an OptimizationOutput to a file.\n\n    Args:\n        filepath: The path to save the molecule to.\n        exclude_none: If True, attributes with a value of None will not be written\n            to the file.\n        exclude_unset: If True, attributes that have not been set will not be\n            written to the file.\n        **kwargs: Additional keyword arguments to pass to the json serializer.\n\n    Note:\n        If the filepath has a `.xyz` extension, the trajectory will be saved to a\n        multi-structure `xyz` file.\n    \"\"\"\n    filepath = Path(filepath)\n    if filepath.suffix == \".xyz\":\n        filepath.write_text(self.to_xyz())\n        return\n    super().save(filepath, exclude_none, exclude_unset, indent, **kwargs)\n</code></pre>"},{"location":"api-documentation/ProgramOutput/#qcio.models.outputs.ConformerSearchResults","title":"qcio.models.outputs.ConformerSearchResults","text":"<p>Results from a conformer search calculation.</p> <p>Conformers and rotamers are sorted by energy.</p> <p>Attributes:</p> Name Type Description <code>conformers</code> <code>list[Structure]</code> <p>The conformers found in the search.</p> <code>conformer_energies</code> <code>SerializableNDArray</code> <p>The energies for each conformer.</p> <code>rotamers</code> <code>list[Structure]</code> <p>The rotamers found in the search.</p> <code>rotamer_energies</code> <code>SerializableNDArray</code> <p>The energies for each rotamer.</p>"},{"location":"api-documentation/ProgramOutput/#qcio.models.outputs.ConformerSearchResults.conformer_energies_relative","title":"conformer_energies_relative  <code>property</code>","text":"<pre><code>conformer_energies_relative: ndarray\n</code></pre> <p>The relative energies for each conformer in the search.</p>"},{"location":"api-documentation/ProgramOutput/#qcio.models.outputs.ConformerSearchResults.rotamer_energies_relative","title":"rotamer_energies_relative  <code>property</code>","text":"<pre><code>rotamer_energies_relative: ndarray\n</code></pre> <p>The relative energies for each rotamer in the search.</p>"},{"location":"api-documentation/ProgramOutput/#qcio.models.outputs.ConformerSearchResults.conformers_filtered","title":"conformers_filtered","text":"<pre><code>conformers_filtered(\n    threshold: float = 0.5, **rmsd_kwargs\n) -&gt; tuple[list[Structure], SerializableNDArray]\n</code></pre> <p>Filter conformers to only unique Structures within rmsd of <code>threshold</code>.</p> <p>Parameters:</p> Name Type Description Default <code>threshold</code> <code>float</code> <p>The RMSD threshold in Angstrom for filtering conformers.</p> <code>0.5</code> <code>**rmsd_kwargs</code> <p>Additional keyword arguments to pass to the rmsd function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple[list[Structure], SerializableNDArray]</code> <p>Tuple of the filtered conformers and their relative energies.</p> Source code in <code>qcio/models/outputs.py</code> <pre><code>def conformers_filtered(\n    self, threshold: float = 0.5, **rmsd_kwargs\n) -&gt; tuple[list[Structure], SerializableNDArray]:\n    \"\"\"Filter conformers to only unique Structures within rmsd of `threshold`.\n\n    Args:\n        threshold: The RMSD threshold in Angstrom for filtering conformers.\n        **rmsd_kwargs: Additional keyword arguments to pass to the rmsd function.\n\n    Returns:\n        Tuple of the filtered conformers and their relative energies.\n    \"\"\"\n    filtered = set()\n\n    for i in range(len(self.conformers)):\n        if i not in filtered:\n            for j in range(i + 1, len(self.conformers)):\n                if (\n                    rmsd(self.conformers[i], self.conformers[j], **rmsd_kwargs)\n                    &lt; threshold\n                ):\n                    filtered.add(j)\n\n    keep_indices = [i for i in range(len(self.conformers)) if i not in filtered]\n    return [\n        self.conformers[i] for i in keep_indices\n    ], self.conformer_energies_relative[keep_indices]\n</code></pre>"},{"location":"api-documentation/exceptions/","title":"Exceptions","text":""},{"location":"api-documentation/exceptions/#chemcloud.exceptions","title":"chemcloud.exceptions","text":""},{"location":"api-documentation/exceptions/#chemcloud.exceptions.BaseError","title":"BaseError","text":"<p>Exception Base for client.</p>"},{"location":"api-documentation/exceptions/#chemcloud.exceptions.TimeoutError","title":"TimeoutError","text":"<p>A timeout parameter was exceeded</p>"},{"location":"api-documentation/exceptions/#chemcloud.exceptions.UnsupportedProgramError","title":"UnsupportedProgramError","text":"<p>A program is not supported by ChemCloud</p>"},{"location":"api-documentation/exceptions/#chemcloud.exceptions.AuthenticationError","title":"AuthenticationError","text":"<p>An error occurred during authentication.</p>"},{"location":"tutorial/authentication/","title":"Authentication","text":"<p>Authentication is the process of supplying your credentials (usually a username and password) to <code>chemcloud</code> so that you can perform computations. <code>chemcloud</code> provides a few easy ways for you to authenticate. If you do not have a ChemCloud account you can get one for free here or at the address of the ChemCloud server you want to interact with: https://chemcloud.mtzlab.com/signup</p>"},{"location":"tutorial/authentication/#setup_profile-recommended-for-most-cases","title":"<code>setup_profile()</code> (recommended for most cases)","text":"<pre><code>from chemcloud import setup_profile\nsetup_profile() # This will setup the default profile\n\u2705 If you dont get have an account please signup at: https://chemcloud.mtzlab.com/signup\nPlease enter your ChemCloud username: your_username@email.com\nPlease enter your ChemCloud password:\nAuthenticating...\n'default' profile configured! Username/password not required for future use.\n</code></pre> <p>Performing this action will configure your local client by writing authentication tokens to <code>~/.chemcloud/credentials</code>. You will not need to run <code>setup_profile()</code> ever again. Under the hood <code>chemcloud</code> will access your tokens, refresh them when necessary, and keep you logged in to ChemCloud. Note that this will write a file to your home directory with sensitive access tokens, so if you are on a shared computer or using a device where you would not want to write this information to disk do not use this option. If you would like to write the <code>credentials</code> file to a different directory than <code>~/.chemcloud</code>, set the <code>CHEMCLOUD_BASE_DIRECTORY</code> environment variable to the path of interest.</p> <p>You can configure multiple profiles in case you have multiple logins to ChemCloud by passing a profile name to <code>setup_profile()</code>:</p> <pre><code>setup_profile('mtz_lab')\n\u2705 If you dont get have an account please signup at: https://chemcloud.mtzlab.com/signup\nPlease enter your ChemCloud username: your_username@email.om\nPlease enter your ChemCloud password:\nAuthenticating...\n'mtz_lab' profile configured! Username/password not required for future use.\n</code></pre> <p>To use a profile other than the default profile, do one of the following:</p> <ol> <li>Set the <code>chemcloud_credentials_profile</code> environment variable in your shell or in python.    <pre><code>export chemcloud_credentials_profile=\"mtz_lab\"\n</code></pre></li> <li>Run <code>configure_client</code> before running `compute() and pass the profile.    <pre><code>from chemcloud import configure_client\nconfigure_client(profile=\"mtz_lab\")\n</code></pre></li> <li>Pass the profile option to a client instance and use the <code>client.compute()</code> method on it.</li> </ol> <pre><code>from chemcloud import CCClient\n# Use default profile\nclient = CCClient()\n\n# Use named profile\nclient = CCClient(profile=\"mtz_lab\")\nclient.compute(...)\n</code></pre>"},{"location":"tutorial/authentication/#environment-variables","title":"Environment Variables","text":"<p>All variables on the <code>config.Settings</code> object can be set via environment variables and chemcloud will pick them up and use them automatically.</p> <p>Most commonly, users may want to modify one or many of the following:</p> <pre><code>export CHEMCLOUD_DOMAIN=https://mycustomchemcloud.com\nexport CHEMCLOUD_QUEUE=myqueue\nexport CHEMCLOUD_CREDENTIALS_PROFILE=non-default-profile-name\n</code></pre> <p>If you are operating in an environment where tokens should not be persistently saved to disk you may want to set the following. <code>chemcloud</code> will find these values and maintain all access tokens in memory only.</p> <pre><code>export CHEMCLOUD_USERNAME=myusername@chemcloud.com\nexport CHEMCLOUD_PASSWORD=mysupersecretpassword  # pragma: allowlist secret\n</code></pre>"},{"location":"tutorial/authentication/#usernamepassword-when-prompted-after-calling-clientcompute","title":"Username/Password when prompted after calling <code>client.compute(...)</code>","text":"<p>If you have not run <code>setup_profile()</code> or set environment variables you will be requested for your username and password when you submit a computation to ChemCloud using <code>compute(...)</code>. The client will use your username and password to get access tokens and ask if you'd like to save the tokens to disk for future sessions.</p>"},{"location":"tutorial/authentication/#pass-usernamepassword-to-client-not-recommended","title":"Pass Username/Password to Client (not recommended)","text":"<p>You can directly pass a username and password to the <code>client</code> object. This is not recommended as it opens up the possibility of your credentials accidentally being committed to your code repo. However, it can be used in rare circumstances when necessary.</p> <pre><code>from chemcloud import configure_client\nconfigure_client = (\n    chemcloud_username=\"your_username@email.com\", chemcloud_password=\"super_secret_password\"  # pragma: allowlist secret\n    )\n</code></pre>"},{"location":"tutorial/batch-computations/","title":"Batch Computations","text":"<p>Calculations can be submitted in bulk by passing a list of <code>Input</code> objects to <code>compute()</code> rather than a single object.</p> <pre><code>from qcio import ProgramInput, Structure\n\nfrom chemcloud import compute\n\nwater = Structure(\n    symbols=[\"O\", \"H\", \"H\"],\n    geometry=[\n        [0.0000, 0.00000, 0.0000],\n        [0.2774, 0.89290, 0.2544],\n        [0.6067, -0.23830, -0.7169],\n    ],\n)\n\nprog_inp = ProgramInput(\n    structure=water,\n    model={\"method\": \"b3lyp\", \"basis\": \"6-31g\"},\n    calctype=\"energy\",\n    keywords={},\n)\noutput = compute(\"terachem\", [prog_inp] * 2)\nprint(output)  # list of ProgramOutput objects\n</code></pre>"},{"location":"tutorial/bigchem-algorithms/","title":"BigChem Algorithms","text":"<p>BigChem implements some of its own concurrent algorithms that leverage its horizontally scalable backend infrastructure. These include a parallel hessian algorithm and parallel frequency analysis algorithm. To use them submit a <code>hessian</code> calculation to ChemCloud using <code>bigchem</code> as the engine. See examples the <code>parallel_hessian.py</code> and <code>parallel_frequency_analysis.py</code> scripts in the examples directory.</p>"},{"location":"tutorial/bigchem-algorithms/#parallel-hessian-frequency-analysis","title":"Parallel Hessian &amp; Frequency Analysis","text":"<pre><code>from qcio import DualProgramInput, Structure\n\nfrom chemcloud import compute\n\nwater = Structure(\n    symbols=[\"O\", \"H\", \"H\"],\n    geometry=[\n        [0.0000, 0.00000, 0.0000],\n        [0.2774, 0.89290, 0.2544],\n        [0.6067, -0.23830, -0.7169],\n    ],\n)\n\n\nprog_inp = DualProgramInput(\n    calctype=\"hessian\",\n    structure=water,\n    subprogram=\"psi4\",\n    subprogram_args={\"model\": {\"method\": \"b3lyp\", \"basis\": \"6-31g\"}},\n)\n\n\n# Submit calculation\noutput = compute(\"bigchem\", prog_inp)\n\n# ProgramOutput object containing all returned data\nprint(output)\nprint(output.results.hessian)\n# Frequency data always included too\nprint(f\"Wavenumbers: {output.results.freqs_wavenumber}\")\nprint(output.results.normal_modes_cartesian)\nprint(output.results.gibbs_free_energy)\n</code></pre> <p>Keywords for the BigChem algorithms:</p> Keyword Type Description Default Value <code>dh</code> <code>float</code> Displacement for gradient geometries for finite difference <code>5.0e-3</code> <code>temperature</code> <code>float</code> Temperature passed to the harmonic free energy module <code>300.0</code> <code>pressure</code> <code>float</code> Pressure passed to the harmonic free energy module <code>1.0</code>"},{"location":"tutorial/compute/","title":"Compute","text":"<p>Computations are physically executed by a BigChem instance fronted by a ChemCloud server. The chemcloud python client submits jobs to and retrieves work from the ChemCloud server. Computations are submitted using the CCClient object.</p> <p>Computations require a QC program and <code>ProgramInput</code> or <code>DualProgramInput</code> object. The <code>ProgramInput</code> object contains all the information necessary to run a single calculation. The <code>DualProgramInput</code> object is used when two QC programs are used in tandem, such as when performing a geometry optimization with one program that uses a subprogram for the energy and gradient calculations.</p>"},{"location":"tutorial/compute/#basic-single-point-calculation","title":"Basic Single Point Calculation","text":"<pre><code>from qcio import ProgramInput, Structure\n\nfrom chemcloud import compute\n\nwater = Structure(\n    symbols=[\"O\", \"H\", \"H\"],\n    geometry=[\n        [0.0000, 0.00000, 0.0000],\n        [0.2774, 0.89290, 0.2544],\n        [0.6067, -0.23830, -0.7169],\n    ],\n)\n\n\nprog_inp = ProgramInput(\n    calctype=\"energy\",  # Or \"gradient\" or \"hessian\"\n    structure=water,\n    model={\"method\": \"b3lyp\", \"basis\": \"6-31g\"},\n    keywords={},\n)\noutput = compute(\"terachem\", prog_inp)\n# ProgramOutput object containing all returned data\nprint(output.stdout)\nprint(output)\n\nif output.success:\n    print(output.results.energy)\n    # Not empty if collect_files=True passed to compute\n    print(output.results.files.keys())\nelse:\n    print(output.traceback)\n</code></pre>"},{"location":"tutorial/compute/#including-files-in-the-input","title":"Including Files in the Input","text":"<p>Add the filename as the key and the <code>str</code> or <code>bytes</code> data to the <code>files</code> attribute:</p> <pre><code>prog_inp = ProgramInput(\n    structure=water,\n    model={\"method\": \"b3lyp\", \"basis\": \"6-31g\"},\n    calctype=\"energy\",\n    keywords={\"guess\": \"c0\"},\n    files={\n        \"c0\": b'\\xdf4R\\xdea\\xd7\\xef?\\xc1-\\xbdg2\\xd0\\xca?\\x8e\\xc4\\x94\\x02\\xe5\\xcd\\xae\\xbe\\xd9kP\\xd8R2\\xb7\\xbfhV\\xc1\\x136\\xe5\\xbe\\xbe\\xad\\x0b#2\\xabp\\xb6?\\xe9\\x91\\x99\\xbf\\xd7\\xe9e&gt;LQ\\x05\\xa4F\\xaa\\xa6&gt;&gt;k\\xab\\xa4\\xd4j\\xa1\\xbf\\xd1#\\xbf\\x14\\t\\xdf\\xd8&gt;\\x99Qq\\x1b\\x07\\x0b\\xb4?$*\\x0ed\\x95\\x91\\x97\\xbe\\r\\xc8\\xfb\\xca\\xbb\\x82\\xab?\\'d\\x0c-Y\\x8e\\x9c?\\x8c\\x10\\xf1\\xd9I\\xb5\\xdd\\xbf\\xf7\\xea%X\\xd0\\x02\\xbf&gt;==urA\\xc8\\xc9?\\xe0f\\xbb#^\\t\\xc8&gt;\\xe3\\xfb\\x8b\\xc2C\\x94\\xc3\\xbf\\xd0]m\\x85\\xd1\\xd7\\xb5&gt;\\xa2\\x1c\\x03Un0\\xd6\\xbe\\xc1\\x90\\xb8\\xec\\n\"\\xc9??\\xd3\\x90\\x80q\\xeb\\x06\\xbf,\\xa9\\x0f\\xc0\\x8dZ\\xdf\\xbf% \\xcc\\x86L\\x85\\xc2\\xbe\\xdf\\xae\\xb07\\xe4\\x91\\xfa\\xbf\\xa9\\x97q\\x07\\xff\\xd0\\x8a\\xbf\\x04\\xad\\xabq\\xc8\\xed\\xdc\\xbf\\xb3]B\\x0c\\xcc\\xa4\\xca&gt;\\x00\\xaaX\\xed\\xd7\\xe9\\xd7?\\xa5\\xbf\\xc0\\x05O\\xb2\\xe1&gt;&gt;c\\x1f\\xef\\x924\\xf1\\xbf\\xf9\\xac0\\xe1r-\\xcf\\xbe\\xe3]\\x92[g\\x18\\xe4&gt;Zm8\\x07@\\xbd\\xd2\\xbf\\xae\\x86\\xa3\\x19Hl\\x0b?e\\xb2\\x81\\xdd\\xdbz\\xc0?\\xc04\\xaea,1\\xe0&gt;t&amp;x\\xceH\\xf5\\x05@\\xc7\\'\\xb0\\xb9\\xd1g#?\\x82Hm\\x14\\xba\\x14\\xc3\\xbfT\\x19p\\xa8T\\x00\\xd1?\\xc5 \\xfc\\xae\\xabf\\xc2\\xbfm2\\xf0t\\xde\\x84\\xd0\\xbe#(\\x16bTh\\xb9?\\xd7i&amp;\\x01\\xc8\\xb7\\xb9?\\x02\\xdc\\xe5m\\xea\\n\\xef\\xbf\\xf6\\xfb\\x86\\n\\x97O\\xe7\\xbfX\\xe7\\xdfb\\x00\\xb8\\x1d?\\x19!\\x83a\\xb5\\xeb\\xe4?\\xa5\\x0b\\xf5&gt;wJ\\x9e?\\xcf\\xdb\\x884z\\xee\\xde\\xbf\\xea\\xbf\\xa7\\xd3@\\xd7h?F5\\x9b\\x1f\\x93\"@\\xbf/\\x8d\\x1e.\\x84o\\xc3?\\x08!\\xa9\\\\\\xc5d\\xbb\\xbf=\\x18s\\x1a\\xf6\\xa3\\xd2\\xben\\xf7\\x8e\\xb5B\\xbe\\xed?\\x96\\xd0:\\xeb\\xbdI\\xf4?\\xa1b\\x81\\x15QU\\xe6?7\\xf1\\xb6\\xac\\xd4i\\xe3?\\xc2\\xf35\\x18\\xc7\\x90\\x10\\xbf\\xc4 \\xf3\\xe5\\x93\\x94\\xc6\\xbfE\\x96\\xe1\\xa1\\xb2\\xe6\\xec?b\\xf4\\xd8K\\x1a|\\xe3\\xbf\\xabKE\\x9a+g#?I&gt;t\\xa1\\xc7\\x14\\xc3\\xbfM\\xd7\\x13\\xb7V\\x00\\xd1\\xbf\\xc4\\x1e\\xf1\\x02\\xa1f\\xc2\\xbf\\x16\\x8d\\x03l\\xd3\\x8e\\xa6\\xbe\\xdd$uFwh\\xb9?\\xcap6\\x18\\xfd\\xb7\\xb9\\xbf|\\xff&amp;\\xa8/\\x0b\\xef?\\x8c+\\x9eG0O\\xe7\\xbf\\xf6\\xfd$\\x1eY\\xdc\\x15?4L\\x99\\xf7\\xbd\\xeb\\xe4?\\xdd=\\xbaD\\xdbM\\x9e\\xbff\\x04*Q\\x81\\xee\\xde\\xbfZ\\x12\\x87\\x8eF\\xd7h?\\n6\\xbd1\\x84&amp;@\\xbf \\xbd#\\x84\\x88o\\xc3\\xbf\\xf2\\x9bj\\x08\\x9dd\\xbb\\xbf\\xcc\\x90aR\\xded\\xb8&gt;\\x18\\xcd\\t\\xf5H\\xbe\\xed?\\xdaw\\x8a\\xa3\\xb6I\\xf4\\xbf\\t\\xe3\\xf8\\xf0\\x92U\\xe6\\xbf\\x83\\xe8\\x9d\\x93\\xadi\\xe3?p\\x0bF\\xfe\\x9a\\x11\\x18\\xbf\\xd9A\\xc7g\\xc4\\x94\\xc6\\xbf\\x8e\\xdd\\xeb\\xa4\\xb0\\xe6\\xec\\xbfJ\\xb6@\\xbb\\x15|\\xe3\\xbf\\x08\\xe1\\xfa\\xa9\\xc0\\xb1Z?\\xf2\\x88\\x88!\\xff\\xaa\\xbc\\xbf[.\\xb8e\\xa8x\\xbc\\xbf\\x07\\x90nr\\xb8\\xc3\\xd9\\xbf4\\x99\\xf9\\x99\\x80Q\\xda\\xbf\\x05\\xd8$t\\x9e\\xfc\\xcb\\xbf\\xf5\\xfe|\\xa6gH\\xb7?\\xbf\\x0e\\xb8L@V\\xa6\\xbf\\xc8\\xa2\\x05\\x84\\xba\\x05\\xe2?\\xa2I\\xa0\\x1f\\x9f\\x80\\xe3\\xbfGv\\xefeG\\\\\\xdc?\\xeb\\x18\\xd63\\xc1\\x19\\xcb\\xbfW\"\\xb9\\x87P\\x92\\xc1\\xbf\\x05\\x13\\xa3IY\\xc3S?\\xa8\\xa2\\x18?\\x0e9\\xb5\\xbf \\xd9\\xcbJNq\\xd8?x\\xa8\\xa4/6\\x13\\xd3\\xbf\\xbdLJA\\xcc\\n\\xd0?\\xb6i\\xb5\\x01\\x1b\\xb8\\xc4\\xbf\\xa7eF\\xef.\\xfd\\xd3\\xbf\\rf\\x06.Z*\\xc3?\\x0b\\xaf\\xbb\\xe4\\xe1\\xb0\\xda?u\\x91\\xb0I\\x9d\\xc5\\xd7?^\\x9c\\xffh\\xa3\\xfe\\xd4?\\xdf\\x0ec\\xf3\\xc0D\\xe7?`\\xd6\\xfb\\xfd\\xf3\\x04\\xba\\xbf\\x8c\\xf1\\xcd\\x98\\x93\\xedK\\xbfv\"!\\xed\\x91\\xfd\\xad?ey\\xdd\\x08\\xc5\\xfc\\xd4?r\\xb7&gt;\\\\\\x83\\xf4\\xca?\\x84M\\xaf\\x8f\\xbb\\x9b\\xdb\\xbfk\\xa36\\xd6UG\\xbd?\\xd9\\xfd\\x0f\\x18\\xdb)\\xd1\\xbf\\xfb`\\x8e\\xf0\\xf0t\\xc0?9\\x1f\\x0b\\xb9h\\xdc\\xd2\\xbf\\xadk\\t_\\xa5t\\xe4\\xbf\\xc1dH\\r`\\xaa\\xcd\\xbf\\xb8\\xbe\\xa9n\\xea\\xfa\\xe3?\\xaa\\x927\\x94 b\\xb2?\\'\\x84E8\\x0e\\x84`\\xbf\\xcf\\xc9\\xaa$\\xae\\xaf\\xaa\\xbf\\xefb}_82\\xaa\\xbf\\xd4\\xfeS\\xc3N\\xc0\\xd1\\xbf\\xdf\\xd5k\\x1b\\x08\\x8b\\xd4\\xbf\\xcf\\x02\\xa6\\xe9\\xaa=\\xd5\\xbfLI\\xad\\x02m\\xb6\\xc4?\\xe9=\\x13\\xecr\\xe2\\xba\\xbf\\xd4\\xf5\\x91\\xd75\\xfb\\xd5\\xbfa\\xaa\\xb0\\x86S*\\xe5?#\\x92\\xd8\\x85\\x1f\\x8d\\xea\\xbf\\x04\\x8e\\xfa\\xde\\xe4\\xf1\\xd6?\\xdd\\xf3\\xc8[.\\xc9\\xe4?\\xae\\xef\\x9f\\x01{tX\\xbf\\xfdG\\xb1\\xd6\\xa1\\xc1\\xa3\\xbfe\\xa4\\xa5\\xacy}\\xc6?/\\xe3&gt;s\\xcfH\\xca\\xbf\\xb4\\xe7\\xd4\\xf9\\x0e\\x0b\\xc9?\\xe0\\xf7\\xf8B]s\\xcf\\xbf/$\\x91\\x9dh\\xc8\\xe1\\xbfk\\xa6\\x86\\xed\\xfd\\x15\\xd7?\\x9fo\\xed~OG\\xd0\\xbft9\\xe6\\xcd\\xa9\\xcd\\xd9\\xbfa\\xa6&gt;\"\\xeb\\xa7\\xe3\\xbfj?\\xea\\xd6\\x11\\xb3\\xf3\\xbf\\xf2=JS\\xf6\\xc6\\xde?9BT]PGQ?\\xe9\\x80\\xd0\\x08\\xfe\\xea\\x9b?\\xf5G\\xb1\\x83\\xa0O\\xc3?\\xef\\x96y[9\\x92\\xc2?\\xc7\\xb6\\xd7\\x87\\xce\\x8c\\xd5\\xbf\\xd1Q\\x02l\\x958\\xc6?C\\xd8\\x13\\x1c\\xdb\\x89\\xde\\xbf2\\x02y\\'\\xa4\\xd2\\xd3?^\\xef\\x1f\\xd70\\x03\\xc7?\\xacm2\\x05s3\\xe6?\\xc0\\xde\\x00pP\\xc6\\xdb?\\x0fx\\x8c\\xdfP\\xea\\xf0\\xbf\\xa7\\xd4\\x80E\\xc9\\xbe\\xd5\\xbf'  # noqa: E501\n    },\n)\n</code></pre> <p>Files can also be added to an input objects using the <code>add_file</code> method.</p> <pre><code>prog_input.add_file(\"some_file.dat\")\n</code></pre>"},{"location":"tutorial/geometry-optimization/","title":"Geometry optimization","text":""},{"location":"tutorial/geometry-optimization/#basic-working-example","title":"Basic Working Example","text":"<pre><code>from qcio import DualProgramInput, Structure\n\nfrom chemcloud import compute\n\nwater = Structure(\n    symbols=[\"O\", \"H\", \"H\"],\n    geometry=[\n        [-0.11904094, -0.36695321, -0.21996706],\n        [1.24615604, -0.14134141, 0.99915579],\n        [-0.24300973, 1.16287522, -1.24168873],\n    ],\n)\n\n\nprog_inp = DualProgramInput(\n    calctype=\"optimization\",\n    structure=water,\n    keywords={\"maxiter\": 25},\n    subprogram=\"psi4\",\n    subprogram_args={\"model\": {\"method\": \"b3lyp\", \"basis\": \"6-31g\"}},\n)\n\n\n# Submit calculation\noutput = compute(\"geometric\", prog_inp)\n\nif output.success:\n    print(\"Optimization succeeded!\")\n    # Will be OptimizationResult object\n    print(output)\n    # The final structure of the geometry optimization\n    print(output.results.final_structure)\n    # Initial structure\n    print(output.inputs.structure)\n    # A list of ordered AtomicResult objects for each step in the optimization\n    print(output.results.trajectory)\n    # A list of ordered energies for each step in the optimization\n    print(output.results.energies)\nelse:\n    print(\"Optimization failed!\")\n    # Will be FailedOperation object\n    print(output)\n    # Error information\n    print(output.traceback)\n</code></pre>"},{"location":"tutorial/geometry-optimization/#using-force-fields","title":"Using Force Fields","text":"<p><code>rdkit</code> can be specified as a compute backend to perform optimizations using force field methods instead of quantum chemistry backends. To use <code>rdkit</code> force field methods simply modify the model specification and <code>subprogram</code> specification as shown below. Also note that <code>rdkit</code> requires the molecular connectivity to be defined.</p> <pre><code>water = Structure(\n    symbols=[\"O\", \"H\", \"H\"],\n    geometry=[\n        [0.0000, 0.00000, 0.0000],\n        [0.2774, 0.89290, 0.2544],\n        [0.6067, -0.23830, -0.7169],\n    ],\n    # Add bond connectivity to water (from_atom, to_atom, bond_order)\n    connectivity=[(0, 1, 1.0), (0, 2, 1.0)],\n)\n\nopt_input = DualProgramInput(\n    ...\n    subprogram=\"rdkit\",\n    subprogram_args={\"model\": {\"method\": \"UFF\"}} # or any other force field\n)\n\noutput = client.compute(\"geometric\", opt_input)\n</code></pre>"},{"location":"tutorial/geometry-optimization/#berny-specifics","title":"Berny Specifics","text":"<p>The <code>berny</code> procedure uses the pyberny package to perform a geometry optimization. <code>berny</code> specific keywords are subject to change as the <code>berny</code> package evolves, but for simplicity a short list is included here with default values noted:</p> Keyword Description Default Value <code>maxsteps</code> Maximum number of steps in the optimization <code>100</code> <code>gradientmax</code> Convergence criteria (AU) <code>0.45e-3</code> <code>gradientrms</code> Convergence criteria (AU) <code>0.15e-3</code> <code>stepmax</code> Step in internal coordinates, assuming radian units for angles (AU) <code>1.8e-3</code> <code>steprms</code> Step in internal coordinates, assuming radian units for angles (AU) <code>0.45e-3</code> <code>trust</code> Initial trust radius in AU. It is the maximum RMS of the quadratic step <code>0.3</code> <code>dihedral</code> Form dihedral angles <code>True</code> <code>superweakdih</code> Form dihedral angles containing two or more noncovalent bonds <code>False</code>"},{"location":"tutorial/geometry-optimization/#geometric-specifics","title":"geomeTRIC Specifics","text":"<p>The <code>geometric</code> procedure uses the geomeTRIC package to perform a geometry optimization. <code>geomeTRIC</code> specific keywords are subject to change as the <code>geomeTRIC</code> package evolves. Since <code>geomeTRIC</code> has considerably more keywords, here's the source code that defines various parameters for an optimization. Keywords noted below can be included in the <code>OptimizationInput</code> keywords dictionary. If these options are overwhelming, keep in mind you can run both the <code>berny</code> and <code>geometric</code> optimizers without any keywords and the optimizers will use sensible defaults.</p> <pre><code>class OptParams(object):\n    \"\"\"\n    Container for optimization parameters.\n    The parameters used to be contained in the command-line \"args\",\n    but this was dropped in order to call Optimize() from another script.\n    \"\"\"\n    def __init__(self, **kwargs):\n        # Whether we are optimizing for a transition state. This changes a number of default parameters.\n        self.transition = kwargs.get('transition', False)\n        # CI optimizations sometimes require tiny steps\n        self.meci = kwargs.get('meci', False)\n        # Handle convergence criteria; this edits the kwargs\n        self.convergence_criteria(**kwargs)\n        # Threshold (in a.u. / rad) for activating alternative algorithm that enforces precise constraint satisfaction\n        self.enforce = kwargs.get('enforce', 0.0)\n        # Small eigenvalue threshold\n        self.epsilon = kwargs.get('epsilon', 1e-5)\n        # Interval for checking the coordinate system for changes\n        self.check = kwargs.get('check', 0)\n        # More verbose printout\n        self.verbose = kwargs.get('verbose', False)\n        # Starting value of the trust radius\n        # Because TS optimization is experimental, use conservative trust radii\n        self.trust = kwargs.get('trust', 0.01 if self.transition else 0.1)\n        # Maximum value of trust radius\n        self.tmax = kwargs.get('tmax', 0.03 if self.transition else 0.3)\n        # Minimum value of the trust radius\n        self.tmin = kwargs.get('tmin', 0.0 if (self.transition or self.meci) else min(1.2e-3, self.Convergence_drms))\n        # Minimum size of a step that can be rejected\n        self.thre_rj = kwargs.get('thre_rj', 1e-4 if (self.transition or self.meci) else 1e-2)\n        # Sanity checks on trust radius\n        if self.tmax &lt; self.tmin:\n            raise ParamError(\"Max trust radius must be larger than min\")\n        # The trust radius should not be outside (tmin, tmax)\n        self.trust = min(self.tmax, self.trust)\n        self.trust = max(self.tmin, self.trust)\n        # Maximum number of optimization cycles\n        self.maxiter = kwargs.get('maxiter', 300)\n        # Use updated constraint algorithm implemented 2019-03-20\n        self.conmethod = kwargs.get('conmethod', 0)\n        # Write Hessian matrix at optimized structure to text file\n        self.write_cart_hess = kwargs.get('write_cart_hess', None)\n        # Output .xyz file name may be set separately in\n        # run_optimizer() prior to calling Optimize().\n        self.xyzout = kwargs.get('xyzout', None)\n        # Name of the qdata.txt file to be written.\n        # The CLI is designed so the user passes true/false instead of the file name.\n        self.qdata = 'qdata.txt' if kwargs.get('qdata', False) else None\n        # Whether to calculate or read a Hessian matrix.\n        self.hessian = kwargs.get('hessian', None)\n        if self.hessian is None:\n            # Default is to calculate Hessian in the first step if searching for a transition state.\n            # Otherwise the default is to never calculate the Hessian.\n            if self.transition: self.hessian = 'first'\n            else: self.hessian = 'never'\n        if self.hessian.startswith('file:'):\n            if os.path.exists(self.hessian[5:]):\n                # If a path is provided for reading a Hessian file, read it now.\n                self.hess_data = np.loadtxt(self.hessian[5:])\n            else:\n                raise IOError(\"No Hessian data file found at %s\" % self.hessian)\n        elif self.hessian.lower() in ['never', 'first', 'each', 'stop', 'last', 'first+last']:\n            self.hessian = self.hessian.lower()\n        else:\n            raise RuntimeError(\"Hessian command line argument can only be never, first, last, first+last, each, stop, or file:&lt;path&gt;\")\n        # Perform a frequency analysis whenever a cartesian Hessian is computed\n        self.frequency = kwargs.get('frequency', None)\n        if self.frequency is None: self.frequency = True\n        # Temperature and pressure for harmonic free energy\n        self.temperature, self.pressure = kwargs.get('thermo', [300.0, 1.0])\n        # Number of desired samples from Wigner distribution\n        self.wigner = kwargs.get('wigner', 0)\n        if self.wigner and not self.frequency:\n            raise ParamError('Wigner sampling requires frequency analysis')\n        # Reset Hessian to guess whenever eigenvalues drop below epsilon\n        self.reset = kwargs.get('reset', None)\n        if self.reset is None: self.reset = not (self.transition or self.meci or self.hessian == 'each')\n</code></pre> <p>And convergence criteria:</p> <pre><code>def convergence_criteria(self, **kwargs):\n        criteria = kwargs.get('converge', [])\n        if len(criteria)%2 != 0:\n            raise RuntimeError('Please pass an even number of options to --converge')\n        for i in range(int(len(criteria)/2)):\n            key = 'convergence_' + criteria[2*i].lower()\n            try:\n                val = float(criteria[2*i+1])\n                logger.info('Using convergence criteria: %s %.2e\\n' % (key, val))\n            except ValueError:\n                # This must be a set\n                val = str(criteria[2*i+1])\n                logger.info('Using convergence criteria set: %s %s\\n' % (key, val))\n            kwargs[key] = val\n        # convergence dictionary to store criteria stored in order of energy, grms, gmax, drms, dmax\n        # 'GAU' contains the default convergence criteria that are used when nothing is passed.\n        convergence_sets = {'GAU': [1e-6, 3e-4, 4.5e-4, 1.2e-3, 1.8e-3],\n                            'NWCHEM_LOOSE': [1e-6, 3e-3, 4.5e-3, 3.6e-3, 5.4e-3],\n                            'GAU_LOOSE': [1e-6, 1.7e-3, 2.5e-3, 6.7e-3, 1e-2],\n                            'TURBOMOLE': [1e-6, 5e-4, 1e-3, 5.0e-4, 1e-3],\n                            'INTERFRAG_TIGHT': [1e-6, 1e-5, 1.5e-5, 4.0e-4, 6.0e-4],\n                            'GAU_TIGHT': [1e-6, 1e-5, 1.5e-5, 4e-5, 6e-5],\n                            'GAU_VERYTIGHT': [1e-6, 1e-6, 2e-6, 4e-6, 6e-6]}\n        # Q-Chem style convergence criteria (i.e. gradient and either energy or displacement)\n        self.qccnv = kwargs.get('qccnv', False)\n        # Molpro style convergence criteria (i.e. gradient and either energy or displacement, with different defaults)\n        self.molcnv = kwargs.get('molcnv', False)\n        # Check if there is a convergence set passed else use the default\n        set_name = kwargs.get('convergence_set', 'GAU').upper()\n        # If we have extra keywords apply them here else use the set\n        # Convergence criteria in a.u. and Angstrom\n        self.Convergence_energy = kwargs.get('convergence_energy', convergence_sets[set_name][0])\n        self.Convergence_grms = kwargs.get('convergence_grms', convergence_sets[set_name][1])\n        self.Convergence_gmax = kwargs.get('convergence_gmax', convergence_sets[set_name][2])\n        self.Convergence_drms = kwargs.get('convergence_drms', convergence_sets[set_name][3])\n        self.Convergence_dmax = kwargs.get('convergence_dmax', convergence_sets[set_name][4])\n        # Convergence criteria that are only used if molconv is set to True\n        self.Convergence_molpro_gmax = kwargs.get('convergence_molpro_gmax', 3e-4)\n        self.Convergence_molpro_dmax = kwargs.get('convergence_molpro_dmax', 1.2e-3)\n</code></pre>"},{"location":"tutorial/supported-programs/","title":"Supported programs","text":"<p>Supported compute engines in chemcloud can be checked as follows:</p> <pre><code>from chemcloud import CCClient\n\nclient = CCClient()\nclient.supported_engines\n[\"psi4\", \"terachem_fe\", \"rdkit\", ...]\n</code></pre> <p>Please see BigChem Algorithms for details on parallel execution algorithms unique to the BigChem compute engine.</p>"}]}