{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"chemcloud","text":""},{"location":"#chemcloud-a-python-client-for-chemcloud","title":"chemcloud - A Python Client for ChemCloud","text":"<p><code>chemcloud</code> is a python client for the ChemCloud Server. The client provides a simple yet powerful interface to perform computational chemistry calculations using nothing but modern Python and an internet connection.</p> <p>Documentation: https://mtzgroup.github.io/chemcloud-client</p> <p><code>chemcloud</code> works in harmony with a suite of other quantum chemistry tools for fast, structured, and interoperable quantum chemistry.</p>"},{"location":"#the-qc-suite-of-programs","title":"The QC Suite of Programs","text":"<ul> <li>qcio - Elegant and intuitive data structures for quantum chemistry, featuring seamless Jupyter Notebook visualizations. Documentation</li> <li>qcparse - A library for efficient parsing of quantum chemistry data into structured <code>qcio</code> objects.</li> <li>qcop - A package for operating quantum chemistry programs using <code>qcio</code> standardized data structures. Compatible with <code>TeraChem</code>, <code>psi4</code>, <code>QChem</code>, <code>NWChem</code>, <code>ORCA</code>, <code>Molpro</code>, <code>geomeTRIC</code>, and many more, featuring seamless Jupyter Notebook visualizations.</li> <li>BigChem - A distributed application for running quantum chemistry calculations at scale across clusters of computers or the cloud. Bring multi-node scaling to your favorite quantum chemistry program, featuring seamless Jupyter Notebook visualizations.</li> <li><code>ChemCloud</code> - A web application and associated Python client for exposing a BigChem cluster securely over the internet, featuring seamless Jupyter Notebook visualizations.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install chemcloud\n</code></pre>"},{"location":"#quickstart","title":"Quickstart","text":"<ul> <li>Create a ChemCloud account at https://chemcloud.mtzlab.com/signup (or the address of the ChemCloud Server you want to communicate with).</li> <li>Instantiate a client</li> <li>Configure client (only required the very first time you use <code>CCClient</code>)</li> </ul> <pre><code>from chemcloud import CCClient\n\nclient = CCClient()\nclient.configure() # only run this the very first time you use CCClient\n# See supported compute engines on the ChemCloud Server\nclient.supported_engines\n['psi4', 'terachem', ...]\n# Test connection to ChemCloud\nclient.hello_world(\"Colton\")\n'Welcome to ChemCloud, Colton'\n</code></pre> <ul> <li>Run calculations just like you would with <code>qcop</code> except calling <code>client.compute</code> instead of <code>qcop.compute</code>. Rather than getting back an <code>Output</code> object directly, <code>client.compute</code> returns a <code>FutureOutput</code> object which can be used to get the output of the computation once it is complete.</li> </ul> <pre><code>from qcio import Structure, ProgramInput\nfrom chemcloud import CCClient\n\nclient = CCClient()\n\n# Create the structure\nh2o = Structure.open(\"h2o.xyz\")\n\n# Define the program input\nprog_input = ProgramInput(\n    structure=h2o,\n    calctype=\"energy\",\n    model={\"method\": \"hf\", \"basis\": \"sto-3g\"},\n    keywords={\"purify\": \"no\", \"restricted\": False},\n)\n\n# Submit the calculation to the server\nfuture_output = client.compute(\"terachem\", prog_input, collect_files=True)\n# Status can be checked at any time\nfuture_result.status\n# Get the output (blocking)\noutput = future_output.get()\n\n# Inspect the output\noutput.input_data # Input data used by the QC program\noutput.success # Whether the calculation succeeded\noutput.results # All structured results from the calculation\noutput.results.files # Any files returned by the calculation\noutput.stdout # Stdout log from the calculation\noutput.pstdout # Shortcut to print out the stdout in human readable format\noutput.provenance # Provenance information about the calculation\noutput.extras # Any extra information not in the schema\noutput.traceback # Stack trace if calculation failed\noutput.ptraceback # Shortcut to print out the traceback in human readable format\n</code></pre>"},{"location":"#examples","title":"Examples","text":"<p>Examples of various computations can be found in the examples directory.</p>"},{"location":"#visualization","title":"\u2728 Visualization \u2728","text":"<p>Visualize all your results with a single line of code!</p> <p>First install the visualization module:</p> <pre><code>pip install qcio[view]\n</code></pre> <p>or if your shell requires <code>''</code> around arguments with brackets:</p> <pre><code>pip install 'qcio[view]'\n</code></pre> <p>Then in a Jupyter notebook import the <code>qcio</code> view module and call <code>view.view(...)</code> passing it one or any number of <code>qcio</code> objects you want to visualizing including <code>Structure</code> objects or any <code>ProgramOutput</code> object. You may also pass an array of <code>titles</code> and/or <code>subtitles</code> to add additional information to the molecular structure display. If no titles are passed <code>qcio</code> with look for <code>Structure</code> identifiers such as a name or SMILES to label the <code>Structure</code>.</p> <p></p> <p>Seamless visualizations for <code>ProgramOutput</code> objects make results analysis easy!</p> <p></p> <p>Single point calculations display their results in a table.</p> <p></p> <p>If you want to use the HTML generated by the viewer to build your own dashboards use the functions inside of <code>qcio.view.py</code> that begin with the word <code>generate_</code> to create HTML you can insert into any dashboard.</p>"},{"location":"#support","title":"Support","text":"<p>If you have any issues with <code>chemcloud</code> or would like to request a feature, please open an issue.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#unreleased","title":"unreleased","text":""},{"location":"CHANGELOG/#0122-2025-02-07","title":"0.12.2 - 2025-02-07","text":""},{"location":"CHANGELOG/#changed","title":"Changed","text":"<ul> <li>Loosened dependency specifications for <code>qcio</code> and <code>httpx</code>.</li> </ul>"},{"location":"CHANGELOG/#0121-2024-09-11","title":"0.12.1 - 2024-09-11","text":""},{"location":"CHANGELOG/#changed_1","title":"Changed","text":"<ul> <li>Using <code>FutureOutput</code> for arrays of inputs of length 1.</li> <li>Updated to Python 3.9 typing syntax.</li> </ul>"},{"location":"CHANGELOG/#0120-2024-08-06","title":"0.12.0 - 2024-08-06","text":""},{"location":"CHANGELOG/#changed_2","title":"Changed","text":"<ul> <li>Removed <code>black</code> and <code>isort</code> in favor for <code>ruff</code></li> </ul>"},{"location":"CHANGELOG/#updated","title":"Updated","text":"<ul> <li>\ud83d\udea8 <code>python</code> (<code>&gt;=3.8</code> -&gt; <code>&gt;=3.9</code>)</li> <li><code>tomli</code> (<code>^1.0</code> -&gt; <code>^2.0</code>)</li> <li><code>httpx</code> (<code>^0.23.1</code> -&gt; <code>^0.27</code>)</li> <li><code>ruff</code> (<code>^0.0287</code> -&gt; <code>^0.5</code>)</li> <li><code>pytest-httpx</code> (<code>&lt;0.23.0</code> -&gt; <code>&gt;=0.23.0</code>)</li> <li><code>format.sh</code> script dropped <code>black</code> and <code>isort</code>.</li> </ul>"},{"location":"CHANGELOG/#0111-2024-07-19","title":"0.11.1 - 2024-07-19","text":""},{"location":"CHANGELOG/#changed_3","title":"Changed","text":"<ul> <li>Updated to qcio 0.11..</li> </ul>"},{"location":"CHANGELOG/#0110-2024-07-12","title":"0.11.0 - 2024-07-12","text":""},{"location":"CHANGELOG/#changed_4","title":"Changed","text":"<p>Updated qcio (0.10.1 -&gt; 0.10.2). <code>Structure.ids</code> -&gt; <code>Structure.identifiers</code></p>"},{"location":"CHANGELOG/#0101-2024-07-11","title":"0.10.1 - 2024-07-11","text":""},{"location":"CHANGELOG/#added","title":"Added","text":"<ul> <li><code>py.typed</code> file for type checking in projects that depend upon <code>chemcloud</code>.</li> </ul>"},{"location":"CHANGELOG/#0100-2024-07-10","title":"0.10.0 - 2024-07-10","text":""},{"location":"CHANGELOG/#changed_5","title":"Changed","text":"<ul> <li>Updated to <code>qcio 0.10.1</code> which uses <code>Structure</code> instead of <code>Molecule</code>.</li> </ul>"},{"location":"CHANGELOG/#090-2024-06-14","title":"0.9.0 - 2024-06-14","text":""},{"location":"CHANGELOG/#changed_6","title":"Changed","text":"<ul> <li>Upgraded to <code>qcio</code> Generics data structures.</li> <li>Upgraded <code>black</code> from <code>^23.0.0</code> to <code>^24.0.0</code>.</li> <li>Renamed <code>collect_wavefucntion</code> kwarg to <code>CCClient.compute(...)</code> to <code>collect_wfn</code>.</li> <li>Updated the response returned by ChemCloud server to have attributes <code>status</code> and <code>program_output</code> from <code>state</code> and <code>results</code>.</li> <li>Rebuilt documentation to reflect new <code>qcio</code> Generics and renamed kwargs.</li> </ul>"},{"location":"CHANGELOG/#083-2023-10-20","title":"0.8.3 - 2023-10-20","text":""},{"location":"CHANGELOG/#changed_7","title":"Changed","text":"<ul> <li>Updated GitHub actions to run on <code>pull_request</code> in addition to <code>push</code>.</li> <li>Migrated dependency <code>uiri/toml</code> to <code>hukkin/tomli</code> (Python &lt; 3.11) or the built-in <code>tomllib</code> (Python &gt;= 3.11)</li> <li>Updated GitHub actions to test against both Python 3.8 and Python 3.11</li> </ul>"},{"location":"CHANGELOG/#082-2023-09-25","title":"0.8.2 - 2023-09-25","text":""},{"location":"CHANGELOG/#changed_8","title":"Changed","text":"<ul> <li>Removed <code>pydantic==2.4.0</code> from supported versions due to immediate bug upon this release. When trying to import <code>CCClient</code> a reference count error appears to trigger a <code>KeyError</code>. Bugs are being tracked here: https://github.com/pydantic/pydantic/issues/7617.</li> </ul>"},{"location":"CHANGELOG/#081-2023-09-20","title":"0.8.1 - 2023-09-20","text":""},{"location":"CHANGELOG/#changed_9","title":"Changed","text":"<ul> <li>Updated to <code>qcio&gt;=0.7.0</code> to account for renaming of <code>DualProgramArgs</code> to <code>SubProgramArgs</code>.</li> </ul>"},{"location":"CHANGELOG/#080-2023-09-19","title":"0.8.0 - 2023-09-19","text":""},{"location":"CHANGELOG/#changed_10","title":"Changed","text":"<ul> <li><code>FutureResult</code> objects now called <code>FutureOutput</code> to keep in harmony with <code>qcio</code> nomenclature.</li> <li>Documentation rewritten to capture API changes with <code>qcio</code> and <code>qcop</code>.</li> <li><code>/examples</code> scripts instantiate a <code>Molecule</code> directly rather than opening <code>h2o.xyz</code> so that code examples can be run directly from the documentation website.</li> <li>All <code>mkdocs</code> and associated documentation packages updated to the latest versions.</li> </ul>"},{"location":"CHANGELOG/#070-2023-09-08","title":"0.7.0 - 2023-09-08","text":""},{"location":"CHANGELOG/#changed_11","title":"Changed","text":"<ul> <li>Dropped <code>QCElemental</code> in favor of <code>qcio</code>.</li> <li>Updated client to work with <code>v2</code> of the ChemCloud server using <code>qcio</code>.</li> <li>Updated DevOps stack to be in harmony with other qc* packages (<code>poetry</code>, <code>GitHub Actions</code>, <code>pre-commit</code>, etc).</li> <li>Updated from pydantic <code>v1</code> -&gt; <code>v2</code>, added <code>pydantic-settings</code> to dependencies.</li> <li>Changed settings <code>chemcloud_default_credentials_profile</code> to <code>chemcloud_credentials_profile</code>.</li> <li>Updated a few names from <code>result</code> to <code>output</code> to be more in harmony with <code>qcio</code> nomenclature.</li> </ul>"},{"location":"CHANGELOG/#added_1","title":"Added","text":"<ul> <li>Publish to pypi from GitHub actions.</li> </ul>"},{"location":"CHANGELOG/#062-2022-12-27","title":"0.6.2 - 2022-12-27","text":""},{"location":"CHANGELOG/#changed_12","title":"Changed","text":"<ul> <li>Updated <code>qcelemental==0.24.0 -&gt; 0.25.1</code></li> </ul>"},{"location":"CHANGELOG/#061-2022-07-19","title":"0.6.1 - 2022-07-19","text":""},{"location":"CHANGELOG/#changed_13","title":"Changed","text":"<ul> <li>Pegged <code>qcelemental</code> to version <code>0.24.0</code> since <code>0.25.0</code> introduces breaking changes. Need to keep this version in sync with <code>ChemCloud</code> server version.</li> </ul>"},{"location":"CHANGELOG/#060-2022-07-19","title":"0.6.0 - 2022-07-19","text":""},{"location":"CHANGELOG/#changed_14","title":"Changed","text":"<ul> <li>Updated project name from <code>qccloud</code> to <code>chemcloud</code></li> </ul>"},{"location":"CHANGELOG/#050-2022-07-15","title":"0.5.0 - 2022-07-15","text":""},{"location":"CHANGELOG/#changed_15","title":"Changed","text":"<ul> <li>Updated project name from <code>tccloud</code> to <code>qccloud</code></li> </ul>"},{"location":"CHANGELOG/#041-2022-05-07","title":"0.4.1 - 2022-05-07","text":""},{"location":"CHANGELOG/#changed_16","title":"Changed","text":"<ul> <li>Upped the default timeout on http reads from 5.0s -&gt; 20.0s.</li> </ul>"},{"location":"CHANGELOG/#040-2022-4-02","title":"0.4.0 - 2022-4-02","text":""},{"location":"CHANGELOG/#added_2","title":"Added","text":"<ul> <li><code>to_file()</code> and <code>from_file()</code> methods to easily save compute job ids for later retrieval.</li> </ul>"},{"location":"CHANGELOG/#changed_17","title":"Changed","text":"<ul> <li>Simplified management of task ids between client and server. Only need to send a single id to server even if a batch computation was initiated.</li> </ul>"},{"location":"CHANGELOG/#removed","title":"Removed","text":"<ul> <li>Support for Python3.6. Python3.6 end-of-lif'ed December 23, 2021.</li> </ul>"},{"location":"CHANGELOG/#031-2022-03-27","title":"0.3.1 - 2022-03-27","text":""},{"location":"CHANGELOG/#added_3","title":"Added","text":"<ul> <li>Decode b64 encoded data returned from server in <code>AtomicResult.extra['tcfe:keywords']</code></li> </ul>"},{"location":"CHANGELOG/#changed_18","title":"Changed","text":"<ul> <li>Updated <code>config.settings.tcfe_config_kwargs = \"tcfe:config</code> -&gt; <code>config.settings.tcfe_keywords = \"tcfe:keywords</code></li> </ul>"},{"location":"CHANGELOG/#030-2022-03-26","title":"0.3.0 - 2022-03-26","text":""},{"location":"CHANGELOG/#added_4","title":"Added","text":"<ul> <li>Support for <code>AtomicInput.protocols.native_files</code>. User can now request QC package specific files generated during a computation.</li> <li>Added support for TeraChem-specific <code>native_files</code>. c0/ca0/cb0 bytes files (or any bytes data) placed in <code>AtomicInput.extras['tcfe:keywords']</code> will be automatically base64 encoded and sent to the server. The enables seeding computations with a wave function as an initial guess.</li> <li>Base64 encoded <code>native_files</code> returned from server will be automatically decoded to bytes.</li> </ul>"},{"location":"CHANGELOG/#024-2021-06-07","title":"0.2.4 - 2021-06-07","text":""},{"location":"CHANGELOG/#added_5","title":"Added","text":"<ul> <li>Private compute queues to <code>compute()</code> and <code>compute_procedure()</code></li> </ul>"},{"location":"CHANGELOG/#023-2021-06-04","title":"0.2.3 - 2021-06-04","text":""},{"location":"CHANGELOG/#added_6","title":"Added","text":"<ul> <li>Batch compute for both <code>compute()</code> and <code>compute_procedure()</code> methods</li> <li><code>FutureResultGroup</code> for batch computations</li> </ul>"},{"location":"CHANGELOG/#changed_19","title":"Changed","text":"<ul> <li>Added <code>pydantic</code> <code>BaseModel</code> as base for <code>FutureResult</code> objects.</li> </ul>"},{"location":"CHANGELOG/#022-2021-05-21","title":"0.2.2 - 2021-05-21","text":""},{"location":"CHANGELOG/#added_7","title":"Added","text":"<ul> <li>Extended documentation to include a Code Reference section and much more comprehensive documentation of the main objects.</li> <li>Added <code>compute_procedure</code> to <code>TCClient</code> for geometry optimizations.</li> <li>Added <code>TCClient.version</code> property for quick version checks.</li> </ul>"},{"location":"CHANGELOG/#021-2021-03-05","title":"0.2.1 - 2021-03-05","text":""},{"location":"CHANGELOG/#added_8","title":"Added","text":"<ul> <li>Changelog</li> <li>User documentation</li> <li>Website for documentation</li> </ul>"},{"location":"CHANGELOG/#020-2021-02-26","title":"0.2.0 - 2021-02-26","text":""},{"location":"CHANGELOG/#added_9","title":"Added","text":"<ul> <li>Added <code>TaskStatus</code> enum to hold all task statuses.</li> <li>Basic documentation on main classes.</li> <li>[core_decisions.md] to document thinking behind architectural choices.</li> </ul>"},{"location":"CHANGELOG/#changed_20","title":"Changed","text":"<ul> <li><code>FutureResult.get()</code> to return either an <code>AtomicResult</code> or a <code>FailedComputation</code></li> <li>Simplified README.md overview to use dictionaries instead of classes. Results in simpler tutorial with fewer imports.</li> </ul>"},{"location":"CHANGELOG/#011-2021-01-22","title":"0.1.1 - 2021-01-22","text":""},{"location":"CHANGELOG/#added_10","title":"Added","text":"<ul> <li><code>TCClient</code> that can manage credentials, submit AtomicInput computations, and retrieve AtomicResult output from TeraChem Cloud.</li> <li><code>_RequestsClient</code> class that handles all network requests to TeraChem Cloud server</li> <li><code>FutureResults</code> object that is created from a <code>task_id</code> and can be used to retrieve a result once finished.</li> </ul>"},{"location":"dev-decisions/","title":"Core Development Decisions","text":""},{"location":"dev-decisions/#_requestsclient-class","title":"_RequestsClient Class","text":"<ul> <li><code>_RequestsClient</code> public http methods (like <code>compute()</code> and <code>result()</code> should always return Python objects. This gives a layer of abstraction between callers who want to think in terms of Python data objects and the <code>_RequestsClient</code> which thinks in terms of http requests and <code>json</code> data structures.</li> </ul> <p>I'm starting to have second thoughts about this ^^ decision. It feels like the <code>_RequestsClient</code> is starting to take on too much responsibility. It accepts python data types as parameters, and returns python data types as it if were an end-user class. It isn't. It's meant to be a utility class used by end-user objects such as <code>CCClient</code> and <code>FutureOutput</code> objects. I think it should return data more directly from the ChemCloud API and let the other classes handle this data. This becomes more apparent as I add <code>pydantic</code> to my data models and realize I'd rather have them pass rawer data types to the <code>_RequestsClient</code> and then handle the results of an API call inside their own class. Maybe the <code>compute()</code> method on the <code>_RequestsClient</code> should go away and these should live exclusively on the <code>CCClient</code> object which then utilizes <code>request</code> and <code>authenticated_request</code> to access ChemCloud.</p>"},{"location":"code-reference/CCClient/","title":"CCClient","text":""},{"location":"code-reference/CCClient/#chemcloud.client.CCClient","title":"chemcloud.client.CCClient","text":"<pre><code>CCClient(\n    *,\n    chemcloud_username: Optional[str] = None,\n    chemcloud_password: Optional[str] = None,\n    profile: Optional[str] = None,\n    chemcloud_domain: Optional[str] = None,\n)\n</code></pre> <p>Main client object to perform computations using ChemCloud.</p> <p>Parameters:</p> Name Type Description Default <code>chemcloud_username</code> <code>Optional[str]</code> <p>ChemCloud username</p> <code>None</code> <code>chemcloud_password</code> <code>Optional[str]</code> <p>ChemCloud password</p> <code>None</code> <code>profile</code> <code>Optional[str]</code> <p>Authentication profile name</p> <code>None</code> <code>chemcloud_domain</code> <code>Optional[str]</code> <p>Domain of ChemCloud instance to connect to</p> <code>None</code> <p>Danger</p> <p>It is not recommended to pass your ChemCloud username and password directly to a <code>CCClient</code>. Instead instantiate a client with no credentials <code>client = CCClient()</code> and then run <code>client.configure()</code> to securely set up your authentication credentials for ChemCloud.</p> Source code in <code>chemcloud/client.py</code> <pre><code>def __init__(\n    self,\n    *,\n    chemcloud_username: Optional[str] = None,\n    chemcloud_password: Optional[str] = None,\n    profile: Optional[str] = None,\n    chemcloud_domain: Optional[str] = None,\n):\n    \"\"\"\n    Initialize a CCClient object.\n\n    Parameters:\n        chemcloud_username: ChemCloud username\n        chemcloud_password: ChemCloud password\n        profile: Authentication profile name\n        chemcloud_domain: Domain of ChemCloud instance to connect to\n\n    !!! Danger\n        It is not recommended to pass your ChemCloud username and\n        password directly to a `CCClient`. Instead instantiate a client with no\n        credentials `client = CCClient()` and then run `client.configure()` to\n        securely set up your authentication credentials for ChemCloud.\n    \"\"\"\n    self._client = _RequestsClient(\n        chemcloud_username=chemcloud_username,\n        chemcloud_password=chemcloud_password,\n        profile=profile,\n        chemcloud_domain=chemcloud_domain,\n    )\n    self._openapi_spec: Optional[dict] = None\n</code></pre>"},{"location":"code-reference/CCClient/#chemcloud.client.CCClient.version","title":"version  <code>property</code>","text":"<pre><code>version: str\n</code></pre> <p>Returns chemcloud client version</p>"},{"location":"code-reference/CCClient/#chemcloud.client.CCClient.profile","title":"profile  <code>property</code>","text":"<pre><code>profile: str\n</code></pre> <p>Profile being used for authentication with ChemCloud.</p> <p>Returns:</p> Type Description <code>str</code> <p>The name of the credentials profile being used with the current client.</p>"},{"location":"code-reference/CCClient/#chemcloud.client.CCClient.supported_programs","title":"supported_programs  <code>property</code>","text":"<pre><code>supported_programs: list[str]\n</code></pre> <p>Compute programs currently supported by ChemCloud.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of programs currently supported by ChemCloud.</p>"},{"location":"code-reference/CCClient/#chemcloud.client.CCClient.hello_world","title":"hello_world","text":"<pre><code>hello_world(name: Optional[str] = None) -&gt; str\n</code></pre> <p>A simple endpoint to check connectivity to ChemCloud.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Your name</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A message from ChemCloud if the client was able to successfully</p> <code>str</code> <p>connect.</p> Source code in <code>chemcloud/client.py</code> <pre><code>def hello_world(self, name: Optional[str] = None) -&gt; str:\n    \"\"\"A simple endpoint to check connectivity to ChemCloud.\n\n    Parameters:\n        name: Your name\n\n    Returns:\n        A message from ChemCloud if the client was able to successfully\n        connect.\n    \"\"\"\n    return self._client.hello_world(name)\n</code></pre>"},{"location":"code-reference/CCClient/#chemcloud.client.CCClient.compute","title":"compute","text":"<pre><code>compute(\n    program: str,\n    inp_obj: QCIOInputsOrList,\n    *,\n    collect_stdout: bool = True,\n    collect_files: bool = False,\n    collect_wfn: bool = False,\n    rm_scratch_dir: bool = True,\n    propagate_wfn: bool = False,\n    queue: Optional[str] = None,\n) -&gt; Union[FutureOutput, FutureOutputGroup]\n</code></pre> <p>Submit a computation to ChemCloud.</p> <p>Parameters:</p> Name Type Description Default <code>program</code> <code>str</code> <p>A program name matching one of the <code>self.supported_programs</code></p> required <code>inp_obj</code> <code>QCIOInputsOrList</code> <p>The input object to be used for the computation. This can be a single input object or a list of input objects.</p> required <code>collect_stdout</code> <code>bool</code> <p>Whether to collect stdout/stderr from the program as output. Failed computations will always collect stdout/stderr.</p> <code>True</code> <code>collect_files</code> <code>bool</code> <p>Collect all files generated by the QC program as output.</p> <code>False</code> <code>collect_wfn</code> <code>bool</code> <p>Collect the wavefunction file(s) from the calculation. Not every program will support this. Use collect_files to collect all files including the wavefunction.</p> <code>False</code> <code>rm_scratch_dir</code> <code>bool</code> <p>Delete the scratch directory after the program exits. Should only be set to False for debugging purposes.</p> <code>True</code> <code>propagate_wfn</code> <code>bool</code> <p>For any adapter performing a sequential task, such as a geometry optimization, propagate the wavefunction from the previous step to the next step. This is useful for accelerating convergence by using a previously computed wavefunction as a starting guess. This will be ignored if the adapter for a given qc program does not support it.</p> <code>False</code> <code>queue</code> <code>Optional[str]</code> <p>The name of a private compute queue. If None, default queue is used</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[FutureOutput, FutureOutputGroup]</code> <p>Object providing access to a computation's eventual result. You can check a</p> <code>Union[FutureOutput, FutureOutputGroup]</code> <p>computation's status by running <code>.status</code> on the <code>FutureOutput</code> object or</p> <code>Union[FutureOutput, FutureOutputGroup]</code> <p><code>.get()</code> to block and retrieve the computation's final result.</p> Source code in <code>chemcloud/client.py</code> <pre><code>def compute(\n    self,\n    program: str,\n    inp_obj: QCIOInputsOrList,\n    *,\n    collect_stdout: bool = True,\n    collect_files: bool = False,\n    collect_wfn: bool = False,\n    rm_scratch_dir: bool = True,\n    propagate_wfn: bool = False,\n    queue: Optional[str] = None,\n) -&gt; Union[FutureOutput, FutureOutputGroup]:\n    \"\"\"Submit a computation to ChemCloud.\n\n    Parameters:\n        program: A program name matching one of the `self.supported_programs`\n        inp_obj: The input object to be used for the computation. This can be a\n            single input object or a list of input objects.\n        collect_stdout: Whether to collect stdout/stderr from the program as output.\n            Failed computations will always collect stdout/stderr.\n        collect_files: Collect all files generated by the QC program as output.\n        collect_wfn: Collect the wavefunction file(s) from the calculation.\n            Not every program will support this. Use collect_files to collect\n            all files including the wavefunction.\n        rm_scratch_dir: Delete the scratch directory after the program exits. Should\n            only be set to False for debugging purposes.\n        propagate_wfn: For any adapter performing a sequential task, such\n            as a geometry optimization, propagate the wavefunction from the previous\n            step to the next step. This is useful for accelerating convergence by\n            using a previously computed wavefunction as a starting guess. This will\n            be ignored if the adapter for a given qc program does not support it.\n        queue: The name of a private compute queue. If None, default queue is used\n\n    Returns:\n        Object providing access to a computation's eventual result. You can check a\n        computation's status by running `.status` on the `FutureOutput` object or\n        `.get()` to block and retrieve the computation's final result.\n    \"\"\"\n    if self.supported_programs is not None:\n        assert (\n            program in self.supported_programs\n        ), f\"Please use one of the following programs: {self.supported_programs}\"\n\n    compute_params = dict(\n        program=program,\n        collect_stdout=collect_stdout,\n        collect_files=collect_files,\n        collect_wfn=collect_wfn,\n        rm_scratch_dir=rm_scratch_dir,\n        propagate_wfn=propagate_wfn,\n        queue=queue,\n    )\n    return self._client.compute(inp_obj, compute_params)\n</code></pre>"},{"location":"code-reference/CCClient/#chemcloud.client.CCClient.configure","title":"configure","text":"<pre><code>configure(\n    profile: str = chemcloud_credentials_profile,\n) -&gt; None\n</code></pre> <p>Configure profiles for authentication with ChemCloud.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>str</code> <p>Optional value to create a named profile for use with QC Cloud. No value needs to be passed and most users will only have one login with ChemCloud. CCClient will access the profile by default without a specific name being passed. Pass a value if you have multiple logins to ChemCloud.</p> <code>chemcloud_credentials_profile</code> <p>Note:     Configures <code>chemcloud</code> to use the passed credentials automatically in the     future. You will not need to run <code>.configure()</code> the next time you use the     <code>chemcloud</code>.</p> Source code in <code>chemcloud/client.py</code> <pre><code>def configure(self, profile: str = settings.chemcloud_credentials_profile) -&gt; None:\n    \"\"\"Configure profiles for authentication with ChemCloud.\n\n    Parameters:\n        profile: Optional value to create a named profile for use with QC\n            Cloud. No value needs to be passed and most users will only have one\n            login with ChemCloud. CCClient will access the profile by\n            default without a specific name being passed. Pass a value if you have\n            multiple logins to ChemCloud.\n    Note:\n        Configures `chemcloud` to use the passed credentials automatically in the\n        future. You will not need to run `.configure()` the next time you use the\n        `chemcloud`.\n\n    \"\"\"\n    print(\n        \"\u2705 If you don't get have an account please signup at: \"\n        f\"{self._client._chemcloud_domain}/signup\"\n    )\n    access_token, refresh_token = self._client._set_tokens_from_user_input()\n    self._client.write_tokens_to_credentials_file(\n        access_token, refresh_token, profile=profile\n    )\n    print(\n        f\"'{profile}' profile configured! Username/password not required for \"\n        \"future use of CCClient\"\n    )\n</code></pre>"},{"location":"code-reference/FutureOutputs/","title":"FutureOutputs","text":""},{"location":"code-reference/FutureOutputs/#chemcloud.models","title":"chemcloud.models","text":""},{"location":"code-reference/FutureOutputs/#chemcloud.models.TaskStatus","title":"TaskStatus","text":"<p>Tasks status for a submitted compute job.</p>"},{"location":"code-reference/FutureOutputs/#chemcloud.models.FutureOutputBase","title":"FutureOutputBase","text":"<p>Base class for FutureOutputs</p> <p>Attributes:</p> Name Type Description <code>task_id</code> <code>str</code> <p>The task_id for primary task submitted to ChemCloud. May correspond to a single task or group of tasks.</p> <code>client</code> <code>Any</code> <p>The _RequestsClient to use for http requests to ChemCloud.</p> <code>result</code> <code>Optional[QCIOOutputsOrList]</code> <p>Primary return value resulting from computation.</p> Caution <p>A FutureOutput should never be instantiated directly. <code>CCClient.compute(...)</code> will return one when you submit a computation.</p>"},{"location":"code-reference/FutureOutputs/#chemcloud.models.FutureOutputBase.status","title":"status  <code>property</code>","text":"<pre><code>status: str\n</code></pre> <p>Check status of compute task.</p> <p>Returns:</p> Type Description <code>str</code> <p>Status of computation.</p> Note <p>Sets self.result if task is complete.</p>"},{"location":"code-reference/FutureOutputs/#chemcloud.models.FutureOutputBase.get","title":"get","text":"<pre><code>get(\n    timeout: Optional[float] = None, interval: float = 1.0\n) -&gt; Optional[QCIOOutputsOrList]\n</code></pre> <p>Block until a calculation is complete and return the result.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>Optional[float]</code> <p>The number of seconds to wait for a computation before raising a TimeOutError.</p> <code>None</code> <code>interval</code> <code>float</code> <p>The amount of time to wait between calls to ChemCloud to check a computation's status.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>Optional[QCIOOutputsOrList]</code> <p>Resultant values from a computation.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>Raised if timeout interval exceeded.</p> Source code in <code>chemcloud/models.py</code> <pre><code>def get(\n    self,\n    timeout: Optional[float] = None,  # in seconds\n    interval: float = 1.0,\n) -&gt; Optional[QCIOOutputsOrList]:\n    \"\"\"Block until a calculation is complete and return the result.\n\n    Parameters:\n        timeout: The number of seconds to wait for a computation before raising a\n            TimeOutError.\n        interval: The amount of time to wait between calls to ChemCloud to\n            check a computation's status.\n\n    Returns:\n        Resultant values from a computation.\n\n    Exceptions:\n        TimeoutError: Raised if timeout interval exceeded.\n    \"\"\"\n    if self.result:\n        return self.result\n\n    start_time = time()\n\n    # self._state check prevents 401 errors from ChemCloud when the job completed\n    # but the server failed to return a result (e.g., due to .program_output not)\n    # being set correctly by qcio/BigChem.\n    # TODO: Make a clearer contract between Server and Client re: states. This got\n    # a bit messy as I switched mimicking celery states to the more simplified setup\n    # I have now. This can be simplified further.\n    while not self.result and self._state not in {\"COMPLETE\", \"FAILURE\"}:\n        # Calling self.status returns status and sets self.result if task complete\n        self.status\n        if timeout:\n            if (time() - start_time) &gt; timeout:\n                raise TimeoutError(\n                    f\"Your timeout limit of {timeout} seconds was exceeded\"\n                )\n        sleep(interval)\n\n    return self.result\n</code></pre>"},{"location":"code-reference/FutureOutputs/#chemcloud.models.FutureOutput","title":"FutureOutput","text":"<p>Single computation result</p>"},{"location":"code-reference/FutureOutputs/#chemcloud.models.FutureOutputGroup","title":"FutureOutputGroup","text":"<p>Group computation result</p>"},{"location":"code-reference/FutureOutputs/#chemcloud.models.FutureOutputGroup.validate_id","title":"validate_id  <code>classmethod</code>","text":"<pre><code>validate_id(val)\n</code></pre> <p>Prepend id with GROUP_ID_PREFIX.</p> NOTE <p>This makes instantiating FutureOutputGroups from saved ids easier because they are differentiated from FutureOutput ids.</p> Source code in <code>chemcloud/models.py</code> <pre><code>@field_validator(\"task_id\")\n@classmethod\ndef validate_id(cls, val):\n    \"\"\"Prepend id with GROUP_ID_PREFIX.\n\n    NOTE:\n        This makes instantiating FutureOutputGroups from saved ids easier because\n        they are differentiated from FutureOutput ids.\n    \"\"\"\n    if not val.startswith(GROUP_ID_PREFIX):\n        val = GROUP_ID_PREFIX + val\n    return val\n</code></pre>"},{"location":"code-reference/FutureOutputs/#chemcloud.models.to_file","title":"to_file","text":"<pre><code>to_file(\n    future_results: Union[\n        FutureOutputBase, list[FutureOutputBase]\n    ],\n    path: Union[str, Path],\n    *,\n    append: bool = False,\n) -&gt; None\n</code></pre> <p>Write FutureOutputs to disk for later retrieval</p> <p>Parameters:</p> Name Type Description Default <code>future_results</code> <code>Union[FutureOutputBase, list[FutureOutputBase]]</code> <p>List of or single FutureOutput or FutureOutputGroup</p> required <code>path</code> <code>Union[str, Path]</code> <p>File path to results file</p> required <code>append</code> <code>bool</code> <p>Append results to an existing file if True, else create new file</p> <code>False</code> Source code in <code>chemcloud/models.py</code> <pre><code>def to_file(\n    future_results: Union[FutureOutputBase, list[FutureOutputBase]],\n    path: Union[str, Path],\n    *,\n    append: bool = False,\n) -&gt; None:\n    \"\"\"Write FutureOutputs to disk for later retrieval\n\n    Params:\n        future_results: List of or single FutureOutput or FutureOutputGroup\n        path: File path to results file\n        append: Append results to an existing file if True, else create new file\n    \"\"\"\n    if not isinstance(future_results, list):\n        future_results = [future_results]\n\n    with open(path, f\"{'a' if append else 'w'}\") as f:\n        f.writelines([f\"{fr.task_id}\\n\" for fr in future_results])\n</code></pre>"},{"location":"code-reference/FutureOutputs/#chemcloud.models.from_file","title":"from_file","text":"<pre><code>from_file(\n    path: Union[str, Path], client: Any\n) -&gt; list[Union[FutureOutput, FutureOutputGroup]]\n</code></pre> <p>Instantiate FutureOutputs or FutureOutputGroups from file of result ids</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to file containing the ids</p> required <code>client</code> <code>Any</code> <p>Instantiated CCClient object</p> required Source code in <code>chemcloud/models.py</code> <pre><code>def from_file(\n    path: Union[str, Path],\n    client: Any,\n) -&gt; list[Union[FutureOutput, FutureOutputGroup]]:\n    \"\"\"Instantiate FutureOutputs or FutureOutputGroups from file of result ids\n\n    Params:\n        path: Path to file containing the ids\n        client: Instantiated CCClient object\n    \"\"\"\n    frs: list[Union[FutureOutput, FutureOutputGroup]] = []\n    with open(path) as f:\n        for id in f.readlines():\n            id = id.strip()\n            model: Union[type[FutureOutput], type[FutureOutputGroup]]\n            if id.startswith(GROUP_ID_PREFIX):\n                model = FutureOutputGroup\n            else:\n                model = FutureOutput\n            frs.append(model(task_id=id, client=client._client))\n\n    assert len(frs) &gt; 0, \"No ids found in file!\"\n    return frs\n</code></pre>"},{"location":"code-reference/ProgramInputs/","title":"ProgramInputs","text":""},{"location":"code-reference/ProgramInputs/#qcio.models.inputs","title":"qcio.models.inputs","text":"<p>Input models for quantum chemistry calculations.</p>"},{"location":"code-reference/ProgramInputs/#qcio.models.inputs.FileInput","title":"FileInput","text":"<p>File and command line argument inputs for a calculation.</p> <p>Attributes:</p> Name Type Description <code>files</code> <code>Files</code> <p>A dict mapping filename to str or bytes data.</p> <code>cmdline_args</code> <code>list[str]</code> <p>A list of command line arguments to be passed to the program.</p> <code>extras</code> <code>Dict[str, Any]</code> <p>Additional information to bundle with the object. Use for schema development and scratch space.</p>"},{"location":"code-reference/ProgramInputs/#qcio.models.inputs.FileInput.from_directory","title":"from_directory  <code>classmethod</code>","text":"<pre><code>from_directory(\n    directory: Union[Path, str], **kwargs\n) -&gt; Self\n</code></pre> <p>Create a new FileInput and collect all files in the directory.</p> Source code in <code>qcio/models/inputs.py</code> <pre><code>@classmethod\ndef from_directory(cls, directory: Union[Path, str], **kwargs) -&gt; Self:\n    \"\"\"Create a new FileInput and collect all files in the directory.\"\"\"\n    obj = cls(**kwargs)\n    directory = Path(directory)\n    obj.add_files(directory)\n    return obj\n</code></pre>"},{"location":"code-reference/ProgramInputs/#qcio.models.inputs.ProgramArgs","title":"ProgramArgs","text":"<p>Generic arguments for a program without a calctype or structure specification.</p> <p>This class is used by <code>DualProgramInput</code> or multi-step calculations to specify <code>subprogram_args</code> or a basic program arguments multistep algorithm in BigChem. It is not intended to be used directly for single-step calculations since it lacks a <code>calctype</code> and <code>structure</code>.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>Model</code> <p>The model for the quantum chemistry calculation.</p> <code>keywords</code> <code>Dict[str, Any]</code> <p>A dict of keywords to be passed to the program excluding model and calctype. Defaults to an empty dict.</p> <code>files</code> <code>Files</code> <p>Files to be passed to the QC program.</p> <code>extras</code> <code>Dict[str, Any]</code> <p>Additional information to bundle with the object. Use for schema development and scratch space.</p>"},{"location":"code-reference/ProgramInputs/#qcio.models.inputs.ProgramArgsSub","title":"ProgramArgsSub","text":"<p>Generic arguments for a program that also calls a subprogram.</p> <p>This class is needed for multi-step calculations where the calctype and structure are specified only once for the entire calculation, e.g., multistep_opt in BigChem.</p> <p>Attributes:</p> Name Type Description <code>keywords</code> <code>dict[str, Any]</code> <p>A dict of keywords to be passed to the program excluding model and calctype. Defaults to an empty dict.</p> <code>files</code> <code>dict[str, Union[str, bytes]]</code> <p>Files to be passed to the QC program.</p> <code>model</code> <code>Optional[Model]</code> <p>The model for the quantum chemistry calculation</p> <code>subprogram</code> <code>str</code> <p>The name of the subprogram to use.</p> <code>subprogram_args</code> <code>ProgramArgs</code> <p>The ProgramArgs for the subprogram.</p> <code>extras</code> <code>dict[str, Any]</code> <p>Additional information to bundle with the object. Use for schema development and scratch space.</p>"},{"location":"code-reference/ProgramInputs/#qcio.models.inputs.ProgramInput","title":"ProgramInput","text":"<pre><code>ProgramInput(**data: Any)\n</code></pre> <p>Input for a single quantum chemistry program. This is the most common input type.</p> <p>Attributes:</p> Name Type Description <code>calctype</code> <code>CalcType</code> <p>The type of calculation to perform.</p> <code>model</code> <code>Model</code> <p>The model for the quantum chemistry calculation.</p> <code>keywords</code> <code>Dict[str, Any]</code> <p>A dict of keywords to be passed to the program excluding model and calctype. Defaults to an empty dict.</p> <code>structure</code> <code>Structure</code> <p>The structure to be used in the calculation.</p> <code>files</code> <code>Files</code> <p>Files to be passed to the QC program.</p> <code>extras</code> <code>Dict[str, Any]</code> <p>Additional information to bundle with the object. Use for schema development and scratch space.</p> Example <pre><code>from qcio.models import ProgramInput, Structure\n\nstruct = Structure.open(\"path/to/structure.xyz\")\n\nprog_inp = ProgramInput(\n    calctype = \"energy\",\n    structure = struct,\n    model = {\"method\": \"hf\", \"basis\": \"6-31G\"},\n    keywords = {\"maxsteps\": \"250\"},  # Optional\n    files = {\"file1\": b\"binary data\"}  # Optional\n)\n</code></pre> Source code in <code>qcio/models/inputs.py</code> <pre><code>def __init__(self, **data: Any):\n    \"\"\"Backwards compatibility for 'molecule' attribute.\"\"\"\n\n    # TODO: Remove in future versions.\n    if \"molecule\" in data:\n        warnings.warn(\n            \"Use of 'molecule' attribute is deprecated. Use 'structure' instead.\",\n            FutureWarning,\n            stacklevel=2,\n        )\n        data[\"structure\"] = data.pop(\"molecule\")\n    super().__init__(**data)\n</code></pre>"},{"location":"code-reference/ProgramInputs/#qcio.models.inputs.DualProgramInput","title":"DualProgramInput","text":"<pre><code>DualProgramInput(**data: Any)\n</code></pre> <p>Input for a two program calculation.</p> <p>Attributes:</p> Name Type Description <code>calctype</code> <code>CalcType</code> <p>The type of calculation to perform.</p> <code>model</code> <code>Model</code> <p>The model for the quantum chemistry calculation.</p> <code>keywords</code> <code>Dict[str, Any]</code> <p>A dict of keywords to be passed to the program excluding model and calctype. Defaults to an empty dict.</p> <code>structure</code> <code>Structure</code> <p>The structure to be used in the calculation.</p> <code>files</code> <code>Files</code> <p>Files to be passed to the QC program.</p> <code>subprogram</code> <code>str</code> <p>The name of the subprogram to use.</p> <code>subprogram_args</code> <code>ProgramArgs</code> <p>The ProgramArgs for the subprogram.</p> <code>extras</code> <code>Dict[str, Any]</code> <p>Additional information to bundle with the object. Use for schema development and scratch space.</p> Example <pre><code>from qcio.models import DualProgramInput, Structure\n\nstruct = Structure.open(\"path/to/structure.xyz\")\n\nprog_inp = DualProgramInput(\n    calctype = \"optimization\",\n    structure = struct,\n    keywords = {\"maxiter\": \"250\"},  # Optional\n    subprogram = \"orca\",\n    subprogram_args = ProgramArgs(\n        model = {\"method\": \"wb97x-d3\", \"basis\": \"def2-SVP\"},\n        keywords = {\"convthre\": \"1e-6\"},  # Optional\n    )\n)\n</code></pre> Source code in <code>qcio/models/inputs.py</code> <pre><code>def __init__(self, **data: Any):\n    \"\"\"Backwards compatibility for 'molecule' attribute.\"\"\"\n\n    # TODO: Remove in future versions.\n    if \"molecule\" in data:\n        warnings.warn(\n            \"Use of 'molecule' attribute is deprecated. Use 'structure' instead.\",\n            FutureWarning,\n            stacklevel=2,\n        )\n        data[\"structure\"] = data.pop(\"molecule\")\n    super().__init__(**data)\n</code></pre>"},{"location":"code-reference/ProgramOutputs/","title":"ProgramOutputs","text":""},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs","title":"qcio.models.outputs","text":"<p>End user output and results objects from a calculation.</p>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.Wavefunction","title":"Wavefunction","text":"<p>The wavefunction for a single point calculation.</p> <p>Attributes:</p> Name Type Description <code>scf_eigenvalues_a</code> <code>SerializableNDArray | None</code> <p>The SCF alpha-spin orbital eigenvalues.</p> <code>scf_eigenvalues_b</code> <code>SerializableNDArray | None</code> <p>The SCF beta-spin orbital eigenvalues.</p> <code>scf_occupations_a</code> <code>SerializableNDArray | None</code> <p>The SCF alpha-spin orbital occupations.</p> <code>scf_occupations_b</code> <code>SerializableNDArray | None</code> <p>The SCF beta-spin orbital occupations.</p>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.SinglePointResults","title":"SinglePointResults","text":"<p>The computed results from a single point calculation.</p> <p>Attributes:</p> Name Type Description <code>calcinfo_natoms</code> <code>int | None</code> <p>The number of atoms as computed by the program.</p> <code>calcinfo_nalpha</code> <code>int | None</code> <p>The number of alpha electrons as computed by the program.</p> <code>calcinfo_nbeta</code> <code>int | None</code> <p>The number of beta electrons as computed by the program.</p> <code>calcinfo_nbasis</code> <code>int | None</code> <p>The number of basis functions in the calculation.</p> <code>calcinfo_nmo</code> <code>int | None</code> <p>The number of molecular orbitals in the calculation.</p> <code>energy</code> <code>float | None</code> <p>The electronic energy of the structure in <code>Hartrees</code>.</p> <code>gradient</code> <code>SerializableNDArray | None</code> <p>The gradient of the structure in <code>Hartrees/Bohr</code>.</p> <code>hessian</code> <code>SerializableNDArray | None</code> <p>The hessian of the structure in <code>Hartrees/Bohr^2</code>.</p> <code>nuclear_repulsion_energy</code> <code>float | None</code> <p>The nuclear repulsion energy of the structure in Hartrees.</p> <code>wavefunction</code> <code>Wavefunction | None</code> <p>Wavefunction data from the calculation.</p> <code>freqs_wavenumber</code> <code>list[float]</code> <p>The frequencies of the structure in wavenumbers.</p> <code>normal_modes_cartesian</code> <code>SerializableNDArray | None</code> <p>3D n_vibmodes x n_atoms x 3 array containing un-mass-weighted Cartesian displacements of each normal mode in Bohr.</p> <code>gibbs_free_energy</code> <code>float | None</code> <p>Gibbs free energy (i.e. thermochemical analysis) in Hartrees of a system where translation / rotation / vibration degrees of freedom are approximated using ideal gas / rigid rotor / harmonic oscillator respectively.</p> <code>scf_dipole_moment</code> <code>list[float] | None</code> <p>The x, y, z component of the dipole moment of the structure in units of e a0 (NOT Debye!).</p>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.SinglePointResults.return_result","title":"return_result","text":"<pre><code>return_result(\n    calctype: CalcType,\n) -&gt; float | SerializableNDArray\n</code></pre> <p>Return the primary result of the calculation.</p> Source code in <code>qcio/models/outputs.py</code> <pre><code>def return_result(self, calctype: CalcType) -&gt; float | SerializableNDArray:\n    \"\"\"Return the primary result of the calculation.\"\"\"\n    return getattr(self, calctype.value)\n</code></pre>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.OptimizationResults","title":"OptimizationResults","text":"<p>Computed properties for an optimization.</p> <p>Attributes:</p> Name Type Description <code>energies</code> <code>ndarray</code> <p>The energies for each step of the optimization.</p> <code>structures</code> <code>list[Structure]</code> <p>The Structure objects for each step of the optimization.</p> <code>final_structure</code> <code>Structure</code> <p>The final, optimized Structure.</p> <code>trajectory</code> <code>list[ProgramOutput[ProgramInput, SinglePointResults] | ProgramOutput[ProgramInput, Files]]</code> <p>The SinglePointOutput objects for each step of the optimization.</p>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.OptimizationResults.final_structure","title":"final_structure  <code>property</code>","text":"<pre><code>final_structure: Structure\n</code></pre> <p>The final Structure in the optimization.</p>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.OptimizationResults.final_energy","title":"final_energy  <code>property</code>","text":"<pre><code>final_energy: float | None\n</code></pre> <p>The final energy in the optimization. Is <code>np.nan</code> if final calculation failed.</p>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.OptimizationResults.energies","title":"energies  <code>property</code>","text":"<pre><code>energies: ndarray\n</code></pre> <p>The energies for each step of the optimization.</p>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.OptimizationResults.structures","title":"structures  <code>property</code>","text":"<pre><code>structures: list[Structure]\n</code></pre> <p>The Structure objects for each step of the optimization.</p>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.OptimizationResults.molecules","title":"molecules  <code>property</code>","text":"<pre><code>molecules: list[Structure]\n</code></pre> <p>The Structure objects for each step of the optimization.</p>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.OptimizationResults.return_result","title":"return_result","text":"<pre><code>return_result(calctype: CalcType) -&gt; Structure | None\n</code></pre> <p>Return the primary result of the calculation.</p> Source code in <code>qcio/models/outputs.py</code> <pre><code>def return_result(self, calctype: CalcType) -&gt; Structure | None:\n    \"\"\"Return the primary result of the calculation.\"\"\"\n    return self.final_structure\n</code></pre>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.OptimizationResults.to_xyz","title":"to_xyz","text":"<pre><code>to_xyz() -&gt; str\n</code></pre> <p>Return the trajectory as an <code>xyz</code> string.</p> Source code in <code>qcio/models/outputs.py</code> <pre><code>def to_xyz(self) -&gt; str:\n    \"\"\"Return the trajectory as an `xyz` string.\"\"\"\n    return to_multi_xyz(\n        prog_output.input_data.structure for prog_output in self.trajectory\n    )\n</code></pre>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.OptimizationResults.save","title":"save","text":"<pre><code>save(\n    filepath: Path | str,\n    exclude_none: bool = True,\n    exclude_unset: bool = True,\n    indent: int = 4,\n    **kwargs: dict[str, Any],\n) -&gt; None\n</code></pre> <p>Save an OptimizationOutput to a file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Path | str</code> <p>The path to save the molecule to.</p> required <code>exclude_none</code> <code>bool</code> <p>If True, attributes with a value of None will not be written to the file.</p> <code>True</code> <code>exclude_unset</code> <code>bool</code> <p>If True, attributes that have not been set will not be written to the file.</p> <code>True</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional keyword arguments to pass to the json serializer.</p> <code>{}</code> Note <p>If the filepath has a <code>.xyz</code> extension, the trajectory will be saved to a multi-structure <code>xyz</code> file.</p> Source code in <code>qcio/models/outputs.py</code> <pre><code>def save(\n    self,\n    filepath: Path | str,\n    exclude_none: bool = True,\n    exclude_unset: bool = True,\n    indent: int = 4,\n    **kwargs: dict[str, Any],\n) -&gt; None:\n    \"\"\"Save an OptimizationOutput to a file.\n\n    Args:\n        filepath: The path to save the molecule to.\n        exclude_none: If True, attributes with a value of None will not be written\n            to the file.\n        exclude_unset: If True, attributes that have not been set will not be\n            written to the file.\n        **kwargs: Additional keyword arguments to pass to the json serializer.\n\n    Note:\n        If the filepath has a `.xyz` extension, the trajectory will be saved to a\n        multi-structure `xyz` file.\n    \"\"\"\n    filepath = Path(filepath)\n    if filepath.suffix == \".xyz\":\n        filepath.write_text(self.to_xyz())\n        return\n    super().save(filepath, exclude_none, exclude_unset, indent, **kwargs)\n</code></pre>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.ConformerSearchResults","title":"ConformerSearchResults","text":"<p>Results from a conformer search calculation.</p> <p>Conformers and rotamers are sorted by energy.</p> <p>Attributes:</p> Name Type Description <code>conformers</code> <code>list[Structure]</code> <p>The conformers found in the search.</p> <code>conformer_energies</code> <code>SerializableNDArray</code> <p>The energies for each conformer.</p> <code>rotamers</code> <code>list[Structure]</code> <p>The rotamers found in the search.</p> <code>rotamer_energies</code> <code>SerializableNDArray</code> <p>The energies for each rotamer.</p>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.ConformerSearchResults.conformer_energies_relative","title":"conformer_energies_relative  <code>property</code>","text":"<pre><code>conformer_energies_relative: ndarray\n</code></pre> <p>The relative energies for each conformer in the search.</p>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.ConformerSearchResults.rotamer_energies_relative","title":"rotamer_energies_relative  <code>property</code>","text":"<pre><code>rotamer_energies_relative: ndarray\n</code></pre> <p>The relative energies for each rotamer in the search.</p>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.ConformerSearchResults.conformers_filtered","title":"conformers_filtered","text":"<pre><code>conformers_filtered(\n    threshold: float = 0.5, **rmsd_kwargs\n) -&gt; tuple[list[Structure], SerializableNDArray]\n</code></pre> <p>Filter conformers to only unique Structures within rmsd of <code>threshold</code>.</p> <p>Parameters:</p> Name Type Description Default <code>threshold</code> <code>float</code> <p>The RMSD threshold in Angstrom for filtering conformers.</p> <code>0.5</code> <code>**rmsd_kwargs</code> <p>Additional keyword arguments to pass to the rmsd function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple[list[Structure], SerializableNDArray]</code> <p>Tuple of the filtered conformers and their relative energies.</p> Source code in <code>qcio/models/outputs.py</code> <pre><code>def conformers_filtered(\n    self, threshold: float = 0.5, **rmsd_kwargs\n) -&gt; tuple[list[Structure], SerializableNDArray]:\n    \"\"\"Filter conformers to only unique Structures within rmsd of `threshold`.\n\n    Args:\n        threshold: The RMSD threshold in Angstrom for filtering conformers.\n        **rmsd_kwargs: Additional keyword arguments to pass to the rmsd function.\n\n    Returns:\n        Tuple of the filtered conformers and their relative energies.\n    \"\"\"\n    filtered = set()\n\n    for i in range(len(self.conformers)):\n        if i not in filtered:\n            for j in range(i + 1, len(self.conformers)):\n                if (\n                    rmsd(self.conformers[i], self.conformers[j], **rmsd_kwargs)\n                    &lt; threshold\n                ):\n                    filtered.add(j)\n\n    keep_indices = [i for i in range(len(self.conformers)) if i not in filtered]\n    return [\n        self.conformers[i] for i in keep_indices\n    ], self.conformer_energies_relative[keep_indices]\n</code></pre>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.ProgramOutput","title":"ProgramOutput","text":"<pre><code>ProgramOutput(**data: Any)\n</code></pre> <p>The core output object from a quantum chemistry calculation.</p> <p>Attributes:</p> Name Type Description <code>input_data</code> <code>InputType</code> <p>The input data for the calculation. Any of <code>qcio.Inputs</code>.</p> <code>success</code> <code>Literal[True, False]</code> <p>Whether the calculation was successful.</p> <code>results</code> <code>ResultsType</code> <p>The results of the calculation. Contains parsed values and files. Any of <code>qcio.Results</code>.</p> <code>stdout</code> <code>str | None</code> <p>The standard output from the calculation.</p> <code>traceback</code> <code>str | None</code> <p>The traceback from the calculation, if it failed.</p> <code>provenance</code> <code>Provenance</code> <p>The provenance information for the calculation.</p> <code>extras</code> <code>Dict[str, Any]</code> <p>Additional information to bundle with the object. Use for schema development and scratch space.</p> <code>pstdout</code> <code>str</code> <p><code>@property</code> Print the stdout text.</p> <code>ptraceback</code> <code>str</code> <p><code>@property</code> Print the traceback text.</p> Source code in <code>qcio/models/outputs.py</code> <pre><code>def __init__(self, **data: Any):\n    \"\"\"Backwards compatibility for files attribute.\"\"\"\n\n    if \"files\" in data:\n        warnings.warn(\n            \"The 'files' attribute has been moved to 'results.files'. Please \"\n            \"update your code accordingly.\",\n            category=FutureWarning,\n            stacklevel=2,\n        )\n\n        # This moves files from the top level to the results attribute\n        if isinstance(data[\"results\"], dict):\n            results_files_dict = data[\"results\"].get(\"files\", {})\n        else:  # data[\"results\"] is Files, SinglePointResults, OptimizationResults\n            results_files_dict = data[\"results\"].files\n\n        results_files_dict.update(**data.pop(\"files\"))\n\n    super().__init__(**data)\n</code></pre>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.ProgramOutput.pstdout","title":"pstdout  <code>property</code>","text":"<pre><code>pstdout: None\n</code></pre> <p>Print the stdout text</p>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.ProgramOutput.ptraceback","title":"ptraceback  <code>property</code>","text":"<pre><code>ptraceback: None\n</code></pre> <p>Print the traceback text</p>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.ProgramOutput.files","title":"files  <code>property</code>","text":"<pre><code>files: dict[str, str | bytes]\n</code></pre> <p>Return the files attribute.</p>"},{"location":"code-reference/ProgramOutputs/#qcio.models.outputs.ProgramOutput.return_result","title":"return_result  <code>property</code>","text":"<pre><code>return_result: (\n    float | SerializableNDArray | Structure | None\n)\n</code></pre> <p>Return the primary result of the calculation.</p>"},{"location":"code-reference/exceptions/","title":"Exceptions","text":""},{"location":"code-reference/exceptions/#chemcloud.exceptions","title":"chemcloud.exceptions","text":""},{"location":"code-reference/exceptions/#chemcloud.exceptions.BaseError","title":"BaseError","text":"<p>Exception Base for client.</p>"},{"location":"code-reference/exceptions/#chemcloud.exceptions.TimeoutError","title":"TimeoutError","text":"<p>A timeout parameter was exceeded</p>"},{"location":"tutorial/authentication/","title":"Authentication","text":"<p>Authentication is the process of supplying your credentials (usually a username and password) to <code>chemcloud</code> so that you can perform computations. <code>chemcloud</code> provides a few easy ways for you to authenticate. If you do not have a ChemCloud account you can get one for free here or at the address of the ChemCloud server you want to interact with: https://chemcloud.mtzlab.com/signup</p>"},{"location":"tutorial/authentication/#clientconfigure-recommended-for-most-cases","title":"<code>client.configure()</code> (recommended for most cases)","text":"<pre><code>from chemcloud import CCClient\nclient = CCClient()\nclient.configure()\n\u2705 If you dont get have an account please signup at: https://chemcloud.mtzlab.com/signup\nPlease enter your ChemCloud username: your_username@email.com\nPlease enter your ChemCloud password:\nAuthenticating...\n'default' profile configured! Username/password not required for future use of CCClient\n</code></pre> <p>Performing this action will configure your local client by writing authentication tokens to <code>~/.chemcloud/credentials</code>. You will not need to execute <code>configure()</code> ever again. Under the hood <code>CCClient</code> will access your tokens, refresh them when necessary, and keep you logged in to ChemCloud. Note that this will write a file to your home directory with sensitive access tokens, so if you are on a shared computer or using a device where you would not want to write this information to disk do not use this option. If you would like to write the <code>credentials</code> file to a different directory than <code>~/.chemcloud</code>, set the <code>CHEMCLOUD_BASE_DIRECTORY</code> environment variable to the path of interest.</p> <p>You can configure multiple profiles in case you have multiple logins to ChemCloud by passing a profile name to <code>configure()</code>:</p> <pre><code>client.configure('mtz_lab')\n\u2705 If you dont get have an account please signup at: https://chemcloud.mtzlab.com/signup\nPlease enter your ChemCloud username: your_username@email.om\nPlease enter your ChemCloud password:\nAuthenticating...\n'mtz_lab' profile configured! Username/password not required for future use of CCClient\n</code></pre> <p>To use one of these profiles pass the profile option to your client instance. The \"default\" profile is used when no profile name is passed:</p> <pre><code>from chemcloud import CCClient\n# Use default profile\nclient = CCClient()\n\n# Use named profile\nclient = CCClient(profile=\"mtz_lab\")\n</code></pre>"},{"location":"tutorial/authentication/#environment-variables","title":"Environment Variables","text":"<p>You can set your ChemCloud username and password in your environment and the <code>client</code> will find them automatically. Set <code>CHEMCLOUD_USERNAME</code> and <code>CHEMCLOUD_PASSWORD</code>. When you create a client it will find these values and maintain all access tokens in memory only.</p>"},{"location":"tutorial/authentication/#usernamepassword-when-prompted-after-calling-clientcompute","title":"Username/Password when prompted after calling <code>client.compute(...)</code>","text":"<p>If you have not run <code>client.configure()</code> or set environment variables you will be requested for your username and password when you submit a computation to ChemCloud using <code>client.compute(...)</code>. The client will use your username and password to get access tokens and will maintain access tokens for you in memory only. Your login session will be valid for the duration of your Python session.</p>"},{"location":"tutorial/authentication/#pass-usernamepassword-to-client-not-recommended","title":"Pass Username/Password to Client (not recommended)","text":"<p>You can directly pass a username and password to the <code>client</code> object. This is not recommended as it opens up the possibility of your credentials accidentally being committed to your code repo. However, it can be used in rare circumstances when necessary.</p> <pre><code>from chemcloud import CCClient\nclient = CCClient(\n    chemcloud_username=\"your_username@email.com\", chemcloud_password=\"super_secret_password\"  # pragma: allowlist secret\n    )\n</code></pre>"},{"location":"tutorial/batch-computations/","title":"Batch Computations","text":"<p>Calculations can be submitted in bulk by passing a list of <code>Input</code> objects to <code>client.compute()</code> rather than a single object.</p> <pre><code>from qcio import ProgramInput, Structure\n\nfrom chemcloud import CCClient\n\nwater = Structure(\n    symbols=[\"O\", \"H\", \"H\"],\n    geometry=[\n        [0.0000, 0.00000, 0.0000],\n        [0.2774, 0.89290, 0.2544],\n        [0.6067, -0.23830, -0.7169],\n    ],\n)\n\nclient = CCClient()\n\nprog_inp = ProgramInput(\n    structure=water,\n    model={\"method\": \"b3lyp\", \"basis\": \"6-31g\"},\n    calctype=\"energy\",\n    keywords={},\n)\nfuture_result = client.compute(\"psi4\", [prog_inp] * 2)\nprog_output = future_result.get()\n# Array of ProgramOutput objects containing all returned data\nprint(prog_output)\n</code></pre>"},{"location":"tutorial/bigchem-algorithms/","title":"BigChem Algorithms","text":"<p>BigChem implements some of its own concurrent algorithms that leverage its horizontally scalable backend infrastructure. These include a parallel hessian algorithm and parallel frequency analysis algorithm. To use them submit a <code>hessian</code> calculation to ChemCloud using <code>bigchem</code> as the engine. See examples the <code>parallel_hessian.py</code> and <code>parallel_frequency_analysis.py</code> scripts in the examples directory.</p>"},{"location":"tutorial/bigchem-algorithms/#hessian","title":"Hessian","text":"<pre><code>from qcio import DualProgramInput, ProgramOutput, Structure\n\nfrom chemcloud import CCClient\n\nwater = Structure(\n    symbols=[\"O\", \"H\", \"H\"],\n    geometry=[\n        [0.0000, 0.00000, 0.0000],\n        [0.2774, 0.89290, 0.2544],\n        [0.6067, -0.23830, -0.7169],\n    ],\n)\n\nclient = CCClient()\n\nprog_inp = DualProgramInput(\n    structure=water,\n    calctype=\"hessian\",\n    subprogram=\"psi4\",\n    subprogram_args={\"model\": {\"method\": \"b3lyp\", \"basis\": \"6-31g\"}},\n)\n\n\n# Submit calculation\nfuture_result = client.compute(\"bigchem\", prog_inp)\nprog_output: ProgramOutput = future_result.get()\n\n# ProgramOutput object containing all returned data\nprint(prog_output)\nprint(prog_output.results.hessian)\n# Frequency data always included too\nprint(f\"Wavenumbers: {prog_output.results.freqs_wavenumber}\")\nprint(prog_output.results.normal_modes_cartesian)\nprint(prog_output.results.gibbs_free_energy)\n</code></pre>"},{"location":"tutorial/bigchem-algorithms/#frequency-analysis","title":"Frequency Analysis","text":"<pre><code>from qcio import DualProgramInput, ProgramOutput, Structure\n\nfrom chemcloud import CCClient\n\nwater = Structure(\n    symbols=[\"O\", \"H\", \"H\"],\n    geometry=[\n        [0.0000, 0.00000, 0.0000],\n        [0.2774, 0.89290, 0.2544],\n        [0.6067, -0.23830, -0.7169],\n    ],\n)\n\nclient = CCClient()\n\nprog_inp = DualProgramInput(\n    structure=water,\n    calctype=\"hessian\",\n    subprogram=\"psi4\",\n    subprogram_args={\"model\": {\"method\": \"b3lyp\", \"basis\": \"6-31g\"}},\n)\n\n\n# Submit calculation\nfuture_result = client.compute(\"bigchem\", prog_inp)\nprog_output: ProgramOutput = future_result.get()\n\n# ProgramOutput object containing all returned data\nprint(prog_output)\nprint(f\"Wavenumbers: {prog_output.results.freqs_wavenumber}\")\nprint(prog_output.results.normal_modes_cartesian)\nprint(prog_output.results.gibbs_free_energy)\n</code></pre> <p>Keywords for the BigChem algorithms:</p> Keyword Type Description Default Value <code>dh</code> <code>float</code> Displacement for gradient geometries for finite difference <code>5.0e-3</code> <code>temperature</code> <code>float</code> Temperature passed to the harmonic free energy module <code>300.0</code> <code>pressure</code> <code>float</code> Pressure passed to the harmonic free energy module <code>1.0</code>"},{"location":"tutorial/compute/","title":"Compute","text":"<p>Computations are physically executed by a BigChem instance fronted by a ChemCloud server. The chemcloud python client submits jobs to and retrieves work from the ChemCloud server. Computations are submitted using the CCClient object.</p> <p>Computations require a QC program and <code>ProgramInput</code> or <code>DualProgramInput</code> object. The <code>ProgramInput</code> object contains all the information necessary to run a single calculation. The <code>DualProgramInput</code> object is used when two QC programs are used in tandem, such as when performing a geometry optimization with one program that uses a subprogram for the energy and gradient calculations.</p>"},{"location":"tutorial/compute/#basic-single-point-calculation","title":"Basic Single Point Calculation","text":"<pre><code>from qcio import ProgramInput, ProgramOutput, Structure\n\nfrom chemcloud import CCClient\n\nwater = Structure(\n    symbols=[\"O\", \"H\", \"H\"],\n    geometry=[\n        [0.0000, 0.00000, 0.0000],\n        [0.2774, 0.89290, 0.2544],\n        [0.6067, -0.23830, -0.7169],\n    ],\n)\n\nclient = CCClient()\n\nprog_inp = ProgramInput(\n    structure=water,\n    model={\"method\": \"b3lyp\", \"basis\": \"6-31g\"},\n    calctype=\"energy\",  # Or \"gradient\" or \"hessian\"\n    keywords={},\n)\nfuture_result = client.compute(\"terachem\", prog_inp, collect_files=True)\nprog_output: ProgramOutput = future_result.get()\n# ProgramOutput object containing all returned data\nprint(prog_output.stdout)\nprint(prog_output)\n# The energy value requested\n\nif prog_output.success:\n    print(prog_output.results.energy)\n    print(prog_output.results.files.keys())\nelse:\n    print(prog_output.traceback)\n</code></pre>"},{"location":"tutorial/compute/#including-files-in-the-input","title":"Including Files in the Input","text":"<pre><code>from qcio import ProgramInput, ProgramOutput, Structure\n\nfrom chemcloud import CCClient\n\nwater = Structure(\n    symbols=[\"O\", \"H\", \"H\"],\n    geometry=[\n        [0.0000, 0.00000, 0.0000],\n        [0.2774, 0.89290, 0.2544],\n        [0.6067, -0.23830, -0.7169],\n    ],\n)\n\nclient = CCClient()\n\nprog_inp = ProgramInput(\n    structure=water,\n    model={\"method\": \"b3lyp\", \"basis\": \"6-31g\"},\n    calctype=\"energy\",\n    keywords={\"guess\": \"c0\"},\n    files={\n        \"c0\": b'\\xdf4R\\xdea\\xd7\\xef?\\xc1-\\xbdg2\\xd0\\xca?\\x8e\\xc4\\x94\\x02\\xe5\\xcd\\xae\\xbe\\xd9kP\\xd8R2\\xb7\\xbfhV\\xc1\\x136\\xe5\\xbe\\xbe\\xad\\x0b#2\\xabp\\xb6?\\xe9\\x91\\x99\\xbf\\xd7\\xe9e&gt;LQ\\x05\\xa4F\\xaa\\xa6&gt;&gt;k\\xab\\xa4\\xd4j\\xa1\\xbf\\xd1#\\xbf\\x14\\t\\xdf\\xd8&gt;\\x99Qq\\x1b\\x07\\x0b\\xb4?$*\\x0ed\\x95\\x91\\x97\\xbe\\r\\xc8\\xfb\\xca\\xbb\\x82\\xab?\\'d\\x0c-Y\\x8e\\x9c?\\x8c\\x10\\xf1\\xd9I\\xb5\\xdd\\xbf\\xf7\\xea%X\\xd0\\x02\\xbf&gt;==urA\\xc8\\xc9?\\xe0f\\xbb#^\\t\\xc8&gt;\\xe3\\xfb\\x8b\\xc2C\\x94\\xc3\\xbf\\xd0]m\\x85\\xd1\\xd7\\xb5&gt;\\xa2\\x1c\\x03Un0\\xd6\\xbe\\xc1\\x90\\xb8\\xec\\n\"\\xc9??\\xd3\\x90\\x80q\\xeb\\x06\\xbf,\\xa9\\x0f\\xc0\\x8dZ\\xdf\\xbf% \\xcc\\x86L\\x85\\xc2\\xbe\\xdf\\xae\\xb07\\xe4\\x91\\xfa\\xbf\\xa9\\x97q\\x07\\xff\\xd0\\x8a\\xbf\\x04\\xad\\xabq\\xc8\\xed\\xdc\\xbf\\xb3]B\\x0c\\xcc\\xa4\\xca&gt;\\x00\\xaaX\\xed\\xd7\\xe9\\xd7?\\xa5\\xbf\\xc0\\x05O\\xb2\\xe1&gt;&gt;c\\x1f\\xef\\x924\\xf1\\xbf\\xf9\\xac0\\xe1r-\\xcf\\xbe\\xe3]\\x92[g\\x18\\xe4&gt;Zm8\\x07@\\xbd\\xd2\\xbf\\xae\\x86\\xa3\\x19Hl\\x0b?e\\xb2\\x81\\xdd\\xdbz\\xc0?\\xc04\\xaea,1\\xe0&gt;t&amp;x\\xceH\\xf5\\x05@\\xc7\\'\\xb0\\xb9\\xd1g#?\\x82Hm\\x14\\xba\\x14\\xc3\\xbfT\\x19p\\xa8T\\x00\\xd1?\\xc5 \\xfc\\xae\\xabf\\xc2\\xbfm2\\xf0t\\xde\\x84\\xd0\\xbe#(\\x16bTh\\xb9?\\xd7i&amp;\\x01\\xc8\\xb7\\xb9?\\x02\\xdc\\xe5m\\xea\\n\\xef\\xbf\\xf6\\xfb\\x86\\n\\x97O\\xe7\\xbfX\\xe7\\xdfb\\x00\\xb8\\x1d?\\x19!\\x83a\\xb5\\xeb\\xe4?\\xa5\\x0b\\xf5&gt;wJ\\x9e?\\xcf\\xdb\\x884z\\xee\\xde\\xbf\\xea\\xbf\\xa7\\xd3@\\xd7h?F5\\x9b\\x1f\\x93\"@\\xbf/\\x8d\\x1e.\\x84o\\xc3?\\x08!\\xa9\\\\\\xc5d\\xbb\\xbf=\\x18s\\x1a\\xf6\\xa3\\xd2\\xben\\xf7\\x8e\\xb5B\\xbe\\xed?\\x96\\xd0:\\xeb\\xbdI\\xf4?\\xa1b\\x81\\x15QU\\xe6?7\\xf1\\xb6\\xac\\xd4i\\xe3?\\xc2\\xf35\\x18\\xc7\\x90\\x10\\xbf\\xc4 \\xf3\\xe5\\x93\\x94\\xc6\\xbfE\\x96\\xe1\\xa1\\xb2\\xe6\\xec?b\\xf4\\xd8K\\x1a|\\xe3\\xbf\\xabKE\\x9a+g#?I&gt;t\\xa1\\xc7\\x14\\xc3\\xbfM\\xd7\\x13\\xb7V\\x00\\xd1\\xbf\\xc4\\x1e\\xf1\\x02\\xa1f\\xc2\\xbf\\x16\\x8d\\x03l\\xd3\\x8e\\xa6\\xbe\\xdd$uFwh\\xb9?\\xcap6\\x18\\xfd\\xb7\\xb9\\xbf|\\xff&amp;\\xa8/\\x0b\\xef?\\x8c+\\x9eG0O\\xe7\\xbf\\xf6\\xfd$\\x1eY\\xdc\\x15?4L\\x99\\xf7\\xbd\\xeb\\xe4?\\xdd=\\xbaD\\xdbM\\x9e\\xbff\\x04*Q\\x81\\xee\\xde\\xbfZ\\x12\\x87\\x8eF\\xd7h?\\n6\\xbd1\\x84&amp;@\\xbf \\xbd#\\x84\\x88o\\xc3\\xbf\\xf2\\x9bj\\x08\\x9dd\\xbb\\xbf\\xcc\\x90aR\\xded\\xb8&gt;\\x18\\xcd\\t\\xf5H\\xbe\\xed?\\xdaw\\x8a\\xa3\\xb6I\\xf4\\xbf\\t\\xe3\\xf8\\xf0\\x92U\\xe6\\xbf\\x83\\xe8\\x9d\\x93\\xadi\\xe3?p\\x0bF\\xfe\\x9a\\x11\\x18\\xbf\\xd9A\\xc7g\\xc4\\x94\\xc6\\xbf\\x8e\\xdd\\xeb\\xa4\\xb0\\xe6\\xec\\xbfJ\\xb6@\\xbb\\x15|\\xe3\\xbf\\x08\\xe1\\xfa\\xa9\\xc0\\xb1Z?\\xf2\\x88\\x88!\\xff\\xaa\\xbc\\xbf[.\\xb8e\\xa8x\\xbc\\xbf\\x07\\x90nr\\xb8\\xc3\\xd9\\xbf4\\x99\\xf9\\x99\\x80Q\\xda\\xbf\\x05\\xd8$t\\x9e\\xfc\\xcb\\xbf\\xf5\\xfe|\\xa6gH\\xb7?\\xbf\\x0e\\xb8L@V\\xa6\\xbf\\xc8\\xa2\\x05\\x84\\xba\\x05\\xe2?\\xa2I\\xa0\\x1f\\x9f\\x80\\xe3\\xbfGv\\xefeG\\\\\\xdc?\\xeb\\x18\\xd63\\xc1\\x19\\xcb\\xbfW\"\\xb9\\x87P\\x92\\xc1\\xbf\\x05\\x13\\xa3IY\\xc3S?\\xa8\\xa2\\x18?\\x0e9\\xb5\\xbf \\xd9\\xcbJNq\\xd8?x\\xa8\\xa4/6\\x13\\xd3\\xbf\\xbdLJA\\xcc\\n\\xd0?\\xb6i\\xb5\\x01\\x1b\\xb8\\xc4\\xbf\\xa7eF\\xef.\\xfd\\xd3\\xbf\\rf\\x06.Z*\\xc3?\\x0b\\xaf\\xbb\\xe4\\xe1\\xb0\\xda?u\\x91\\xb0I\\x9d\\xc5\\xd7?^\\x9c\\xffh\\xa3\\xfe\\xd4?\\xdf\\x0ec\\xf3\\xc0D\\xe7?`\\xd6\\xfb\\xfd\\xf3\\x04\\xba\\xbf\\x8c\\xf1\\xcd\\x98\\x93\\xedK\\xbfv\"!\\xed\\x91\\xfd\\xad?ey\\xdd\\x08\\xc5\\xfc\\xd4?r\\xb7&gt;\\\\\\x83\\xf4\\xca?\\x84M\\xaf\\x8f\\xbb\\x9b\\xdb\\xbfk\\xa36\\xd6UG\\xbd?\\xd9\\xfd\\x0f\\x18\\xdb)\\xd1\\xbf\\xfb`\\x8e\\xf0\\xf0t\\xc0?9\\x1f\\x0b\\xb9h\\xdc\\xd2\\xbf\\xadk\\t_\\xa5t\\xe4\\xbf\\xc1dH\\r`\\xaa\\xcd\\xbf\\xb8\\xbe\\xa9n\\xea\\xfa\\xe3?\\xaa\\x927\\x94 b\\xb2?\\'\\x84E8\\x0e\\x84`\\xbf\\xcf\\xc9\\xaa$\\xae\\xaf\\xaa\\xbf\\xefb}_82\\xaa\\xbf\\xd4\\xfeS\\xc3N\\xc0\\xd1\\xbf\\xdf\\xd5k\\x1b\\x08\\x8b\\xd4\\xbf\\xcf\\x02\\xa6\\xe9\\xaa=\\xd5\\xbfLI\\xad\\x02m\\xb6\\xc4?\\xe9=\\x13\\xecr\\xe2\\xba\\xbf\\xd4\\xf5\\x91\\xd75\\xfb\\xd5\\xbfa\\xaa\\xb0\\x86S*\\xe5?#\\x92\\xd8\\x85\\x1f\\x8d\\xea\\xbf\\x04\\x8e\\xfa\\xde\\xe4\\xf1\\xd6?\\xdd\\xf3\\xc8[.\\xc9\\xe4?\\xae\\xef\\x9f\\x01{tX\\xbf\\xfdG\\xb1\\xd6\\xa1\\xc1\\xa3\\xbfe\\xa4\\xa5\\xacy}\\xc6?/\\xe3&gt;s\\xcfH\\xca\\xbf\\xb4\\xe7\\xd4\\xf9\\x0e\\x0b\\xc9?\\xe0\\xf7\\xf8B]s\\xcf\\xbf/$\\x91\\x9dh\\xc8\\xe1\\xbfk\\xa6\\x86\\xed\\xfd\\x15\\xd7?\\x9fo\\xed~OG\\xd0\\xbft9\\xe6\\xcd\\xa9\\xcd\\xd9\\xbfa\\xa6&gt;\"\\xeb\\xa7\\xe3\\xbfj?\\xea\\xd6\\x11\\xb3\\xf3\\xbf\\xf2=JS\\xf6\\xc6\\xde?9BT]PGQ?\\xe9\\x80\\xd0\\x08\\xfe\\xea\\x9b?\\xf5G\\xb1\\x83\\xa0O\\xc3?\\xef\\x96y[9\\x92\\xc2?\\xc7\\xb6\\xd7\\x87\\xce\\x8c\\xd5\\xbf\\xd1Q\\x02l\\x958\\xc6?C\\xd8\\x13\\x1c\\xdb\\x89\\xde\\xbf2\\x02y\\'\\xa4\\xd2\\xd3?^\\xef\\x1f\\xd70\\x03\\xc7?\\xacm2\\x05s3\\xe6?\\xc0\\xde\\x00pP\\xc6\\xdb?\\x0fx\\x8c\\xdfP\\xea\\xf0\\xbf\\xa7\\xd4\\x80E\\xc9\\xbe\\xd5\\xbf'  # noqa: E501\n    },\n)\nfuture_result = client.compute(\"terachem\", prog_inp, collect_files=True)\nprog_output: ProgramOutput = future_result.get()\n# ProgramOutput object containing all returned data\nprint(prog_output.stdout)\nprint(prog_output)\n# The energy value requested\nprint(prog_output.results.energy)\nprint(prog_output.results.files.keys())\n</code></pre> <p>Files can also be added to an input objects using the <code>open_file</code> method.</p> <pre><code>prog_input.open_file(\"some_file.dat\")\n</code></pre>"},{"location":"tutorial/geometry-optimization/","title":"Geometry optimization","text":""},{"location":"tutorial/geometry-optimization/#basic-working-example","title":"Basic Working Example","text":"<pre><code>from qcio import DualProgramInput, OptimizationOutput, Structure\n\nfrom chemcloud import CCClient\n\nwater = Structure(\n    symbols=[\"O\", \"H\", \"H\"],\n    geometry=[\n        [-0.11904094, -0.36695321, -0.21996706],\n        [1.24615604, -0.14134141, 0.99915579],\n        [-0.24300973, 1.16287522, -1.24168873],\n    ],\n)\n\nclient = CCClient()\n\nprog_inp = DualProgramInput(\n    structure=water,\n    calctype=\"optimization\",\n    keywords={\"maxiter\": 25},\n    subprogram=\"psi4\",\n    subprogram_args={\"model\": {\"method\": \"b3lyp\", \"basis\": \"6-31g\"}},\n)\n\n\n# Submit calculation\nfuture_result = client.compute(\"geometric\", prog_inp)\noutput: OptimizationOutput = future_result.get()\n\nif output.success:\n    print(\"Optimization succeeded!\")\n    # Will be OptimizationResult object\n    print(output)\n    # The final structure of the geometry optimization\n    print(output.results.final_structure)\n    # Initial structure\n    print(output.input_data.structure)\n    # A list of ordered AtomicResult objects for each step in the optimization\n    print(output.results.trajectory)\n    # A list of ordered energies for each step in the optimization\n    print(output.results.energies)\nelse:\n    print(\"Optimization failed!\")\n    # Will be FailedOperation object\n    print(output)\n    # Error information\n    print(output.traceback)\n</code></pre>"},{"location":"tutorial/geometry-optimization/#using-force-fields","title":"Using Force Fields","text":"<p><code>rdkit</code> can be specified as a compute backend to perform optimizations using force field methods instead of quantum chemistry backends. To use <code>rdkit</code> force field methods simply modify the model specification and <code>subprogram</code> specification as shown below. Also note that <code>rdkit</code> requires the molecular connectivity to be defined.</p> <pre><code>water = Structure(\n    symbols=[\"O\", \"H\", \"H\"],\n    geometry=[\n        [0.0000, 0.00000, 0.0000],\n        [0.2774, 0.89290, 0.2544],\n        [0.6067, -0.23830, -0.7169],\n    ],\n    # Add bond connectivity to water (from_atom, to_atom, bond_order)\n    connectivity=[(0, 1, 1.0), (0, 2, 1.0)],\n)\n\nopt_input = DualProgramInput(\n    ...\n    subprogram=\"rdkit\",\n    subprogram_args={\"model\": {\"method\": \"UFF\"}} # or any other force field\n)\n\nfuture_output = client.compute(\"geometric\", opt_input)\n</code></pre>"},{"location":"tutorial/geometry-optimization/#berny-specifics","title":"Berny Specifics","text":"<p>The <code>berny</code> procedure uses the pyberny package to perform a geometry optimization. <code>berny</code> specific keywords are subject to change as the <code>berny</code> package evolves, but for simplicity a short list is included here with default values noted:</p> Keyword Description Default Value <code>maxsteps</code> Maximum number of steps in the optimization <code>100</code> <code>gradientmax</code> Convergence criteria (AU) <code>0.45e-3</code> <code>gradientrms</code> Convergence criteria (AU) <code>0.15e-3</code> <code>stepmax</code> Step in internal coordinates, assuming radian units for angles (AU) <code>1.8e-3</code> <code>steprms</code> Step in internal coordinates, assuming radian units for angles (AU) <code>0.45e-3</code> <code>trust</code> Initial trust radius in AU. It is the maximum RMS of the quadratic step <code>0.3</code> <code>dihedral</code> Form dihedral angles <code>True</code> <code>superweakdih</code> Form dihedral angles containing two or more noncovalent bonds <code>False</code>"},{"location":"tutorial/geometry-optimization/#geometric-specifics","title":"geomeTRIC Specifics","text":"<p>The <code>geometric</code> procedure uses the geomeTRIC package to perform a geometry optimization. <code>geomeTRIC</code> specific keywords are subject to change as the <code>geomeTRIC</code> package evolves. Since <code>geomeTRIC</code> has considerably more keywords, here's the source code that defines various parameters for an optimization. Keywords noted below can be included in the <code>OptimizationInput</code> keywords dictionary. If these options are overwhelming, keep in mind you can run both the <code>berny</code> and <code>geometric</code> optimizers without any keywords and the optimizers will use sensible defaults.</p> <pre><code>class OptParams(object):\n    \"\"\"\n    Container for optimization parameters.\n    The parameters used to be contained in the command-line \"args\",\n    but this was dropped in order to call Optimize() from another script.\n    \"\"\"\n    def __init__(self, **kwargs):\n        # Whether we are optimizing for a transition state. This changes a number of default parameters.\n        self.transition = kwargs.get('transition', False)\n        # CI optimizations sometimes require tiny steps\n        self.meci = kwargs.get('meci', False)\n        # Handle convergence criteria; this edits the kwargs\n        self.convergence_criteria(**kwargs)\n        # Threshold (in a.u. / rad) for activating alternative algorithm that enforces precise constraint satisfaction\n        self.enforce = kwargs.get('enforce', 0.0)\n        # Small eigenvalue threshold\n        self.epsilon = kwargs.get('epsilon', 1e-5)\n        # Interval for checking the coordinate system for changes\n        self.check = kwargs.get('check', 0)\n        # More verbose printout\n        self.verbose = kwargs.get('verbose', False)\n        # Starting value of the trust radius\n        # Because TS optimization is experimental, use conservative trust radii\n        self.trust = kwargs.get('trust', 0.01 if self.transition else 0.1)\n        # Maximum value of trust radius\n        self.tmax = kwargs.get('tmax', 0.03 if self.transition else 0.3)\n        # Minimum value of the trust radius\n        self.tmin = kwargs.get('tmin', 0.0 if (self.transition or self.meci) else min(1.2e-3, self.Convergence_drms))\n        # Minimum size of a step that can be rejected\n        self.thre_rj = kwargs.get('thre_rj', 1e-4 if (self.transition or self.meci) else 1e-2)\n        # Sanity checks on trust radius\n        if self.tmax &lt; self.tmin:\n            raise ParamError(\"Max trust radius must be larger than min\")\n        # The trust radius should not be outside (tmin, tmax)\n        self.trust = min(self.tmax, self.trust)\n        self.trust = max(self.tmin, self.trust)\n        # Maximum number of optimization cycles\n        self.maxiter = kwargs.get('maxiter', 300)\n        # Use updated constraint algorithm implemented 2019-03-20\n        self.conmethod = kwargs.get('conmethod', 0)\n        # Write Hessian matrix at optimized structure to text file\n        self.write_cart_hess = kwargs.get('write_cart_hess', None)\n        # Output .xyz file name may be set separately in\n        # run_optimizer() prior to calling Optimize().\n        self.xyzout = kwargs.get('xyzout', None)\n        # Name of the qdata.txt file to be written.\n        # The CLI is designed so the user passes true/false instead of the file name.\n        self.qdata = 'qdata.txt' if kwargs.get('qdata', False) else None\n        # Whether to calculate or read a Hessian matrix.\n        self.hessian = kwargs.get('hessian', None)\n        if self.hessian is None:\n            # Default is to calculate Hessian in the first step if searching for a transition state.\n            # Otherwise the default is to never calculate the Hessian.\n            if self.transition: self.hessian = 'first'\n            else: self.hessian = 'never'\n        if self.hessian.startswith('file:'):\n            if os.path.exists(self.hessian[5:]):\n                # If a path is provided for reading a Hessian file, read it now.\n                self.hess_data = np.loadtxt(self.hessian[5:])\n            else:\n                raise IOError(\"No Hessian data file found at %s\" % self.hessian)\n        elif self.hessian.lower() in ['never', 'first', 'each', 'stop', 'last', 'first+last']:\n            self.hessian = self.hessian.lower()\n        else:\n            raise RuntimeError(\"Hessian command line argument can only be never, first, last, first+last, each, stop, or file:&lt;path&gt;\")\n        # Perform a frequency analysis whenever a cartesian Hessian is computed\n        self.frequency = kwargs.get('frequency', None)\n        if self.frequency is None: self.frequency = True\n        # Temperature and pressure for harmonic free energy\n        self.temperature, self.pressure = kwargs.get('thermo', [300.0, 1.0])\n        # Number of desired samples from Wigner distribution\n        self.wigner = kwargs.get('wigner', 0)\n        if self.wigner and not self.frequency:\n            raise ParamError('Wigner sampling requires frequency analysis')\n        # Reset Hessian to guess whenever eigenvalues drop below epsilon\n        self.reset = kwargs.get('reset', None)\n        if self.reset is None: self.reset = not (self.transition or self.meci or self.hessian == 'each')\n</code></pre> <p>And convergence criteria:</p> <pre><code>def convergence_criteria(self, **kwargs):\n        criteria = kwargs.get('converge', [])\n        if len(criteria)%2 != 0:\n            raise RuntimeError('Please pass an even number of options to --converge')\n        for i in range(int(len(criteria)/2)):\n            key = 'convergence_' + criteria[2*i].lower()\n            try:\n                val = float(criteria[2*i+1])\n                logger.info('Using convergence criteria: %s %.2e\\n' % (key, val))\n            except ValueError:\n                # This must be a set\n                val = str(criteria[2*i+1])\n                logger.info('Using convergence criteria set: %s %s\\n' % (key, val))\n            kwargs[key] = val\n        # convergence dictionary to store criteria stored in order of energy, grms, gmax, drms, dmax\n        # 'GAU' contains the default convergence criteria that are used when nothing is passed.\n        convergence_sets = {'GAU': [1e-6, 3e-4, 4.5e-4, 1.2e-3, 1.8e-3],\n                            'NWCHEM_LOOSE': [1e-6, 3e-3, 4.5e-3, 3.6e-3, 5.4e-3],\n                            'GAU_LOOSE': [1e-6, 1.7e-3, 2.5e-3, 6.7e-3, 1e-2],\n                            'TURBOMOLE': [1e-6, 5e-4, 1e-3, 5.0e-4, 1e-3],\n                            'INTERFRAG_TIGHT': [1e-6, 1e-5, 1.5e-5, 4.0e-4, 6.0e-4],\n                            'GAU_TIGHT': [1e-6, 1e-5, 1.5e-5, 4e-5, 6e-5],\n                            'GAU_VERYTIGHT': [1e-6, 1e-6, 2e-6, 4e-6, 6e-6]}\n        # Q-Chem style convergence criteria (i.e. gradient and either energy or displacement)\n        self.qccnv = kwargs.get('qccnv', False)\n        # Molpro style convergence criteria (i.e. gradient and either energy or displacement, with different defaults)\n        self.molcnv = kwargs.get('molcnv', False)\n        # Check if there is a convergence set passed else use the default\n        set_name = kwargs.get('convergence_set', 'GAU').upper()\n        # If we have extra keywords apply them here else use the set\n        # Convergence criteria in a.u. and Angstrom\n        self.Convergence_energy = kwargs.get('convergence_energy', convergence_sets[set_name][0])\n        self.Convergence_grms = kwargs.get('convergence_grms', convergence_sets[set_name][1])\n        self.Convergence_gmax = kwargs.get('convergence_gmax', convergence_sets[set_name][2])\n        self.Convergence_drms = kwargs.get('convergence_drms', convergence_sets[set_name][3])\n        self.Convergence_dmax = kwargs.get('convergence_dmax', convergence_sets[set_name][4])\n        # Convergence criteria that are only used if molconv is set to True\n        self.Convergence_molpro_gmax = kwargs.get('convergence_molpro_gmax', 3e-4)\n        self.Convergence_molpro_dmax = kwargs.get('convergence_molpro_dmax', 1.2e-3)\n</code></pre>"},{"location":"tutorial/supported-programs/","title":"Supported programs","text":"<p>Supported compute engines in chemcloud can be checked as follows:</p> <pre><code>from chemcloud import CCClient\n\nclient = CCClient()\nclient.supported_engines\n[\"psi4\", \"terachem_fe\", \"rdkit\", ...]\n</code></pre> <p>Please see BigChem Algorithms for details on parallel execution algorithms unique to the BigChem compute engine.</p>"}]}